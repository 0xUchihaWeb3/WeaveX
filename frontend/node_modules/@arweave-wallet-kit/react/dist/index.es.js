"use client";
(function(){"use strict";try{if(typeof document<"u"){var e=document.createElement("style");e.appendChild(document.createTextNode(".b1cb9caz{display:-webkit-box;display:-webkit-flex;display:-ms-flexbox;display:flex;font-family:Manrope,sans-serif;font-size:.9rem;font-weight:600;color:#fff;background-color:rgb(var(--b1cb9caz-0));border-radius:var(--b1cb9caz-1);padding:.3rem .8rem;text-align:center;border:none;outline:none;text-transform:uppercase;cursor:pointer;-webkit-align-items:center;-webkit-box-align:center;-ms-flex-align:center;align-items:center;-webkit-box-pack:center;-ms-flex-pack:center;-webkit-justify-content:center;justify-content:center;gap:.4rem;white-space:nowrap;-webkit-tap-highlight-color:transparent;-webkit-transition:all .18s ease-in-out;transition:all .18s ease-in-out}.b1cb9caz:hover:not(:active):not(:disabled){-webkit-transform:translate3d(0px,-1.4px,0px);-moz-transform:translate3d(0px,-1.4px,0px);-ms-transform:translate3d(0px,-1.4px,0px);transform:translate3d(0,-1.4px,0);box-shadow:var(--b1cb9caz-2)}.b1cb9caz:disabled{opacity:.7;cursor:not-allowed}.b1cb9caz svg{font-size:1em;width:1em;height:1em}.w14emrir{border-radius:var(--w14emrir-0);text-transform:none;padding:.3rem;background-color:var(--w14emrir-1)}.czh4f0e{line-height:2.6rem;padding:0 .9rem}.pwkn5es{display:-webkit-box;display:-webkit-flex;display:-ms-flexbox;display:flex;-webkit-align-items:center;-webkit-box-align:center;-ms-flex-align:center;align-items:center;background-color:rgb(var(--pwkn5es-0),.2);height:2.6rem;border-radius:var(--pwkn5es-1);padding:0 .3rem 0 .6rem;gap:.25rem}.bdt02oh{padding:0 .5rem}.e3hlv71{font-size:1.5rem!important}.a1jsmwxp{-webkit-user-select:none;-moz-user-select:none;-ms-user-select:none;user-select:none;border-radius:var(--a1jsmwxp-0);object-fit:cover;width:1.7rem;height:1.7rem;margin-right:.4rem}.as6ir6f{font-size:1rem!important;color:#fff}.av7js2i{position:relative;border-radius:var(--av7js2i-0);width:1.7rem;height:1.7rem;margin-right:.4rem;background:linear-gradient(to right,#4776e6,#8e54e9);-webkit-background-size:cover;background-size:cover}.av7js2i .as6ir6f{position:absolute;top:50%;left:50%;-webkit-transform:translate(-50%,-50%);-moz-transform:translate(-50%,-50%);-ms-transform:translate(-50%,-50%);transform:translate(-50%,-50%)}.bbvkbel{position:fixed;top:0;left:0;right:0;bottom:0;width:100vw;height:100vh;z-index:90000;background-color:#0006}.w1767o4q{position:fixed;left:50%;top:50%;width:28vw;background-color:rgb(var(--w1767o4q-0));border-radius:var(--w1767o4q-1);z-index:100000;font-family:Manrope,sans-serif;overflow:hidden;-webkit-transition:background-color .23s ease-in-out,height .17s ease;transition:background-color .23s ease-in-out,height .17s ease}.w1767o4q *::selection{background-color:#000000bf;color:#fff}.w1767o4q *::-moz-selection{background-color:#000000bf;color:#fff}@media screen and (max-width: 1080px){.w1767o4q{width:50vw}}@media screen and (max-width: 720px){.w1767o4q{width:100vw;top:unset;bottom:0;border-bottom-left-radius:0;border-bottom-right-radius:0}}.kzdiz37{position:fixed;font-family:Manrope,sans-serif;font-size:.8rem;font-weight:500;-webkit-user-select:none;-moz-user-select:none;-ms-user-select:none;user-select:none;cursor:default;text-align:center;margin:0;color:#ffffff80;left:50%;bottom:10px;-webkit-transform:translateX(-50%);-moz-transform:translateX(-50%);-ms-transform:translateX(-50%);transform:translate(-50%)}@media screen and (max-width: 720px){.kzdiz37{bottom:unset;top:10px}}.b7jc8fb{display:-webkit-box;display:-webkit-flex;display:-ms-flexbox;display:flex;-webkit-align-items:center;-webkit-box-align:center;-ms-flex-align:center;align-items:center;gap:1.24rem;padding:.75rem 1rem;border-radius:var(--b7jc8fb-0);border-radius:15px;bottom:0;right:1.5rem;left:unset;top:unset;width:auto}@media screen and (max-width: 720px){.b7jc8fb{left:1.5rem;gap:1rem}}.cypmncv{display:-webkit-box;display:-webkit-flex;display:-ms-flexbox;display:flex;-webkit-align-items:center;-webkit-box-align:center;-ms-flex-align:center;align-items:center;gap:1.24rem}.t14qolsb{font-size:1.05rem;font-weight:500;color:rgb(var(--t14qolsb-0));margin:0}.b1jq17m8{display:-webkit-box;display:-webkit-flex;display:-ms-flexbox;display:flex;-webkit-align-items:center;-webkit-box-align:center;-ms-flex-align:center;align-items:center;gap:.6rem}@media screen and (max-width: 720px){.b1jq17m8{-webkit-flex-direction:column;-ms-flex-direction:column;flex-direction:column}.b1jq17m8 button{width:100%}}.c4cavtk{background-color:transparent;color:rgb(var(--c4cavtk-0))}.c4cavtk:hover{background-color:rgba(var(--c4cavtk-1),.05);color:rgb(var(--c4cavtk-1));box-shadow:none!important}.wzg6vks{display:-webkit-box;display:-webkit-flex;display:-ms-flexbox;display:flex;-webkit-align-items:center;-webkit-box-align:center;-ms-flex-align:center;align-items:center;-webkit-box-pack:justify;-webkit-justify-content:space-between;justify-content:space-between;padding:0 20px}.a1vzc1qt{display:-webkit-box;display:-webkit-flex;display:-ms-flexbox;display:flex;-webkit-align-items:center;-webkit-box-align:center;-ms-flex-align:center;align-items:center;gap:.8rem}.l1rbotc6{width:60%;height:60%;-webkit-user-select:none;-moz-user-select:none;-ms-user-select:none;user-select:none;object-fit:contain}.acuhj7u{position:relative;width:3.8rem;height:3.8rem;border-radius:var(--acuhj7u-0);background-color:rgb(var(--acuhj7u-1));-webkit-flex-shrink:0;-ms-flex-negative:0;flex-shrink:0;-webkit-tap-highlight-color:transparent;cursor:var(--acuhj7u-2);-webkit-transition:-webkit-transform .125s ease;transition:transform .125s ease}.acuhj7u .l1rbotc6{position:absolute;top:50%;left:50%;-webkit-transform:translate(-50%,-50%);-moz-transform:translate(-50%,-50%);-ms-transform:translate(-50%,-50%);transform:translate(-50%,-50%)}.acuhj7u:active{-webkit-transform:scale(var(--acuhj7u-3));-moz-transform:scale(var(--acuhj7u-3));-ms-transform:scale(var(--acuhj7u-3));transform:scale(var(--acuhj7u-3))}.a143ijem{-webkit-flex-shrink:1;-ms-flex-negative:1;flex-shrink:1}.wv1c1ab{display:-webkit-box;display:-webkit-flex;display:-ms-flexbox;display:flex;-webkit-align-items:center;-webkit-box-align:center;-ms-flex-align:center;align-items:center;-webkit-box-pack:justify;-webkit-justify-content:space-between;justify-content:space-between;padding:10px 20px;border-top:1px solid rgb(var(--wv1c1ab-0));-webkit-transition:border-color .23s ease-in-out;transition:border-color .23s ease-in-out}.h1mmuqym{display:-webkit-box;display:-webkit-flex;display:-ms-flexbox;display:flex;-webkit-align-items:center;-webkit-box-align:center;-ms-flex-align:center;align-items:center;-webkit-box-pack:justify;-webkit-justify-content:space-between;justify-content:space-between;padding:20px}.c86k5gq{position:relative;width:1.4rem;height:1.4rem;border-radius:100%;background-color:rgb(var(--c86k5gq-0));cursor:pointer;-webkit-tap-highlight-color:transparent;-webkit-transition:opacity .23s ease-in-out,-webkit-transform .125s ease,background-color .23s ease-in-out;transition:opacity .23s ease-in-out,transform .125s ease,background-color .23s ease-in-out}.c86k5gq:hover{-webkit-transform:scale(1.14);-moz-transform:scale(1.14);-ms-transform:scale(1.14);transform:scale(1.14)}.c86k5gq:active{-webkit-transform:scale(.92);-moz-transform:scale(.92);-ms-transform:scale(.92);transform:scale(.92)}.c86k5gq svg{font-size:1.1rem;width:1em;height:1em;position:absolute;top:50%;left:50%;color:rgb(var(--c86k5gq-1));-webkit-transform:translate(-50%,-50%);-moz-transform:translate(-50%,-50%);-ms-transform:translate(-50%,-50%);transform:translate(-50%,-50%)}.a5r445t{position:relative;display:-webkit-box;display:-webkit-flex;display:-ms-flexbox;display:flex;-webkit-flex-direction:column;-ms-flex-direction:column;flex-direction:column;gap:1.1rem;padding-bottom:1.2rem;max-height:280px;overflow-y:auto}.nukrfi8{font-size:.94rem;text-align:center;color:rgb(var(--nukrfi8-0));margin:3.4rem 0;font-weight:600;-webkit-transition:color .23s ease-in-out;transition:color .23s ease-in-out}.c13sms3{position:relative;height:280px}.w1r2gdr0{position:absolute;display:-webkit-box;display:-webkit-flex;display:-ms-flexbox;display:flex;-webkit-flex-direction:column;-ms-flex-direction:column;flex-direction:column;-webkit-align-items:center;-webkit-box-align:center;-ms-flex-align:center;align-items:center;top:45%;left:50%;width:70%;-webkit-transform:translate(-50%,-50%);-moz-transform:translate(-50%,-50%);-ms-transform:translate(-50%,-50%);transform:translate(-50%,-50%)}.w1r2gdr0 .acuhj7u{margin-bottom:.65rem}.w1r2gdr0 .s1osnke6{text-align:center;font-weight:700;margin-bottom:.1rem;-webkit-box-pack:center;-ms-flex-pack:center;-webkit-justify-content:center;justify-content:center}.w1r2gdr0 .s15u83h7{text-align:center}.w1r2gdr0 .b1cb9caz{margin-top:1rem}.b1aod1tx{background-color:#fb552b33;color:#fb542b;padding:.44rem;border-radius:var(--b1aod1tx-0);margin-top:.6rem}.c11dth47{display:block;margin:0 auto;margin-top:1rem;color:rgb(var(--c11dth47-0));width:1.25rem;height:1.25rem}.bcs69tl{font-size:1em;width:1em;height:1em;cursor:pointer;color:#007aff;-webkit-transform:scale(1.75);-moz-transform:scale(1.75);-ms-transform:scale(1.75);transform:scale(1.75);-webkit-tap-highlight-color:transparent;-webkit-transition:-webkit-transform .125s ease;transition:transform .125s ease}.bcs69tl:hover{-webkit-transform:scale(1.9);-moz-transform:scale(1.9);-ms-transform:scale(1.9);transform:scale(1.9)}.bcs69tl:active{-webkit-transform:scale(1.5);-moz-transform:scale(1.5);-ms-transform:scale(1.5);transform:scale(1.5)}.ar7vqm6{margin:1rem;padding:.8rem 1rem;border-radius:12px;border:1px solid rgb(var(--ar7vqm6-0));color:rgb(var(--ar7vqm6-1));font-size:.95rem;font-family:monospace;font-weight:500}.plzinag{display:-webkit-box;display:-webkit-flex;display:-ms-flexbox;display:flex;-webkit-flex-direction:column;-ms-flex-direction:column;flex-direction:column;-webkit-align-items:center;-webkit-box-align:center;-ms-flex-align:center;align-items:center;padding:0 20px 20px}.plzinag .s1hjgol5,.plzinag .subls4f{text-align:center}.plzinag .s1hjgol5 svg,.plzinag .subls4f svg{font-size:.85em;width:1em;height:1em;cursor:pointer;-webkit-tap-highlight-color:transparent;-webkit-transition:all .125s ease-in-out;transition:all .125s ease-in-out}.plzinag .s1hjgol5 svg:hover,.plzinag .subls4f svg:hover{opacity:.85}.plzinag .s1hjgol5 svg:active,.plzinag .subls4f svg:active{-webkit-transform:scale(.9);-moz-transform:scale(.9);-ms-transform:scale(.9);transform:scale(.9)}.plzinag .b1cb9caz{margin-top:1.5rem;width:100%;padding:.9rem 0;border-radius:var(--plzinag-0);text-transform:none}.p1qewrlg{position:relative;width:80px;height:80px;border-radius:var(--p1qewrlg-0);margin-bottom:.475rem;background-color:rgb(var(--p1qewrlg-1));-webkit-background-size:cover;background-size:cover;z-index:1}.a11vudt2{position:absolute;bottom:0;right:0;width:1.45rem;height:1.45rem;border-radius:100%;background-color:rgb(var(--a11vudt2-0));border:2px solid rgb(var(--a11vudt2-1))}.a11vudt2 img{position:absolute;top:50%;left:50%;object-fit:contain;-webkit-user-select:none;-moz-user-select:none;-ms-user-select:none;user-select:none;width:74%;height:74%;border-radius:100%;-webkit-transform:translate(-50%,-50%);-moz-transform:translate(-50%,-50%);-ms-transform:translate(-50%,-50%);transform:translate(-50%,-50%)}.p1jk1ov7{position:absolute;font-size:45px;width:1em;height:1em;top:50%;left:50%;color:#fff;-webkit-transform:translate(-50%,-50%);-moz-transform:translate(-50%,-50%);-ms-transform:translate(-50%,-50%);transform:translate(-50%,-50%)}")),document.head.appendChild(e)}}catch(t){console.error("vite-plugin-css-injected-by-js",t)}})();
var gl = Object.defineProperty;
var yl = (e, t, n) => t in e ? gl(e, t, { enumerable: !0, configurable: !0, writable: !0, value: n }) : e[t] = n;
var q = (e, t, n) => (yl(e, typeof t != "symbol" ? t + "" : t, n), n);
import * as ve from "react";
import je, { createContext as kt, useContext as $e, useMemo as ze, useState as He, useEffect as Te, useLayoutEffect as vl, useRef as nt, useCallback as Rt, forwardRef as wl, createElement as la, useId as wi, useInsertionEffect as Tl, cloneElement as bl, Children as Al, isValidElement as El, useReducer as Sl } from "react";
import So from "@arweave-wallet-kit/styles/dist/text/paragraph.module.css?used";
import Vn from "@arweave-wallet-kit/styles/dist/text/title.module.css?used";
import xl from "@arweave-wallet-kit/styles/dist/loading.module.css?used";
function ua(e, t) {
  for (const n of e)
    if (!t.includes(n))
      return !1;
  return !0;
}
const wn = "wallet_kit_strategy_id";
async function Pl(e, t, n) {
  let r = (localStorage == null ? void 0 : localStorage.getItem(wn)) || !1;
  if (r && jt(r, e))
    return jt(r, e);
  for (const i of e) {
    const s = await i.getPermissions();
    if (!n && s.length > 0 || n && ua(t, s))
      return qr(i.id), jt(i.id, e);
  }
  return !1;
}
function qr(e) {
  localStorage && localStorage.setItem(wn, e);
}
function jt(e, t) {
  return t.find((n) => n.id === e);
}
const Ti = {
  activeModal: !1,
  activeStrategy: !1,
  givenPermissions: [],
  config: {
    strategies: [],
    permissions: []
  }
}, fa = kt(void 0);
function We() {
  const e = $e(fa);
  return ze(
    () => e || { state: Ti, dispatch: () => {
    } },
    [e]
  );
}
function sv() {
  const { state: e } = We();
  return ze(() => e.activeStrategy, [e]);
}
function lt() {
  const { state: e } = We();
  return ze(() => jt(
    e.activeStrategy,
    e.config.strategies
  ), [e]);
}
function av() {
  const e = lt();
  return ze(() => {
    if (!e)
      return;
    const n = e, r = [
      "name",
      "description",
      "theme",
      "logo",
      "url",
      "resumeSession",
      "isAvailable",
      "addAddressEvent",
      "removeAddressEvent",
      "connect"
    ];
    for (const i in e)
      r.includes(i) && delete n[i];
    return n;
  }, [e]);
}
function er() {
  const { state: e } = We();
  return e == null ? void 0 : e.activeAddress;
}
async function Cl() {
  const e = lt(), { dispatch: t } = We();
  Te(() => {
    (async () => {
      var i;
      if (!e)
        return;
      const n = async () => {
        try {
          const s = await e.getActiveAddress();
          t({
            type: "UPDATE_ADDRESS",
            payload: s
          });
        } catch (s) {
          console.error(
            `[Arweave Wallet Kit] Failed to sync address
${(s == null ? void 0 : s.message) || s}`
          );
        }
      };
      await n();
      const r = (i = e.addAddressEvent) == null ? void 0 : i.call(
        e,
        (s) => t({
          type: "UPDATE_ADDRESS",
          payload: s
        })
      );
      return addEventListener("focus", n), () => {
        r && e.removeAddressEvent && e.removeAddressEvent(r), removeEventListener("focus", n);
      };
    })();
  }, [e, t]);
}
function cv() {
  const [e, t] = He(), n = lt(), r = er();
  return Te(() => {
    (async () => !n || !n.getActivePublicKey || t(await n.getActivePublicKey()))();
  }, [r, n]), e;
}
function _l() {
  const [e, t] = He([]), n = er(), { state: r } = We(), i = lt();
  return Te(() => {
    (async () => {
      if (!i)
        return t([]);
      const s = async () => {
        try {
          t(await i.getAllAddresses());
        } catch (o) {
          console.error(
            `[Arweave Wallet Kit] Failed to sync addresses
${(o == null ? void 0 : o.message) || o}`
          );
        }
      };
      return await s(), addEventListener("focus", s), () => removeEventListener("focus", s);
    })();
  }, [n, r, i]), e;
}
function lv() {
  const [e, t] = He({}), n = _l(), { state: r } = We(), i = lt();
  return Te(() => {
    (async () => {
      if (!i || !i.getWalletNames)
        return t({});
      try {
        const s = await i.getWalletNames();
        t(s);
      } catch (s) {
        console.error(
          `[Arweave Wallet Kit] Failed to sync wallet names
${(s == null ? void 0 : s.message) || s}`
        );
      }
    })();
  }, [n, r == null ? void 0 : r.activeStrategy]), e;
}
var $t = typeof globalThis < "u" ? globalThis : typeof window < "u" ? window : typeof global < "u" ? global : typeof self < "u" ? self : {};
function Tn(e) {
  return e && e.__esModule && Object.prototype.hasOwnProperty.call(e, "default") ? e.default : e;
}
var zr = { exports: {} }, Zt = {};
/**
 * @license React
 * react-jsx-runtime.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var xo;
function Ol() {
  if (xo)
    return Zt;
  xo = 1;
  var e = je, t = Symbol.for("react.element"), n = Symbol.for("react.fragment"), r = Object.prototype.hasOwnProperty, i = e.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED.ReactCurrentOwner, s = { key: !0, ref: !0, __self: !0, __source: !0 };
  function o(a, c, l) {
    var u, d = {}, h = null, m = null;
    l !== void 0 && (h = "" + l), c.key !== void 0 && (h = "" + c.key), c.ref !== void 0 && (m = c.ref);
    for (u in c)
      r.call(c, u) && !s.hasOwnProperty(u) && (d[u] = c[u]);
    if (a && a.defaultProps)
      for (u in c = a.defaultProps, c)
        d[u] === void 0 && (d[u] = c[u]);
    return { $$typeof: t, type: a, key: h, ref: m, props: d, _owner: i.current };
  }
  return Zt.Fragment = n, Zt.jsx = o, Zt.jsxs = o, Zt;
}
var Jt = {};
/**
 * @license React
 * react-jsx-runtime.development.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var Po;
function Rl() {
  return Po || (Po = 1, process.env.NODE_ENV !== "production" && function() {
    var e = je, t = Symbol.for("react.element"), n = Symbol.for("react.portal"), r = Symbol.for("react.fragment"), i = Symbol.for("react.strict_mode"), s = Symbol.for("react.profiler"), o = Symbol.for("react.provider"), a = Symbol.for("react.context"), c = Symbol.for("react.forward_ref"), l = Symbol.for("react.suspense"), u = Symbol.for("react.suspense_list"), d = Symbol.for("react.memo"), h = Symbol.for("react.lazy"), m = Symbol.for("react.offscreen"), v = Symbol.iterator, w = "@@iterator";
    function I(y) {
      if (y === null || typeof y != "object")
        return null;
      var $ = v && y[v] || y[w];
      return typeof $ == "function" ? $ : null;
    }
    var E = e.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED;
    function P(y) {
      {
        for (var $ = arguments.length, U = new Array($ > 1 ? $ - 1 : 0), te = 1; te < $; te++)
          U[te - 1] = arguments[te];
        M("error", y, U);
      }
    }
    function M(y, $, U) {
      {
        var te = E.ReactDebugCurrentFrame, we = te.getStackAddendum();
        we !== "" && ($ += "%s", U = U.concat([we]));
        var xe = U.map(function(me) {
          return String(me);
        });
        xe.unshift("Warning: " + $), Function.prototype.apply.call(console[y], console, xe);
      }
    }
    var L = !1, T = !1, _ = !1, V = !1, F = !1, W;
    W = Symbol.for("react.module.reference");
    function N(y) {
      return !!(typeof y == "string" || typeof y == "function" || y === r || y === s || F || y === i || y === l || y === u || V || y === m || L || T || _ || typeof y == "object" && y !== null && (y.$$typeof === h || y.$$typeof === d || y.$$typeof === o || y.$$typeof === a || y.$$typeof === c || // This needs to include all possible module reference object
      // types supported by any Flight configuration anywhere since
      // we don't know which Flight build this will end up being used
      // with.
      y.$$typeof === W || y.getModuleId !== void 0));
    }
    function G(y, $, U) {
      var te = y.displayName;
      if (te)
        return te;
      var we = $.displayName || $.name || "";
      return we !== "" ? U + "(" + we + ")" : U;
    }
    function ne(y) {
      return y.displayName || "Context";
    }
    function J(y) {
      if (y == null)
        return null;
      if (typeof y.tag == "number" && P("Received an unexpected object in getComponentNameFromType(). This is likely a bug in React. Please file an issue."), typeof y == "function")
        return y.displayName || y.name || null;
      if (typeof y == "string")
        return y;
      switch (y) {
        case r:
          return "Fragment";
        case n:
          return "Portal";
        case s:
          return "Profiler";
        case i:
          return "StrictMode";
        case l:
          return "Suspense";
        case u:
          return "SuspenseList";
      }
      if (typeof y == "object")
        switch (y.$$typeof) {
          case a:
            var $ = y;
            return ne($) + ".Consumer";
          case o:
            var U = y;
            return ne(U._context) + ".Provider";
          case c:
            return G(y, y.render, "ForwardRef");
          case d:
            var te = y.displayName || null;
            return te !== null ? te : J(y.type) || "Memo";
          case h: {
            var we = y, xe = we._payload, me = we._init;
            try {
              return J(me(xe));
            } catch {
              return null;
            }
          }
        }
      return null;
    }
    var ue = Object.assign, Q = 0, ge, de, Le, Fe, j, H, ee;
    function oe() {
    }
    oe.__reactDisabledLog = !0;
    function D() {
      {
        if (Q === 0) {
          ge = console.log, de = console.info, Le = console.warn, Fe = console.error, j = console.group, H = console.groupCollapsed, ee = console.groupEnd;
          var y = {
            configurable: !0,
            enumerable: !0,
            value: oe,
            writable: !0
          };
          Object.defineProperties(console, {
            info: y,
            log: y,
            warn: y,
            error: y,
            group: y,
            groupCollapsed: y,
            groupEnd: y
          });
        }
        Q++;
      }
    }
    function fe() {
      {
        if (Q--, Q === 0) {
          var y = {
            configurable: !0,
            enumerable: !0,
            writable: !0
          };
          Object.defineProperties(console, {
            log: ue({}, y, {
              value: ge
            }),
            info: ue({}, y, {
              value: de
            }),
            warn: ue({}, y, {
              value: Le
            }),
            error: ue({}, y, {
              value: Fe
            }),
            group: ue({}, y, {
              value: j
            }),
            groupCollapsed: ue({}, y, {
              value: H
            }),
            groupEnd: ue({}, y, {
              value: ee
            })
          });
        }
        Q < 0 && P("disabledDepth fell below zero. This is a bug in React. Please file an issue.");
      }
    }
    var re = E.ReactCurrentDispatcher, ie;
    function X(y, $, U) {
      {
        if (ie === void 0)
          try {
            throw Error();
          } catch (we) {
            var te = we.stack.trim().match(/\n( *(at )?)/);
            ie = te && te[1] || "";
          }
        return `
` + ie + y;
      }
    }
    var se = !1, f;
    {
      var g = typeof WeakMap == "function" ? WeakMap : Map;
      f = new g();
    }
    function p(y, $) {
      if (!y || se)
        return "";
      {
        var U = f.get(y);
        if (U !== void 0)
          return U;
      }
      var te;
      se = !0;
      var we = Error.prepareStackTrace;
      Error.prepareStackTrace = void 0;
      var xe;
      xe = re.current, re.current = null, D();
      try {
        if ($) {
          var me = function() {
            throw Error();
          };
          if (Object.defineProperty(me.prototype, "props", {
            set: function() {
              throw Error();
            }
          }), typeof Reflect == "object" && Reflect.construct) {
            try {
              Reflect.construct(me, []);
            } catch (ut) {
              te = ut;
            }
            Reflect.construct(y, [], me);
          } else {
            try {
              me.call();
            } catch (ut) {
              te = ut;
            }
            y.call(me.prototype);
          }
        } else {
          try {
            throw Error();
          } catch (ut) {
            te = ut;
          }
          y();
        }
      } catch (ut) {
        if (ut && te && typeof ut.stack == "string") {
          for (var he = ut.stack.split(`
`), Ke = te.stack.split(`
`), Ie = he.length - 1, De = Ke.length - 1; Ie >= 1 && De >= 0 && he[Ie] !== Ke[De]; )
            De--;
          for (; Ie >= 1 && De >= 0; Ie--, De--)
            if (he[Ie] !== Ke[De]) {
              if (Ie !== 1 || De !== 1)
                do
                  if (Ie--, De--, De < 0 || he[Ie] !== Ke[De]) {
                    var et = `
` + he[Ie].replace(" at new ", " at ");
                    return y.displayName && et.includes("<anonymous>") && (et = et.replace("<anonymous>", y.displayName)), typeof y == "function" && f.set(y, et), et;
                  }
                while (Ie >= 1 && De >= 0);
              break;
            }
        }
      } finally {
        se = !1, re.current = xe, fe(), Error.prepareStackTrace = we;
      }
      var Lt = y ? y.displayName || y.name : "", Eo = Lt ? X(Lt) : "";
      return typeof y == "function" && f.set(y, Eo), Eo;
    }
    function C(y, $, U) {
      return p(y, !1);
    }
    function A(y) {
      var $ = y.prototype;
      return !!($ && $.isReactComponent);
    }
    function x(y, $, U) {
      if (y == null)
        return "";
      if (typeof y == "function")
        return p(y, A(y));
      if (typeof y == "string")
        return X(y);
      switch (y) {
        case l:
          return X("Suspense");
        case u:
          return X("SuspenseList");
      }
      if (typeof y == "object")
        switch (y.$$typeof) {
          case c:
            return C(y.render);
          case d:
            return x(y.type, $, U);
          case h: {
            var te = y, we = te._payload, xe = te._init;
            try {
              return x(xe(we), $, U);
            } catch {
            }
          }
        }
      return "";
    }
    var k = Object.prototype.hasOwnProperty, b = {}, S = E.ReactDebugCurrentFrame;
    function R(y) {
      if (y) {
        var $ = y._owner, U = x(y.type, y._source, $ ? $.type : null);
        S.setExtraStackFrame(U);
      } else
        S.setExtraStackFrame(null);
    }
    function O(y, $, U, te, we) {
      {
        var xe = Function.call.bind(k);
        for (var me in y)
          if (xe(y, me)) {
            var he = void 0;
            try {
              if (typeof y[me] != "function") {
                var Ke = Error((te || "React class") + ": " + U + " type `" + me + "` is invalid; it must be a function, usually from the `prop-types` package, but received `" + typeof y[me] + "`.This often happens because of typos such as `PropTypes.function` instead of `PropTypes.func`.");
                throw Ke.name = "Invariant Violation", Ke;
              }
              he = y[me]($, me, te, U, null, "SECRET_DO_NOT_PASS_THIS_OR_YOU_WILL_BE_FIRED");
            } catch (Ie) {
              he = Ie;
            }
            he && !(he instanceof Error) && (R(we), P("%s: type specification of %s `%s` is invalid; the type checker function must return `null` or an `Error` but returned a %s. You may have forgotten to pass an argument to the type checker creator (arrayOf, instanceOf, objectOf, oneOf, oneOfType, and shape all require an argument).", te || "React class", U, me, typeof he), R(null)), he instanceof Error && !(he.message in b) && (b[he.message] = !0, R(we), P("Failed %s type: %s", U, he.message), R(null));
          }
      }
    }
    var B = Array.isArray;
    function z(y) {
      return B(y);
    }
    function Y(y) {
      {
        var $ = typeof Symbol == "function" && Symbol.toStringTag, U = $ && y[Symbol.toStringTag] || y.constructor.name || "Object";
        return U;
      }
    }
    function pe(y) {
      try {
        return Ce(y), !1;
      } catch {
        return !0;
      }
    }
    function Ce(y) {
      return "" + y;
    }
    function ke(y) {
      if (pe(y))
        return P("The provided key is an unsupported type %s. This value must be coerced to a string before before using it here.", Y(y)), Ce(y);
    }
    var le = E.ReactCurrentOwner, be = {
      key: !0,
      ref: !0,
      __self: !0,
      __source: !0
    }, Ve, At, Et;
    Et = {};
    function Xt(y) {
      if (k.call(y, "ref")) {
        var $ = Object.getOwnPropertyDescriptor(y, "ref").get;
        if ($ && $.isReactWarning)
          return !1;
      }
      return y.ref !== void 0;
    }
    function Qe(y) {
      if (k.call(y, "key")) {
        var $ = Object.getOwnPropertyDescriptor(y, "key").get;
        if ($ && $.isReactWarning)
          return !1;
      }
      return y.key !== void 0;
    }
    function St(y, $) {
      if (typeof y.ref == "string" && le.current && $ && le.current.stateNode !== $) {
        var U = J(le.current.type);
        Et[U] || (P('Component "%s" contains the string ref "%s". Support for string refs will be removed in a future major release. This case cannot be automatically converted to an arrow function. We ask you to manually fix this case by using useRef() or createRef() instead. Learn more about using refs safely here: https://reactjs.org/link/strict-mode-string-ref', J(le.current.type), y.ref), Et[U] = !0);
      }
    }
    function Ge(y, $) {
      {
        var U = function() {
          Ve || (Ve = !0, P("%s: `key` is not a prop. Trying to access it will result in `undefined` being returned. If you need to access the same value within the child component, you should pass it as a different prop. (https://reactjs.org/link/special-props)", $));
        };
        U.isReactWarning = !0, Object.defineProperty(y, "key", {
          get: U,
          configurable: !0
        });
      }
    }
    function Ue(y, $) {
      {
        var U = function() {
          At || (At = !0, P("%s: `ref` is not a prop. Trying to access it will result in `undefined` being returned. If you need to access the same value within the child component, you should pass it as a different prop. (https://reactjs.org/link/special-props)", $));
        };
        U.isReactWarning = !0, Object.defineProperty(y, "ref", {
          get: U,
          configurable: !0
        });
      }
    }
    var _e = function(y, $, U, te, we, xe, me) {
      var he = {
        // This tag allows us to uniquely identify this as a React Element
        $$typeof: t,
        // Built-in properties that belong on the element
        type: y,
        key: $,
        ref: U,
        props: me,
        // Record the component responsible for creating this element.
        _owner: xe
      };
      return he._store = {}, Object.defineProperty(he._store, "validated", {
        configurable: !1,
        enumerable: !1,
        writable: !0,
        value: !1
      }), Object.defineProperty(he, "_self", {
        configurable: !1,
        enumerable: !1,
        writable: !1,
        value: te
      }), Object.defineProperty(he, "_source", {
        configurable: !1,
        enumerable: !1,
        writable: !1,
        value: we
      }), Object.freeze && (Object.freeze(he.props), Object.freeze(he)), he;
    };
    function al(y, $, U, te, we) {
      {
        var xe, me = {}, he = null, Ke = null;
        U !== void 0 && (ke(U), he = "" + U), Qe($) && (ke($.key), he = "" + $.key), Xt($) && (Ke = $.ref, St($, we));
        for (xe in $)
          k.call($, xe) && !be.hasOwnProperty(xe) && (me[xe] = $[xe]);
        if (y && y.defaultProps) {
          var Ie = y.defaultProps;
          for (xe in Ie)
            me[xe] === void 0 && (me[xe] = Ie[xe]);
        }
        if (he || Ke) {
          var De = typeof y == "function" ? y.displayName || y.name || "Unknown" : y;
          he && Ge(me, De), Ke && Ue(me, De);
        }
        return _e(y, he, Ke, we, te, le.current, me);
      }
    }
    var vr = E.ReactCurrentOwner, yo = E.ReactDebugCurrentFrame;
    function It(y) {
      if (y) {
        var $ = y._owner, U = x(y.type, y._source, $ ? $.type : null);
        yo.setExtraStackFrame(U);
      } else
        yo.setExtraStackFrame(null);
    }
    var wr;
    wr = !1;
    function Tr(y) {
      return typeof y == "object" && y !== null && y.$$typeof === t;
    }
    function vo() {
      {
        if (vr.current) {
          var y = J(vr.current.type);
          if (y)
            return `

Check the render method of \`` + y + "`.";
        }
        return "";
      }
    }
    function cl(y) {
      {
        if (y !== void 0) {
          var $ = y.fileName.replace(/^.*[\\\/]/, ""), U = y.lineNumber;
          return `

Check your code at ` + $ + ":" + U + ".";
        }
        return "";
      }
    }
    var wo = {};
    function ll(y) {
      {
        var $ = vo();
        if (!$) {
          var U = typeof y == "string" ? y : y.displayName || y.name;
          U && ($ = `

Check the top-level render call using <` + U + ">.");
        }
        return $;
      }
    }
    function To(y, $) {
      {
        if (!y._store || y._store.validated || y.key != null)
          return;
        y._store.validated = !0;
        var U = ll($);
        if (wo[U])
          return;
        wo[U] = !0;
        var te = "";
        y && y._owner && y._owner !== vr.current && (te = " It was passed a child from " + J(y._owner.type) + "."), It(y), P('Each child in a list should have a unique "key" prop.%s%s See https://reactjs.org/link/warning-keys for more information.', U, te), It(null);
      }
    }
    function bo(y, $) {
      {
        if (typeof y != "object")
          return;
        if (z(y))
          for (var U = 0; U < y.length; U++) {
            var te = y[U];
            Tr(te) && To(te, $);
          }
        else if (Tr(y))
          y._store && (y._store.validated = !0);
        else if (y) {
          var we = I(y);
          if (typeof we == "function" && we !== y.entries)
            for (var xe = we.call(y), me; !(me = xe.next()).done; )
              Tr(me.value) && To(me.value, $);
        }
      }
    }
    function ul(y) {
      {
        var $ = y.type;
        if ($ == null || typeof $ == "string")
          return;
        var U;
        if (typeof $ == "function")
          U = $.propTypes;
        else if (typeof $ == "object" && ($.$$typeof === c || // Note: Memo only checks outer props here.
        // Inner props are checked in the reconciler.
        $.$$typeof === d))
          U = $.propTypes;
        else
          return;
        if (U) {
          var te = J($);
          O(U, y.props, "prop", te, y);
        } else if ($.PropTypes !== void 0 && !wr) {
          wr = !0;
          var we = J($);
          P("Component %s declared `PropTypes` instead of `propTypes`. Did you misspell the property assignment?", we || "Unknown");
        }
        typeof $.getDefaultProps == "function" && !$.getDefaultProps.isReactClassApproved && P("getDefaultProps is only used on classic React.createClass definitions. Use a static property named `defaultProps` instead.");
      }
    }
    function fl(y) {
      {
        for (var $ = Object.keys(y.props), U = 0; U < $.length; U++) {
          var te = $[U];
          if (te !== "children" && te !== "key") {
            It(y), P("Invalid prop `%s` supplied to `React.Fragment`. React.Fragment can only have `key` and `children` props.", te), It(null);
            break;
          }
        }
        y.ref !== null && (It(y), P("Invalid attribute `ref` supplied to `React.Fragment`."), It(null));
      }
    }
    function Ao(y, $, U, te, we, xe) {
      {
        var me = N(y);
        if (!me) {
          var he = "";
          (y === void 0 || typeof y == "object" && y !== null && Object.keys(y).length === 0) && (he += " You likely forgot to export your component from the file it's defined in, or you might have mixed up default and named imports.");
          var Ke = cl(we);
          Ke ? he += Ke : he += vo();
          var Ie;
          y === null ? Ie = "null" : z(y) ? Ie = "array" : y !== void 0 && y.$$typeof === t ? (Ie = "<" + (J(y.type) || "Unknown") + " />", he = " Did you accidentally export a JSX literal instead of a component?") : Ie = typeof y, P("React.jsx: type is invalid -- expected a string (for built-in components) or a class/function (for composite components) but got: %s.%s", Ie, he);
        }
        var De = al(y, $, U, we, xe);
        if (De == null)
          return De;
        if (me) {
          var et = $.children;
          if (et !== void 0)
            if (te)
              if (z(et)) {
                for (var Lt = 0; Lt < et.length; Lt++)
                  bo(et[Lt], y);
                Object.freeze && Object.freeze(et);
              } else
                P("React.jsx: Static children should always be an array. You are likely explicitly calling React.jsxs or React.jsxDEV. Use the Babel transform instead.");
            else
              bo(et, y);
        }
        return y === r ? fl(De) : ul(De), De;
      }
    }
    function dl(y, $, U) {
      return Ao(y, $, U, !0);
    }
    function hl(y, $, U) {
      return Ao(y, $, U, !1);
    }
    var pl = hl, ml = dl;
    Jt.Fragment = r, Jt.jsx = pl, Jt.jsxs = ml;
  }()), Jt;
}
process.env.NODE_ENV === "production" ? zr.exports = Ol() : zr.exports = Rl();
var bi = zr.exports;
const hn = bi.Fragment, K = bi.jsx, ye = bi.jsxs;
function da(e, t = 13) {
  return e.substring(0, t) + "..." + e.substring(e.length - t, e.length);
}
function kl(e) {
  return /* @__PURE__ */ ve.createElement("svg", Object.assign({
    width: 24,
    height: 24,
    fill: "none",
    viewBox: "0 0 24 24"
  }, e), /* @__PURE__ */ ve.createElement("path", {
    stroke: "currentColor",
    strokeLinecap: "round",
    strokeLinejoin: "round",
    strokeWidth: 1.5,
    d: "M15.25 10.75L12 14.25L8.75 10.75"
  }));
}
function Ml(e) {
  return /* @__PURE__ */ ve.createElement("svg", Object.assign({
    width: 24,
    height: 24,
    fill: "none",
    viewBox: "0 0 24 24"
  }, e), /* @__PURE__ */ ve.createElement("path", {
    stroke: "currentColor",
    strokeLinecap: "round",
    strokeLinejoin: "round",
    strokeWidth: 1.5,
    d: "M13.25 8.75L9.75 12L13.25 15.25"
  }));
}
function Il(e) {
  return /* @__PURE__ */ ve.createElement("svg", Object.assign({
    width: 24,
    height: 24,
    fill: "none",
    viewBox: "0 0 24 24"
  }, e), /* @__PURE__ */ ve.createElement("path", {
    stroke: "currentColor",
    strokeLinecap: "round",
    strokeLinejoin: "round",
    strokeWidth: 1.5,
    d: "M17.25 6.75L6.75 17.25"
  }), /* @__PURE__ */ ve.createElement("path", {
    stroke: "currentColor",
    strokeLinecap: "round",
    strokeLinejoin: "round",
    strokeWidth: 1.5,
    d: "M6.75 6.75L17.25 17.25"
  }));
}
function Ll(e) {
  return /* @__PURE__ */ ve.createElement("svg", Object.assign({
    width: 24,
    height: 24,
    fill: "none",
    viewBox: "0 0 24 24"
  }, e), /* @__PURE__ */ ve.createElement("path", {
    stroke: "currentColor",
    strokeLinecap: "round",
    strokeLinejoin: "round",
    strokeWidth: 1.5,
    d: "M6.5 15.25V15.25C5.5335 15.25 4.75 14.4665 4.75 13.5V6.75C4.75 5.64543 5.64543 4.75 6.75 4.75H13.5C14.4665 4.75 15.25 5.5335 15.25 6.5V6.5"
  }), /* @__PURE__ */ ve.createElement("rect", {
    width: 10.5,
    height: 10.5,
    x: 8.75,
    y: 8.75,
    stroke: "currentColor",
    strokeLinecap: "round",
    strokeLinejoin: "round",
    strokeWidth: 1.5,
    rx: 2
  }));
}
function Dl(e) {
  return /* @__PURE__ */ ve.createElement("svg", Object.assign({
    width: 24,
    height: 24,
    fill: "none",
    viewBox: "0 0 24 24"
  }, e), /* @__PURE__ */ ve.createElement("path", {
    stroke: "currentColor",
    strokeLinecap: "round",
    strokeLinejoin: "round",
    strokeWidth: 1.5,
    d: "M15.75 8.75L19.25 12L15.75 15.25"
  }), /* @__PURE__ */ ve.createElement("path", {
    stroke: "currentColor",
    strokeLinecap: "round",
    strokeLinejoin: "round",
    strokeWidth: 1.5,
    d: "M19 12H10.75"
  }), /* @__PURE__ */ ve.createElement("path", {
    stroke: "currentColor",
    strokeLinecap: "round",
    strokeLinejoin: "round",
    strokeWidth: 1.5,
    d: "M15.25 4.75H6.75C5.64543 4.75 4.75 5.64543 4.75 6.75V17.25C4.75 18.3546 5.64543 19.25 6.75 19.25H15.25"
  }));
}
function ha(e) {
  return /* @__PURE__ */ ve.createElement("svg", Object.assign({
    width: 24,
    height: 24,
    fill: "none",
    viewBox: "0 0 24 24"
  }, e), /* @__PURE__ */ ve.createElement("circle", {
    cx: 12,
    cy: 8,
    r: 3.25,
    stroke: "currentColor",
    strokeLinecap: "round",
    strokeLinejoin: "round",
    strokeWidth: 1.5
  }), /* @__PURE__ */ ve.createElement("path", {
    stroke: "currentColor",
    strokeLinecap: "round",
    strokeLinejoin: "round",
    strokeWidth: 1.5,
    d: "M6.8475 19.25H17.1525C18.2944 19.25 19.174 18.2681 18.6408 17.2584C17.8563 15.7731 16.068 14 12 14C7.93201 14 6.14367 15.7731 5.35924 17.2584C4.82597 18.2681 5.70558 19.25 6.8475 19.25Z"
  }));
}
var Ai = {}, pa = { exports: {} };
(function(e, t) {
  (function(n, r) {
    e.exports = r();
  })($t, function() {
    var n = function(P) {
      return r(P) && !i(P);
    };
    function r(E) {
      return !!E && typeof E == "object";
    }
    function i(E) {
      var P = Object.prototype.toString.call(E);
      return P === "[object RegExp]" || P === "[object Date]" || a(E);
    }
    var s = typeof Symbol == "function" && Symbol.for, o = s ? Symbol.for("react.element") : 60103;
    function a(E) {
      return E.$$typeof === o;
    }
    function c(E) {
      return Array.isArray(E) ? [] : {};
    }
    function l(E, P) {
      return P.clone !== !1 && P.isMergeableObject(E) ? w(c(E), E, P) : E;
    }
    function u(E, P, M) {
      return E.concat(P).map(function(L) {
        return l(L, M);
      });
    }
    function d(E, P) {
      if (!P.customMerge)
        return w;
      var M = P.customMerge(E);
      return typeof M == "function" ? M : w;
    }
    function h(E) {
      return Object.getOwnPropertySymbols ? Object.getOwnPropertySymbols(E).filter(function(P) {
        return E.propertyIsEnumerable(P);
      }) : [];
    }
    function m(E) {
      return Object.keys(E).concat(h(E));
    }
    function v(E, P, M) {
      var L = {};
      return M.isMergeableObject(E) && m(E).forEach(function(T) {
        L[T] = l(E[T], M);
      }), m(P).forEach(function(T) {
        !M.isMergeableObject(P[T]) || !E[T] ? L[T] = l(P[T], M) : L[T] = d(T, M)(E[T], P[T], M);
      }), L;
    }
    function w(E, P, M) {
      M = M || {}, M.arrayMerge = M.arrayMerge || u, M.isMergeableObject = M.isMergeableObject || n;
      var L = Array.isArray(P), T = Array.isArray(E), _ = L === T;
      return _ ? L ? M.arrayMerge(E, P, M) : v(E, P, M) : l(P, M);
    }
    w.all = function(P, M) {
      if (!Array.isArray(P))
        throw new Error("first argument should be an array");
      return P.reduce(function(L, T) {
        return w(L, T, M);
      }, {});
    };
    var I = w;
    return I;
  });
})(pa);
var ma = pa.exports, tr = {};
tr.__esModule = !0;
tr.default = void 0;
var Co = Vl(je);
function Vl(e) {
  if (e && e.__esModule)
    return e;
  var t = {};
  if (e != null) {
    for (var n in e)
      if (Object.prototype.hasOwnProperty.call(e, n)) {
        var r = Object.defineProperty && Object.getOwnPropertyDescriptor ? Object.getOwnPropertyDescriptor(e, n) : {};
        r.get || r.set ? Object.defineProperty(t, n, r) : t[n] = e[n];
      }
  }
  return t.default = e, t;
}
function Nl(e, t) {
  e.prototype = Object.create(t.prototype), e.prototype.constructor = e, e.__proto__ = t;
}
function Bl(e, t, n) {
  return t in e ? Object.defineProperty(e, t, { value: n, enumerable: !0, configurable: !0, writable: !0 }) : e[t] = n, e;
}
function jl(e, t) {
  var n, r;
  return r = n = /* @__PURE__ */ function(i) {
    Nl(s, i);
    function s() {
      return i.apply(this, arguments) || this;
    }
    var o = s.prototype;
    return o.render = function() {
      return Co.createElement(t.Provider, {
        value: this.props.theme
      }, this.props.children);
    }, s;
  }(Co.Component), Bl(n, "defaultProps", {
    theme: e
  }), r;
}
var $l = jl;
tr.default = $l;
var nr = {}, Pn = { exports: {} }, Ae = {};
/** @license React v16.13.1
 * react-is.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var _o;
function Fl() {
  if (_o)
    return Ae;
  _o = 1;
  var e = typeof Symbol == "function" && Symbol.for, t = e ? Symbol.for("react.element") : 60103, n = e ? Symbol.for("react.portal") : 60106, r = e ? Symbol.for("react.fragment") : 60107, i = e ? Symbol.for("react.strict_mode") : 60108, s = e ? Symbol.for("react.profiler") : 60114, o = e ? Symbol.for("react.provider") : 60109, a = e ? Symbol.for("react.context") : 60110, c = e ? Symbol.for("react.async_mode") : 60111, l = e ? Symbol.for("react.concurrent_mode") : 60111, u = e ? Symbol.for("react.forward_ref") : 60112, d = e ? Symbol.for("react.suspense") : 60113, h = e ? Symbol.for("react.suspense_list") : 60120, m = e ? Symbol.for("react.memo") : 60115, v = e ? Symbol.for("react.lazy") : 60116, w = e ? Symbol.for("react.block") : 60121, I = e ? Symbol.for("react.fundamental") : 60117, E = e ? Symbol.for("react.responder") : 60118, P = e ? Symbol.for("react.scope") : 60119;
  function M(T) {
    if (typeof T == "object" && T !== null) {
      var _ = T.$$typeof;
      switch (_) {
        case t:
          switch (T = T.type, T) {
            case c:
            case l:
            case r:
            case s:
            case i:
            case d:
              return T;
            default:
              switch (T = T && T.$$typeof, T) {
                case a:
                case u:
                case v:
                case m:
                case o:
                  return T;
                default:
                  return _;
              }
          }
        case n:
          return _;
      }
    }
  }
  function L(T) {
    return M(T) === l;
  }
  return Ae.AsyncMode = c, Ae.ConcurrentMode = l, Ae.ContextConsumer = a, Ae.ContextProvider = o, Ae.Element = t, Ae.ForwardRef = u, Ae.Fragment = r, Ae.Lazy = v, Ae.Memo = m, Ae.Portal = n, Ae.Profiler = s, Ae.StrictMode = i, Ae.Suspense = d, Ae.isAsyncMode = function(T) {
    return L(T) || M(T) === c;
  }, Ae.isConcurrentMode = L, Ae.isContextConsumer = function(T) {
    return M(T) === a;
  }, Ae.isContextProvider = function(T) {
    return M(T) === o;
  }, Ae.isElement = function(T) {
    return typeof T == "object" && T !== null && T.$$typeof === t;
  }, Ae.isForwardRef = function(T) {
    return M(T) === u;
  }, Ae.isFragment = function(T) {
    return M(T) === r;
  }, Ae.isLazy = function(T) {
    return M(T) === v;
  }, Ae.isMemo = function(T) {
    return M(T) === m;
  }, Ae.isPortal = function(T) {
    return M(T) === n;
  }, Ae.isProfiler = function(T) {
    return M(T) === s;
  }, Ae.isStrictMode = function(T) {
    return M(T) === i;
  }, Ae.isSuspense = function(T) {
    return M(T) === d;
  }, Ae.isValidElementType = function(T) {
    return typeof T == "string" || typeof T == "function" || T === r || T === l || T === s || T === i || T === d || T === h || typeof T == "object" && T !== null && (T.$$typeof === v || T.$$typeof === m || T.$$typeof === o || T.$$typeof === a || T.$$typeof === u || T.$$typeof === I || T.$$typeof === E || T.$$typeof === P || T.$$typeof === w);
  }, Ae.typeOf = M, Ae;
}
var Ee = {};
/** @license React v16.13.1
 * react-is.development.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var Oo;
function Ul() {
  return Oo || (Oo = 1, process.env.NODE_ENV !== "production" && function() {
    var e = typeof Symbol == "function" && Symbol.for, t = e ? Symbol.for("react.element") : 60103, n = e ? Symbol.for("react.portal") : 60106, r = e ? Symbol.for("react.fragment") : 60107, i = e ? Symbol.for("react.strict_mode") : 60108, s = e ? Symbol.for("react.profiler") : 60114, o = e ? Symbol.for("react.provider") : 60109, a = e ? Symbol.for("react.context") : 60110, c = e ? Symbol.for("react.async_mode") : 60111, l = e ? Symbol.for("react.concurrent_mode") : 60111, u = e ? Symbol.for("react.forward_ref") : 60112, d = e ? Symbol.for("react.suspense") : 60113, h = e ? Symbol.for("react.suspense_list") : 60120, m = e ? Symbol.for("react.memo") : 60115, v = e ? Symbol.for("react.lazy") : 60116, w = e ? Symbol.for("react.block") : 60121, I = e ? Symbol.for("react.fundamental") : 60117, E = e ? Symbol.for("react.responder") : 60118, P = e ? Symbol.for("react.scope") : 60119;
    function M(p) {
      return typeof p == "string" || typeof p == "function" || // Note: its typeof might be other than 'symbol' or 'number' if it's a polyfill.
      p === r || p === l || p === s || p === i || p === d || p === h || typeof p == "object" && p !== null && (p.$$typeof === v || p.$$typeof === m || p.$$typeof === o || p.$$typeof === a || p.$$typeof === u || p.$$typeof === I || p.$$typeof === E || p.$$typeof === P || p.$$typeof === w);
    }
    function L(p) {
      if (typeof p == "object" && p !== null) {
        var C = p.$$typeof;
        switch (C) {
          case t:
            var A = p.type;
            switch (A) {
              case c:
              case l:
              case r:
              case s:
              case i:
              case d:
                return A;
              default:
                var x = A && A.$$typeof;
                switch (x) {
                  case a:
                  case u:
                  case v:
                  case m:
                  case o:
                    return x;
                  default:
                    return C;
                }
            }
          case n:
            return C;
        }
      }
    }
    var T = c, _ = l, V = a, F = o, W = t, N = u, G = r, ne = v, J = m, ue = n, Q = s, ge = i, de = d, Le = !1;
    function Fe(p) {
      return Le || (Le = !0, console.warn("The ReactIs.isAsyncMode() alias has been deprecated, and will be removed in React 17+. Update your code to use ReactIs.isConcurrentMode() instead. It has the exact same API.")), j(p) || L(p) === c;
    }
    function j(p) {
      return L(p) === l;
    }
    function H(p) {
      return L(p) === a;
    }
    function ee(p) {
      return L(p) === o;
    }
    function oe(p) {
      return typeof p == "object" && p !== null && p.$$typeof === t;
    }
    function D(p) {
      return L(p) === u;
    }
    function fe(p) {
      return L(p) === r;
    }
    function re(p) {
      return L(p) === v;
    }
    function ie(p) {
      return L(p) === m;
    }
    function X(p) {
      return L(p) === n;
    }
    function se(p) {
      return L(p) === s;
    }
    function f(p) {
      return L(p) === i;
    }
    function g(p) {
      return L(p) === d;
    }
    Ee.AsyncMode = T, Ee.ConcurrentMode = _, Ee.ContextConsumer = V, Ee.ContextProvider = F, Ee.Element = W, Ee.ForwardRef = N, Ee.Fragment = G, Ee.Lazy = ne, Ee.Memo = J, Ee.Portal = ue, Ee.Profiler = Q, Ee.StrictMode = ge, Ee.Suspense = de, Ee.isAsyncMode = Fe, Ee.isConcurrentMode = j, Ee.isContextConsumer = H, Ee.isContextProvider = ee, Ee.isElement = oe, Ee.isForwardRef = D, Ee.isFragment = fe, Ee.isLazy = re, Ee.isMemo = ie, Ee.isPortal = X, Ee.isProfiler = se, Ee.isStrictMode = f, Ee.isSuspense = g, Ee.isValidElementType = M, Ee.typeOf = L;
  }()), Ee;
}
var Ro;
function Ei() {
  return Ro || (Ro = 1, process.env.NODE_ENV === "production" ? Pn.exports = Fl() : Pn.exports = Ul()), Pn.exports;
}
var Si = Ei(), Hl = {
  childContextTypes: !0,
  contextType: !0,
  contextTypes: !0,
  defaultProps: !0,
  displayName: !0,
  getDefaultProps: !0,
  getDerivedStateFromError: !0,
  getDerivedStateFromProps: !0,
  mixins: !0,
  propTypes: !0,
  type: !0
}, Wl = {
  name: !0,
  length: !0,
  prototype: !0,
  caller: !0,
  callee: !0,
  arguments: !0,
  arity: !0
}, ql = {
  $$typeof: !0,
  render: !0,
  defaultProps: !0,
  displayName: !0,
  propTypes: !0
}, ga = {
  $$typeof: !0,
  compare: !0,
  defaultProps: !0,
  displayName: !0,
  propTypes: !0,
  type: !0
}, xi = {};
xi[Si.ForwardRef] = ql;
xi[Si.Memo] = ga;
function ko(e) {
  return Si.isMemo(e) ? ga : xi[e.$$typeof] || Hl;
}
var zl = Object.defineProperty, Kl = Object.getOwnPropertyNames, Mo = Object.getOwnPropertySymbols, Yl = Object.getOwnPropertyDescriptor, Gl = Object.getPrototypeOf, Io = Object.prototype;
function ya(e, t, n) {
  if (typeof t != "string") {
    if (Io) {
      var r = Gl(t);
      r && r !== Io && ya(e, r, n);
    }
    var i = Kl(t);
    Mo && (i = i.concat(Mo(t)));
    for (var s = ko(e), o = ko(t), a = 0; a < i.length; ++a) {
      var c = i[a];
      if (!Wl[c] && !(n && n[c]) && !(o && o[c]) && !(s && s[c])) {
        var l = Yl(t, c);
        try {
          zl(e, c, l);
        } catch {
        }
      }
    }
  }
  return e;
}
var Xl = ya;
nr.__esModule = !0;
nr.default = void 0;
var Qt = Ql(je), Zl = va(ma), Jl = va(Xl);
function va(e) {
  return e && e.__esModule ? e : { default: e };
}
function Ql(e) {
  if (e && e.__esModule)
    return e;
  var t = {};
  if (e != null) {
    for (var n in e)
      if (Object.prototype.hasOwnProperty.call(e, n)) {
        var r = Object.defineProperty && Object.getOwnPropertyDescriptor ? Object.getOwnPropertyDescriptor(e, n) : {};
        r.get || r.set ? Object.defineProperty(t, n, r) : t[n] = e[n];
      }
  }
  return t.default = e, t;
}
function $n() {
  return $n = Object.assign || function(e) {
    for (var t = 1; t < arguments.length; t++) {
      var n = arguments[t];
      for (var r in n)
        Object.prototype.hasOwnProperty.call(n, r) && (e[r] = n[r]);
    }
    return e;
  }, $n.apply(this, arguments);
}
function eu(e, t) {
  if (e == null)
    return {};
  var n = {}, r = Object.keys(e), i, s;
  for (s = 0; s < r.length; s++)
    i = r[s], !(t.indexOf(i) >= 0) && (n[i] = e[i]);
  return n;
}
function Lo(e) {
  if (e === void 0)
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  return e;
}
function tu(e, t) {
  e.prototype = Object.create(t.prototype), e.prototype.constructor = e, e.__proto__ = t;
}
function Do(e, t, n) {
  return t in e ? Object.defineProperty(e, t, { value: n, enumerable: !0, configurable: !0, writable: !0 }) : e[t] = n, e;
}
var nu = function(t, n) {
  return function(i) {
    var s = /* @__PURE__ */ function(a) {
      tu(c, a);
      function c() {
        for (var u, d = arguments.length, h = new Array(d), m = 0; m < d; m++)
          h[m] = arguments[m];
        return u = a.call.apply(a, [this].concat(h)) || this, Do(Lo(u), "_previous", void 0), Do(Lo(u), "_merge", function(v, w) {
          var I = u._previous;
          if (I && I.a === v && I.b === w)
            return I.result;
          var E = v && w && v !== w ? (0, Zl.default)(v, w) : v || w;
          return u._previous = {
            a: v,
            b: w,
            result: E
          }, E;
        }), u;
      }
      var l = c.prototype;
      return l.render = function() {
        var d = this, h = this.props, m = h._reactThemeProviderForwardedRef, v = eu(h, ["_reactThemeProviderForwardedRef"]);
        return Qt.createElement(n.Consumer, null, function(w) {
          return Qt.createElement(i, $n({}, v, {
            theme: d._merge(w, v.theme),
            ref: m
          }));
        });
      }, c;
    }(Qt.Component), o = Qt.forwardRef(function(a, c) {
      return Qt.createElement(s, $n({}, a, {
        _reactThemeProviderForwardedRef: c
      }));
    });
    return o.displayName = "withTheme(" + (i.displayName || i.name) + ")", (0, Jl.default)(o, i), o;
  };
}, ru = nu;
nr.default = ru;
Ai.__esModule = !0;
Ai.default = cu;
var br = au(je), iu = Pi(ma), ou = Pi(tr), su = Pi(nr);
function Pi(e) {
  return e && e.__esModule ? e : { default: e };
}
function au(e) {
  if (e && e.__esModule)
    return e;
  var t = {};
  if (e != null) {
    for (var n in e)
      if (Object.prototype.hasOwnProperty.call(e, n)) {
        var r = Object.defineProperty && Object.getOwnPropertyDescriptor ? Object.getOwnPropertyDescriptor(e, n) : {};
        r.get || r.set ? Object.defineProperty(t, n, r) : t[n] = e[n];
      }
  }
  return t.default = e, t;
}
function cu(e) {
  var t = br.createContext(e), n = (0, ou.default)(e, t), r = (0, su.default)(n, t), i = function(o) {
    var a = br.useContext(t), c = br.useMemo(function() {
      return a && o ? (0, iu.default)(a, o) : a || o;
    }, [a, o]);
    return c;
  };
  return {
    ThemeContext: t,
    ThemeProvider: n,
    withTheme: r,
    useTheme: i
  };
}
var lu = fu(Ai), uu = lu.default;
function fu(e) {
  return e && e.__esModule ? e : { default: e };
}
const du = (e) => `${e.r}, ${e.g}, ${e.b}`, Kr = {
  displayTheme: "light",
  accent: {
    r: 0,
    g: 0,
    b: 0
  },
  titleHighlight: {
    r: 0,
    g: 122,
    b: 255
  },
  radius: "default"
}, wa = {
  primaryText: "0, 0, 0",
  background: "255, 255, 255",
  secondaryText: "146, 146, 147",
  light: "242, 242, 247"
}, hu = {
  primaryText: "240, 240, 240",
  background: "26, 27, 31",
  secondaryText: "161, 161, 161",
  light: "44, 45, 49"
}, Ta = uu({
  displayTheme: "light",
  theme: "0, 0, 0",
  themeConfig: Kr,
  ...wa
}), { ThemeProvider: pu, useTheme: uv } = Ta, Be = Ta.withTheme || ((e) => e);
function mu() {
  const { state: e, dispatch: t } = We(), n = lt();
  return Te(() => {
    (async () => n && t({
      type: "UPDATE_PERMISSIONS",
      payload: await n.getPermissions()
    }))();
  }, [t]), e.givenPermissions;
}
function gu() {
  const { state: e, dispatch: t } = We(), n = lt();
  Te(() => {
    async function r() {
      if (!n)
        return s(), t({
          type: "UPDATE_PERMISSIONS",
          payload: []
        });
      try {
        const a = await n.getPermissions();
        t({
          type: "UPDATE_PERMISSIONS",
          payload: a
        }), a.length === 0 && s();
      } catch {
        s(), t({
          type: "UPDATE_PERMISSIONS",
          payload: []
        });
      }
    }
    async function i(a) {
      a.data.type === "connect_result" && await r();
    }
    function s() {
      !e.activeAddress && !e.activeStrategy || (t({ type: "DISCONNECT" }), localStorage.removeItem(wn));
    }
    r(), addEventListener("arweaveWalletLoaded", r), addEventListener("focus", r), addEventListener("message", i);
    let o;
    return n && (o = n.addAddressEvent(r)), () => {
      removeEventListener("arweaveWalletLoaded", r), removeEventListener("focus", r), removeEventListener("message", i), n && o && n.removeAddressEvent(o);
    };
  }, [n, t]);
}
function Ci() {
  const [e, t] = He(!1), n = lt(), r = mu(), { state: i } = We(), { permissions: s, ensurePermissions: o } = i.config;
  return Te(() => {
    if (!n)
      return t(!1);
    t(o ? ua(s, r) : r.length > 0);
  }, [n, r, s, o]), e;
}
function yu() {
  const e = lt(), { dispatch: t } = We(), n = Ci();
  async function r() {
    if (!e || !n)
      throw new Error("[Arweave Wallet Kit] Not yet connected");
    try {
      await e.disconnect(), localStorage.removeItem(wn), t({ type: "DISCONNECT" });
    } catch (i) {
      throw new Error(
        `[Arweave Wallet Kit] Could not disconnect
` + ((i == null ? void 0 : i.message) || i)
      );
    }
  }
  return r;
}
function vu() {
  const { dispatch: e } = We(), t = Ci();
  return () => new Promise((r, i) => {
    if (t)
      return i("[Arweave Wallet Kit] Already connected");
    e({
      type: "OPEN_MODAL",
      payload: "connect"
    });
    async function s(o) {
      o.data.type === "connect_result" && (removeEventListener("message", s), o.data.res ? r() : i("[Arweave Wallet Kit] User cancelled the connection"));
    }
    addEventListener("message", s);
  });
}
function _i() {
  const e = Ci(), t = vu(), n = yu();
  return {
    connected: e,
    connect: t,
    disconnect: n
  };
}
function wu() {
  const { state: e, dispatch: t } = We();
  return Te(() => {
    e.activeStrategy || e.activeModal !== "profile" || t({ type: "CLOSE_MODAL" });
  }, [e, t]), {
    setOpen(n) {
      if (!e.activeStrategy)
        throw new Error("[Arweave Wallet Kit] App not connected");
      t(n ? {
        type: "OPEN_MODAL",
        payload: "profile"
      } : { type: "CLOSE_MODAL" });
    },
    open: e.activeModal === "profile"
  };
}
var ba = {}, Cn = {}, Oi = {}, Aa = { exports: {} };
(function(e) {
  (function(t) {
    var n, r = /^-?(?:\d+(?:\.\d*)?|\.\d+)(?:e[+-]?\d+)?$/i, i = Math.ceil, s = Math.floor, o = "[BigNumber Error] ", a = o + "Number primitive has more than 15 significant digits: ", c = 1e14, l = 14, u = 9007199254740991, d = [1, 10, 100, 1e3, 1e4, 1e5, 1e6, 1e7, 1e8, 1e9, 1e10, 1e11, 1e12, 1e13], h = 1e7, m = 1e9;
    function v(_) {
      var V, F, W, N = D.prototype = { constructor: D, toString: null, valueOf: null }, G = new D(1), ne = 20, J = 4, ue = -7, Q = 21, ge = -1e7, de = 1e7, Le = !1, Fe = 1, j = 0, H = {
        prefix: "",
        groupSize: 3,
        secondaryGroupSize: 0,
        groupSeparator: ",",
        decimalSeparator: ".",
        fractionGroupSize: 0,
        fractionGroupSeparator: "",
        // non-breaking space
        suffix: ""
      }, ee = "0123456789abcdefghijklmnopqrstuvwxyz", oe = !0;
      function D(f, g) {
        var p, C, A, x, k, b, S, R, O = this;
        if (!(O instanceof D))
          return new D(f, g);
        if (g == null) {
          if (f && f._isBigNumber === !0) {
            O.s = f.s, !f.c || f.e > de ? O.c = O.e = null : f.e < ge ? O.c = [O.e = 0] : (O.e = f.e, O.c = f.c.slice());
            return;
          }
          if ((b = typeof f == "number") && f * 0 == 0) {
            if (O.s = 1 / f < 0 ? (f = -f, -1) : 1, f === ~~f) {
              for (x = 0, k = f; k >= 10; k /= 10, x++)
                ;
              x > de ? O.c = O.e = null : (O.e = x, O.c = [f]);
              return;
            }
            R = String(f);
          } else {
            if (!r.test(R = String(f)))
              return W(O, R, b);
            O.s = R.charCodeAt(0) == 45 ? (R = R.slice(1), -1) : 1;
          }
          (x = R.indexOf(".")) > -1 && (R = R.replace(".", "")), (k = R.search(/e/i)) > 0 ? (x < 0 && (x = k), x += +R.slice(k + 1), R = R.substring(0, k)) : x < 0 && (x = R.length);
        } else {
          if (P(g, 2, ee.length, "Base"), g == 10 && oe)
            return O = new D(f), X(O, ne + O.e + 1, J);
          if (R = String(f), b = typeof f == "number") {
            if (f * 0 != 0)
              return W(O, R, b, g);
            if (O.s = 1 / f < 0 ? (R = R.slice(1), -1) : 1, D.DEBUG && R.replace(/^0\.0*|\./, "").length > 15)
              throw Error(a + f);
          } else
            O.s = R.charCodeAt(0) === 45 ? (R = R.slice(1), -1) : 1;
          for (p = ee.slice(0, g), x = k = 0, S = R.length; k < S; k++)
            if (p.indexOf(C = R.charAt(k)) < 0) {
              if (C == ".") {
                if (k > x) {
                  x = S;
                  continue;
                }
              } else if (!A && (R == R.toUpperCase() && (R = R.toLowerCase()) || R == R.toLowerCase() && (R = R.toUpperCase()))) {
                A = !0, k = -1, x = 0;
                continue;
              }
              return W(O, String(f), b, g);
            }
          b = !1, R = F(R, g, 10, O.s), (x = R.indexOf(".")) > -1 ? R = R.replace(".", "") : x = R.length;
        }
        for (k = 0; R.charCodeAt(k) === 48; k++)
          ;
        for (S = R.length; R.charCodeAt(--S) === 48; )
          ;
        if (R = R.slice(k, ++S)) {
          if (S -= k, b && D.DEBUG && S > 15 && (f > u || f !== s(f)))
            throw Error(a + O.s * f);
          if ((x = x - k - 1) > de)
            O.c = O.e = null;
          else if (x < ge)
            O.c = [O.e = 0];
          else {
            if (O.e = x, O.c = [], k = (x + 1) % l, x < 0 && (k += l), k < S) {
              for (k && O.c.push(+R.slice(0, k)), S -= l; k < S; )
                O.c.push(+R.slice(k, k += l));
              k = l - (R = R.slice(k)).length;
            } else
              k -= S;
            for (; k--; R += "0")
              ;
            O.c.push(+R);
          }
        } else
          O.c = [O.e = 0];
      }
      D.clone = v, D.ROUND_UP = 0, D.ROUND_DOWN = 1, D.ROUND_CEIL = 2, D.ROUND_FLOOR = 3, D.ROUND_HALF_UP = 4, D.ROUND_HALF_DOWN = 5, D.ROUND_HALF_EVEN = 6, D.ROUND_HALF_CEIL = 7, D.ROUND_HALF_FLOOR = 8, D.EUCLID = 9, D.config = D.set = function(f) {
        var g, p;
        if (f != null)
          if (typeof f == "object") {
            if (f.hasOwnProperty(g = "DECIMAL_PLACES") && (p = f[g], P(p, 0, m, g), ne = p), f.hasOwnProperty(g = "ROUNDING_MODE") && (p = f[g], P(p, 0, 8, g), J = p), f.hasOwnProperty(g = "EXPONENTIAL_AT") && (p = f[g], p && p.pop ? (P(p[0], -m, 0, g), P(p[1], 0, m, g), ue = p[0], Q = p[1]) : (P(p, -m, m, g), ue = -(Q = p < 0 ? -p : p))), f.hasOwnProperty(g = "RANGE"))
              if (p = f[g], p && p.pop)
                P(p[0], -m, -1, g), P(p[1], 1, m, g), ge = p[0], de = p[1];
              else if (P(p, -m, m, g), p)
                ge = -(de = p < 0 ? -p : p);
              else
                throw Error(o + g + " cannot be zero: " + p);
            if (f.hasOwnProperty(g = "CRYPTO"))
              if (p = f[g], p === !!p)
                if (p)
                  if (typeof crypto < "u" && crypto && (crypto.getRandomValues || crypto.randomBytes))
                    Le = p;
                  else
                    throw Le = !p, Error(o + "crypto unavailable");
                else
                  Le = p;
              else
                throw Error(o + g + " not true or false: " + p);
            if (f.hasOwnProperty(g = "MODULO_MODE") && (p = f[g], P(p, 0, 9, g), Fe = p), f.hasOwnProperty(g = "POW_PRECISION") && (p = f[g], P(p, 0, m, g), j = p), f.hasOwnProperty(g = "FORMAT"))
              if (p = f[g], typeof p == "object")
                H = p;
              else
                throw Error(o + g + " not an object: " + p);
            if (f.hasOwnProperty(g = "ALPHABET"))
              if (p = f[g], typeof p == "string" && !/^.?$|[+\-.\s]|(.).*\1/.test(p))
                oe = p.slice(0, 10) == "0123456789", ee = p;
              else
                throw Error(o + g + " invalid: " + p);
          } else
            throw Error(o + "Object expected: " + f);
        return {
          DECIMAL_PLACES: ne,
          ROUNDING_MODE: J,
          EXPONENTIAL_AT: [ue, Q],
          RANGE: [ge, de],
          CRYPTO: Le,
          MODULO_MODE: Fe,
          POW_PRECISION: j,
          FORMAT: H,
          ALPHABET: ee
        };
      }, D.isBigNumber = function(f) {
        if (!f || f._isBigNumber !== !0)
          return !1;
        if (!D.DEBUG)
          return !0;
        var g, p, C = f.c, A = f.e, x = f.s;
        e:
          if ({}.toString.call(C) == "[object Array]") {
            if ((x === 1 || x === -1) && A >= -m && A <= m && A === s(A)) {
              if (C[0] === 0) {
                if (A === 0 && C.length === 1)
                  return !0;
                break e;
              }
              if (g = (A + 1) % l, g < 1 && (g += l), String(C[0]).length == g) {
                for (g = 0; g < C.length; g++)
                  if (p = C[g], p < 0 || p >= c || p !== s(p))
                    break e;
                if (p !== 0)
                  return !0;
              }
            }
          } else if (C === null && A === null && (x === null || x === 1 || x === -1))
            return !0;
        throw Error(o + "Invalid BigNumber: " + f);
      }, D.maximum = D.max = function() {
        return re(arguments, N.lt);
      }, D.minimum = D.min = function() {
        return re(arguments, N.gt);
      }, D.random = function() {
        var f = 9007199254740992, g = Math.random() * f & 2097151 ? function() {
          return s(Math.random() * f);
        } : function() {
          return (Math.random() * 1073741824 | 0) * 8388608 + (Math.random() * 8388608 | 0);
        };
        return function(p) {
          var C, A, x, k, b, S = 0, R = [], O = new D(G);
          if (p == null ? p = ne : P(p, 0, m), k = i(p / l), Le)
            if (crypto.getRandomValues) {
              for (C = crypto.getRandomValues(new Uint32Array(k *= 2)); S < k; )
                b = C[S] * 131072 + (C[S + 1] >>> 11), b >= 9e15 ? (A = crypto.getRandomValues(new Uint32Array(2)), C[S] = A[0], C[S + 1] = A[1]) : (R.push(b % 1e14), S += 2);
              S = k / 2;
            } else if (crypto.randomBytes) {
              for (C = crypto.randomBytes(k *= 7); S < k; )
                b = (C[S] & 31) * 281474976710656 + C[S + 1] * 1099511627776 + C[S + 2] * 4294967296 + C[S + 3] * 16777216 + (C[S + 4] << 16) + (C[S + 5] << 8) + C[S + 6], b >= 9e15 ? crypto.randomBytes(7).copy(C, S) : (R.push(b % 1e14), S += 7);
              S = k / 7;
            } else
              throw Le = !1, Error(o + "crypto unavailable");
          if (!Le)
            for (; S < k; )
              b = g(), b < 9e15 && (R[S++] = b % 1e14);
          for (k = R[--S], p %= l, k && p && (b = d[l - p], R[S] = s(k / b) * b); R[S] === 0; R.pop(), S--)
            ;
          if (S < 0)
            R = [x = 0];
          else {
            for (x = -1; R[0] === 0; R.splice(0, 1), x -= l)
              ;
            for (S = 1, b = R[0]; b >= 10; b /= 10, S++)
              ;
            S < l && (x -= l - S);
          }
          return O.e = x, O.c = R, O;
        };
      }(), D.sum = function() {
        for (var f = 1, g = arguments, p = new D(g[0]); f < g.length; )
          p = p.plus(g[f++]);
        return p;
      }, F = function() {
        var f = "0123456789";
        function g(p, C, A, x) {
          for (var k, b = [0], S, R = 0, O = p.length; R < O; ) {
            for (S = b.length; S--; b[S] *= C)
              ;
            for (b[0] += x.indexOf(p.charAt(R++)), k = 0; k < b.length; k++)
              b[k] > A - 1 && (b[k + 1] == null && (b[k + 1] = 0), b[k + 1] += b[k] / A | 0, b[k] %= A);
          }
          return b.reverse();
        }
        return function(p, C, A, x, k) {
          var b, S, R, O, B, z, Y, pe, Ce = p.indexOf("."), ke = ne, le = J;
          for (Ce >= 0 && (O = j, j = 0, p = p.replace(".", ""), pe = new D(C), z = pe.pow(p.length - Ce), j = O, pe.c = g(
            T(I(z.c), z.e, "0"),
            10,
            A,
            f
          ), pe.e = pe.c.length), Y = g(p, C, A, k ? (b = ee, f) : (b = f, ee)), R = O = Y.length; Y[--O] == 0; Y.pop())
            ;
          if (!Y[0])
            return b.charAt(0);
          if (Ce < 0 ? --R : (z.c = Y, z.e = R, z.s = x, z = V(z, pe, ke, le, A), Y = z.c, B = z.r, R = z.e), S = R + ke + 1, Ce = Y[S], O = A / 2, B = B || S < 0 || Y[S + 1] != null, B = le < 4 ? (Ce != null || B) && (le == 0 || le == (z.s < 0 ? 3 : 2)) : Ce > O || Ce == O && (le == 4 || B || le == 6 && Y[S - 1] & 1 || le == (z.s < 0 ? 8 : 7)), S < 1 || !Y[0])
            p = B ? T(b.charAt(1), -ke, b.charAt(0)) : b.charAt(0);
          else {
            if (Y.length = S, B)
              for (--A; ++Y[--S] > A; )
                Y[S] = 0, S || (++R, Y = [1].concat(Y));
            for (O = Y.length; !Y[--O]; )
              ;
            for (Ce = 0, p = ""; Ce <= O; p += b.charAt(Y[Ce++]))
              ;
            p = T(p, R, b.charAt(0));
          }
          return p;
        };
      }(), V = function() {
        function f(C, A, x) {
          var k, b, S, R, O = 0, B = C.length, z = A % h, Y = A / h | 0;
          for (C = C.slice(); B--; )
            S = C[B] % h, R = C[B] / h | 0, k = Y * S + R * z, b = z * S + k % h * h + O, O = (b / x | 0) + (k / h | 0) + Y * R, C[B] = b % x;
          return O && (C = [O].concat(C)), C;
        }
        function g(C, A, x, k) {
          var b, S;
          if (x != k)
            S = x > k ? 1 : -1;
          else
            for (b = S = 0; b < x; b++)
              if (C[b] != A[b]) {
                S = C[b] > A[b] ? 1 : -1;
                break;
              }
          return S;
        }
        function p(C, A, x, k) {
          for (var b = 0; x--; )
            C[x] -= b, b = C[x] < A[x] ? 1 : 0, C[x] = b * k + C[x] - A[x];
          for (; !C[0] && C.length > 1; C.splice(0, 1))
            ;
        }
        return function(C, A, x, k, b) {
          var S, R, O, B, z, Y, pe, Ce, ke, le, be, Ve, At, Et, Xt, Qe, St, Ge = C.s == A.s ? 1 : -1, Ue = C.c, _e = A.c;
          if (!Ue || !Ue[0] || !_e || !_e[0])
            return new D(
              // Return NaN if either NaN, or both Infinity or 0.
              !C.s || !A.s || (Ue ? _e && Ue[0] == _e[0] : !_e) ? NaN : (
                // Return 0 if x is 0 or y is Infinity, or return Infinity as y is 0.
                Ue && Ue[0] == 0 || !_e ? Ge * 0 : Ge / 0
              )
            );
          for (Ce = new D(Ge), ke = Ce.c = [], R = C.e - A.e, Ge = x + R + 1, b || (b = c, R = w(C.e / l) - w(A.e / l), Ge = Ge / l | 0), O = 0; _e[O] == (Ue[O] || 0); O++)
            ;
          if (_e[O] > (Ue[O] || 0) && R--, Ge < 0)
            ke.push(1), B = !0;
          else {
            for (Et = Ue.length, Qe = _e.length, O = 0, Ge += 2, z = s(b / (_e[0] + 1)), z > 1 && (_e = f(_e, z, b), Ue = f(Ue, z, b), Qe = _e.length, Et = Ue.length), At = Qe, le = Ue.slice(0, Qe), be = le.length; be < Qe; le[be++] = 0)
              ;
            St = _e.slice(), St = [0].concat(St), Xt = _e[0], _e[1] >= b / 2 && Xt++;
            do {
              if (z = 0, S = g(_e, le, Qe, be), S < 0) {
                if (Ve = le[0], Qe != be && (Ve = Ve * b + (le[1] || 0)), z = s(Ve / Xt), z > 1)
                  for (z >= b && (z = b - 1), Y = f(_e, z, b), pe = Y.length, be = le.length; g(Y, le, pe, be) == 1; )
                    z--, p(Y, Qe < pe ? St : _e, pe, b), pe = Y.length, S = 1;
                else
                  z == 0 && (S = z = 1), Y = _e.slice(), pe = Y.length;
                if (pe < be && (Y = [0].concat(Y)), p(le, Y, be, b), be = le.length, S == -1)
                  for (; g(_e, le, Qe, be) < 1; )
                    z++, p(le, Qe < be ? St : _e, be, b), be = le.length;
              } else
                S === 0 && (z++, le = [0]);
              ke[O++] = z, le[0] ? le[be++] = Ue[At] || 0 : (le = [Ue[At]], be = 1);
            } while ((At++ < Et || le[0] != null) && Ge--);
            B = le[0] != null, ke[0] || ke.splice(0, 1);
          }
          if (b == c) {
            for (O = 1, Ge = ke[0]; Ge >= 10; Ge /= 10, O++)
              ;
            X(Ce, x + (Ce.e = O + R * l - 1) + 1, k, B);
          } else
            Ce.e = R, Ce.r = +B;
          return Ce;
        };
      }();
      function fe(f, g, p, C) {
        var A, x, k, b, S;
        if (p == null ? p = J : P(p, 0, 8), !f.c)
          return f.toString();
        if (A = f.c[0], k = f.e, g == null)
          S = I(f.c), S = C == 1 || C == 2 && (k <= ue || k >= Q) ? L(S, k) : T(S, k, "0");
        else if (f = X(new D(f), g, p), x = f.e, S = I(f.c), b = S.length, C == 1 || C == 2 && (g <= x || x <= ue)) {
          for (; b < g; S += "0", b++)
            ;
          S = L(S, x);
        } else if (g -= k, S = T(S, x, "0"), x + 1 > b) {
          if (--g > 0)
            for (S += "."; g--; S += "0")
              ;
        } else if (g += x - b, g > 0)
          for (x + 1 == b && (S += "."); g--; S += "0")
            ;
        return f.s < 0 && A ? "-" + S : S;
      }
      function re(f, g) {
        for (var p, C = 1, A = new D(f[0]); C < f.length; C++)
          if (p = new D(f[C]), p.s)
            g.call(A, p) && (A = p);
          else {
            A = p;
            break;
          }
        return A;
      }
      function ie(f, g, p) {
        for (var C = 1, A = g.length; !g[--A]; g.pop())
          ;
        for (A = g[0]; A >= 10; A /= 10, C++)
          ;
        return (p = C + p * l - 1) > de ? f.c = f.e = null : p < ge ? f.c = [f.e = 0] : (f.e = p, f.c = g), f;
      }
      W = function() {
        var f = /^(-?)0([xbo])(?=\w[\w.]*$)/i, g = /^([^.]+)\.$/, p = /^\.([^.]+)$/, C = /^-?(Infinity|NaN)$/, A = /^\s*\+(?=[\w.])|^\s+|\s+$/g;
        return function(x, k, b, S) {
          var R, O = b ? k : k.replace(A, "");
          if (C.test(O))
            x.s = isNaN(O) ? null : O < 0 ? -1 : 1;
          else {
            if (!b && (O = O.replace(f, function(B, z, Y) {
              return R = (Y = Y.toLowerCase()) == "x" ? 16 : Y == "b" ? 2 : 8, !S || S == R ? z : B;
            }), S && (R = S, O = O.replace(g, "$1").replace(p, "0.$1")), k != O))
              return new D(O, R);
            if (D.DEBUG)
              throw Error(o + "Not a" + (S ? " base " + S : "") + " number: " + k);
            x.s = null;
          }
          x.c = x.e = null;
        };
      }();
      function X(f, g, p, C) {
        var A, x, k, b, S, R, O, B = f.c, z = d;
        if (B) {
          e: {
            for (A = 1, b = B[0]; b >= 10; b /= 10, A++)
              ;
            if (x = g - A, x < 0)
              x += l, k = g, S = B[R = 0], O = S / z[A - k - 1] % 10 | 0;
            else if (R = i((x + 1) / l), R >= B.length)
              if (C) {
                for (; B.length <= R; B.push(0))
                  ;
                S = O = 0, A = 1, x %= l, k = x - l + 1;
              } else
                break e;
            else {
              for (S = b = B[R], A = 1; b >= 10; b /= 10, A++)
                ;
              x %= l, k = x - l + A, O = k < 0 ? 0 : S / z[A - k - 1] % 10 | 0;
            }
            if (C = C || g < 0 || // Are there any non-zero digits after the rounding digit?
            // The expression  n % pows10[d - j - 1]  returns all digits of n to the right
            // of the digit at j, e.g. if n is 908714 and j is 2, the expression gives 714.
            B[R + 1] != null || (k < 0 ? S : S % z[A - k - 1]), C = p < 4 ? (O || C) && (p == 0 || p == (f.s < 0 ? 3 : 2)) : O > 5 || O == 5 && (p == 4 || C || p == 6 && // Check whether the digit to the left of the rounding digit is odd.
            (x > 0 ? k > 0 ? S / z[A - k] : 0 : B[R - 1]) % 10 & 1 || p == (f.s < 0 ? 8 : 7)), g < 1 || !B[0])
              return B.length = 0, C ? (g -= f.e + 1, B[0] = z[(l - g % l) % l], f.e = -g || 0) : B[0] = f.e = 0, f;
            if (x == 0 ? (B.length = R, b = 1, R--) : (B.length = R + 1, b = z[l - x], B[R] = k > 0 ? s(S / z[A - k] % z[k]) * b : 0), C)
              for (; ; )
                if (R == 0) {
                  for (x = 1, k = B[0]; k >= 10; k /= 10, x++)
                    ;
                  for (k = B[0] += b, b = 1; k >= 10; k /= 10, b++)
                    ;
                  x != b && (f.e++, B[0] == c && (B[0] = 1));
                  break;
                } else {
                  if (B[R] += b, B[R] != c)
                    break;
                  B[R--] = 0, b = 1;
                }
            for (x = B.length; B[--x] === 0; B.pop())
              ;
          }
          f.e > de ? f.c = f.e = null : f.e < ge && (f.c = [f.e = 0]);
        }
        return f;
      }
      function se(f) {
        var g, p = f.e;
        return p === null ? f.toString() : (g = I(f.c), g = p <= ue || p >= Q ? L(g, p) : T(g, p, "0"), f.s < 0 ? "-" + g : g);
      }
      return N.absoluteValue = N.abs = function() {
        var f = new D(this);
        return f.s < 0 && (f.s = 1), f;
      }, N.comparedTo = function(f, g) {
        return E(this, new D(f, g));
      }, N.decimalPlaces = N.dp = function(f, g) {
        var p, C, A, x = this;
        if (f != null)
          return P(f, 0, m), g == null ? g = J : P(g, 0, 8), X(new D(x), f + x.e + 1, g);
        if (!(p = x.c))
          return null;
        if (C = ((A = p.length - 1) - w(this.e / l)) * l, A = p[A])
          for (; A % 10 == 0; A /= 10, C--)
            ;
        return C < 0 && (C = 0), C;
      }, N.dividedBy = N.div = function(f, g) {
        return V(this, new D(f, g), ne, J);
      }, N.dividedToIntegerBy = N.idiv = function(f, g) {
        return V(this, new D(f, g), 0, 1);
      }, N.exponentiatedBy = N.pow = function(f, g) {
        var p, C, A, x, k, b, S, R, O, B = this;
        if (f = new D(f), f.c && !f.isInteger())
          throw Error(o + "Exponent not an integer: " + se(f));
        if (g != null && (g = new D(g)), b = f.e > 14, !B.c || !B.c[0] || B.c[0] == 1 && !B.e && B.c.length == 1 || !f.c || !f.c[0])
          return O = new D(Math.pow(+se(B), b ? f.s * (2 - M(f)) : +se(f))), g ? O.mod(g) : O;
        if (S = f.s < 0, g) {
          if (g.c ? !g.c[0] : !g.s)
            return new D(NaN);
          C = !S && B.isInteger() && g.isInteger(), C && (B = B.mod(g));
        } else {
          if (f.e > 9 && (B.e > 0 || B.e < -1 || (B.e == 0 ? B.c[0] > 1 || b && B.c[1] >= 24e7 : B.c[0] < 8e13 || b && B.c[0] <= 9999975e7)))
            return x = B.s < 0 && M(f) ? -0 : 0, B.e > -1 && (x = 1 / x), new D(S ? 1 / x : x);
          j && (x = i(j / l + 2));
        }
        for (b ? (p = new D(0.5), S && (f.s = 1), R = M(f)) : (A = Math.abs(+se(f)), R = A % 2), O = new D(G); ; ) {
          if (R) {
            if (O = O.times(B), !O.c)
              break;
            x ? O.c.length > x && (O.c.length = x) : C && (O = O.mod(g));
          }
          if (A) {
            if (A = s(A / 2), A === 0)
              break;
            R = A % 2;
          } else if (f = f.times(p), X(f, f.e + 1, 1), f.e > 14)
            R = M(f);
          else {
            if (A = +se(f), A === 0)
              break;
            R = A % 2;
          }
          B = B.times(B), x ? B.c && B.c.length > x && (B.c.length = x) : C && (B = B.mod(g));
        }
        return C ? O : (S && (O = G.div(O)), g ? O.mod(g) : x ? X(O, j, J, k) : O);
      }, N.integerValue = function(f) {
        var g = new D(this);
        return f == null ? f = J : P(f, 0, 8), X(g, g.e + 1, f);
      }, N.isEqualTo = N.eq = function(f, g) {
        return E(this, new D(f, g)) === 0;
      }, N.isFinite = function() {
        return !!this.c;
      }, N.isGreaterThan = N.gt = function(f, g) {
        return E(this, new D(f, g)) > 0;
      }, N.isGreaterThanOrEqualTo = N.gte = function(f, g) {
        return (g = E(this, new D(f, g))) === 1 || g === 0;
      }, N.isInteger = function() {
        return !!this.c && w(this.e / l) > this.c.length - 2;
      }, N.isLessThan = N.lt = function(f, g) {
        return E(this, new D(f, g)) < 0;
      }, N.isLessThanOrEqualTo = N.lte = function(f, g) {
        return (g = E(this, new D(f, g))) === -1 || g === 0;
      }, N.isNaN = function() {
        return !this.s;
      }, N.isNegative = function() {
        return this.s < 0;
      }, N.isPositive = function() {
        return this.s > 0;
      }, N.isZero = function() {
        return !!this.c && this.c[0] == 0;
      }, N.minus = function(f, g) {
        var p, C, A, x, k = this, b = k.s;
        if (f = new D(f, g), g = f.s, !b || !g)
          return new D(NaN);
        if (b != g)
          return f.s = -g, k.plus(f);
        var S = k.e / l, R = f.e / l, O = k.c, B = f.c;
        if (!S || !R) {
          if (!O || !B)
            return O ? (f.s = -g, f) : new D(B ? k : NaN);
          if (!O[0] || !B[0])
            return B[0] ? (f.s = -g, f) : new D(O[0] ? k : (
              // IEEE 754 (2008) 6.3: n - n = -0 when rounding to -Infinity
              J == 3 ? -0 : 0
            ));
        }
        if (S = w(S), R = w(R), O = O.slice(), b = S - R) {
          for ((x = b < 0) ? (b = -b, A = O) : (R = S, A = B), A.reverse(), g = b; g--; A.push(0))
            ;
          A.reverse();
        } else
          for (C = (x = (b = O.length) < (g = B.length)) ? b : g, b = g = 0; g < C; g++)
            if (O[g] != B[g]) {
              x = O[g] < B[g];
              break;
            }
        if (x && (A = O, O = B, B = A, f.s = -f.s), g = (C = B.length) - (p = O.length), g > 0)
          for (; g--; O[p++] = 0)
            ;
        for (g = c - 1; C > b; ) {
          if (O[--C] < B[C]) {
            for (p = C; p && !O[--p]; O[p] = g)
              ;
            --O[p], O[C] += c;
          }
          O[C] -= B[C];
        }
        for (; O[0] == 0; O.splice(0, 1), --R)
          ;
        return O[0] ? ie(f, O, R) : (f.s = J == 3 ? -1 : 1, f.c = [f.e = 0], f);
      }, N.modulo = N.mod = function(f, g) {
        var p, C, A = this;
        return f = new D(f, g), !A.c || !f.s || f.c && !f.c[0] ? new D(NaN) : !f.c || A.c && !A.c[0] ? new D(A) : (Fe == 9 ? (C = f.s, f.s = 1, p = V(A, f, 0, 3), f.s = C, p.s *= C) : p = V(A, f, 0, Fe), f = A.minus(p.times(f)), !f.c[0] && Fe == 1 && (f.s = A.s), f);
      }, N.multipliedBy = N.times = function(f, g) {
        var p, C, A, x, k, b, S, R, O, B, z, Y, pe, Ce, ke, le = this, be = le.c, Ve = (f = new D(f, g)).c;
        if (!be || !Ve || !be[0] || !Ve[0])
          return !le.s || !f.s || be && !be[0] && !Ve || Ve && !Ve[0] && !be ? f.c = f.e = f.s = null : (f.s *= le.s, !be || !Ve ? f.c = f.e = null : (f.c = [0], f.e = 0)), f;
        for (C = w(le.e / l) + w(f.e / l), f.s *= le.s, S = be.length, B = Ve.length, S < B && (pe = be, be = Ve, Ve = pe, A = S, S = B, B = A), A = S + B, pe = []; A--; pe.push(0))
          ;
        for (Ce = c, ke = h, A = B; --A >= 0; ) {
          for (p = 0, z = Ve[A] % ke, Y = Ve[A] / ke | 0, k = S, x = A + k; x > A; )
            R = be[--k] % ke, O = be[k] / ke | 0, b = Y * R + O * z, R = z * R + b % ke * ke + pe[x] + p, p = (R / Ce | 0) + (b / ke | 0) + Y * O, pe[x--] = R % Ce;
          pe[x] = p;
        }
        return p ? ++C : pe.splice(0, 1), ie(f, pe, C);
      }, N.negated = function() {
        var f = new D(this);
        return f.s = -f.s || null, f;
      }, N.plus = function(f, g) {
        var p, C = this, A = C.s;
        if (f = new D(f, g), g = f.s, !A || !g)
          return new D(NaN);
        if (A != g)
          return f.s = -g, C.minus(f);
        var x = C.e / l, k = f.e / l, b = C.c, S = f.c;
        if (!x || !k) {
          if (!b || !S)
            return new D(A / 0);
          if (!b[0] || !S[0])
            return S[0] ? f : new D(b[0] ? C : A * 0);
        }
        if (x = w(x), k = w(k), b = b.slice(), A = x - k) {
          for (A > 0 ? (k = x, p = S) : (A = -A, p = b), p.reverse(); A--; p.push(0))
            ;
          p.reverse();
        }
        for (A = b.length, g = S.length, A - g < 0 && (p = S, S = b, b = p, g = A), A = 0; g; )
          A = (b[--g] = b[g] + S[g] + A) / c | 0, b[g] = c === b[g] ? 0 : b[g] % c;
        return A && (b = [A].concat(b), ++k), ie(f, b, k);
      }, N.precision = N.sd = function(f, g) {
        var p, C, A, x = this;
        if (f != null && f !== !!f)
          return P(f, 1, m), g == null ? g = J : P(g, 0, 8), X(new D(x), f, g);
        if (!(p = x.c))
          return null;
        if (A = p.length - 1, C = A * l + 1, A = p[A]) {
          for (; A % 10 == 0; A /= 10, C--)
            ;
          for (A = p[0]; A >= 10; A /= 10, C++)
            ;
        }
        return f && x.e + 1 > C && (C = x.e + 1), C;
      }, N.shiftedBy = function(f) {
        return P(f, -u, u), this.times("1e" + f);
      }, N.squareRoot = N.sqrt = function() {
        var f, g, p, C, A, x = this, k = x.c, b = x.s, S = x.e, R = ne + 4, O = new D("0.5");
        if (b !== 1 || !k || !k[0])
          return new D(!b || b < 0 && (!k || k[0]) ? NaN : k ? x : 1 / 0);
        if (b = Math.sqrt(+se(x)), b == 0 || b == 1 / 0 ? (g = I(k), (g.length + S) % 2 == 0 && (g += "0"), b = Math.sqrt(+g), S = w((S + 1) / 2) - (S < 0 || S % 2), b == 1 / 0 ? g = "5e" + S : (g = b.toExponential(), g = g.slice(0, g.indexOf("e") + 1) + S), p = new D(g)) : p = new D(b + ""), p.c[0]) {
          for (S = p.e, b = S + R, b < 3 && (b = 0); ; )
            if (A = p, p = O.times(A.plus(V(x, A, R, 1))), I(A.c).slice(0, b) === (g = I(p.c)).slice(0, b))
              if (p.e < S && --b, g = g.slice(b - 3, b + 1), g == "9999" || !C && g == "4999") {
                if (!C && (X(A, A.e + ne + 2, 0), A.times(A).eq(x))) {
                  p = A;
                  break;
                }
                R += 4, b += 4, C = 1;
              } else {
                (!+g || !+g.slice(1) && g.charAt(0) == "5") && (X(p, p.e + ne + 2, 1), f = !p.times(p).eq(x));
                break;
              }
        }
        return X(p, p.e + ne + 1, J, f);
      }, N.toExponential = function(f, g) {
        return f != null && (P(f, 0, m), f++), fe(this, f, g, 1);
      }, N.toFixed = function(f, g) {
        return f != null && (P(f, 0, m), f = f + this.e + 1), fe(this, f, g);
      }, N.toFormat = function(f, g, p) {
        var C, A = this;
        if (p == null)
          f != null && g && typeof g == "object" ? (p = g, g = null) : f && typeof f == "object" ? (p = f, f = g = null) : p = H;
        else if (typeof p != "object")
          throw Error(o + "Argument not an object: " + p);
        if (C = A.toFixed(f, g), A.c) {
          var x, k = C.split("."), b = +p.groupSize, S = +p.secondaryGroupSize, R = p.groupSeparator || "", O = k[0], B = k[1], z = A.s < 0, Y = z ? O.slice(1) : O, pe = Y.length;
          if (S && (x = b, b = S, S = x, pe -= x), b > 0 && pe > 0) {
            for (x = pe % b || b, O = Y.substr(0, x); x < pe; x += b)
              O += R + Y.substr(x, b);
            S > 0 && (O += R + Y.slice(x)), z && (O = "-" + O);
          }
          C = B ? O + (p.decimalSeparator || "") + ((S = +p.fractionGroupSize) ? B.replace(
            new RegExp("\\d{" + S + "}\\B", "g"),
            "$&" + (p.fractionGroupSeparator || "")
          ) : B) : O;
        }
        return (p.prefix || "") + C + (p.suffix || "");
      }, N.toFraction = function(f) {
        var g, p, C, A, x, k, b, S, R, O, B, z, Y = this, pe = Y.c;
        if (f != null && (b = new D(f), !b.isInteger() && (b.c || b.s !== 1) || b.lt(G)))
          throw Error(o + "Argument " + (b.isInteger() ? "out of range: " : "not an integer: ") + se(b));
        if (!pe)
          return new D(Y);
        for (g = new D(G), R = p = new D(G), C = S = new D(G), z = I(pe), x = g.e = z.length - Y.e - 1, g.c[0] = d[(k = x % l) < 0 ? l + k : k], f = !f || b.comparedTo(g) > 0 ? x > 0 ? g : R : b, k = de, de = 1 / 0, b = new D(z), S.c[0] = 0; O = V(b, g, 0, 1), A = p.plus(O.times(C)), A.comparedTo(f) != 1; )
          p = C, C = A, R = S.plus(O.times(A = R)), S = A, g = b.minus(O.times(A = g)), b = A;
        return A = V(f.minus(p), C, 0, 1), S = S.plus(A.times(R)), p = p.plus(A.times(C)), S.s = R.s = Y.s, x = x * 2, B = V(R, C, x, J).minus(Y).abs().comparedTo(
          V(S, p, x, J).minus(Y).abs()
        ) < 1 ? [R, C] : [S, p], de = k, B;
      }, N.toNumber = function() {
        return +se(this);
      }, N.toPrecision = function(f, g) {
        return f != null && P(f, 1, m), fe(this, f, g, 2);
      }, N.toString = function(f) {
        var g, p = this, C = p.s, A = p.e;
        return A === null ? C ? (g = "Infinity", C < 0 && (g = "-" + g)) : g = "NaN" : (f == null ? g = A <= ue || A >= Q ? L(I(p.c), A) : T(I(p.c), A, "0") : f === 10 && oe ? (p = X(new D(p), ne + A + 1, J), g = T(I(p.c), p.e, "0")) : (P(f, 2, ee.length, "Base"), g = F(T(I(p.c), A, "0"), 10, f, C, !0)), C < 0 && p.c[0] && (g = "-" + g)), g;
      }, N.valueOf = N.toJSON = function() {
        return se(this);
      }, N._isBigNumber = !0, _ != null && D.set(_), D;
    }
    function w(_) {
      var V = _ | 0;
      return _ > 0 || _ === V ? V : V - 1;
    }
    function I(_) {
      for (var V, F, W = 1, N = _.length, G = _[0] + ""; W < N; ) {
        for (V = _[W++] + "", F = l - V.length; F--; V = "0" + V)
          ;
        G += V;
      }
      for (N = G.length; G.charCodeAt(--N) === 48; )
        ;
      return G.slice(0, N + 1 || 1);
    }
    function E(_, V) {
      var F, W, N = _.c, G = V.c, ne = _.s, J = V.s, ue = _.e, Q = V.e;
      if (!ne || !J)
        return null;
      if (F = N && !N[0], W = G && !G[0], F || W)
        return F ? W ? 0 : -J : ne;
      if (ne != J)
        return ne;
      if (F = ne < 0, W = ue == Q, !N || !G)
        return W ? 0 : !N ^ F ? 1 : -1;
      if (!W)
        return ue > Q ^ F ? 1 : -1;
      for (J = (ue = N.length) < (Q = G.length) ? ue : Q, ne = 0; ne < J; ne++)
        if (N[ne] != G[ne])
          return N[ne] > G[ne] ^ F ? 1 : -1;
      return ue == Q ? 0 : ue > Q ^ F ? 1 : -1;
    }
    function P(_, V, F, W) {
      if (_ < V || _ > F || _ !== s(_))
        throw Error(o + (W || "Argument") + (typeof _ == "number" ? _ < V || _ > F ? " out of range: " : " not an integer: " : " not a primitive number: ") + String(_));
    }
    function M(_) {
      var V = _.c.length - 1;
      return w(_.e / l) == V && _.c[V] % 2 != 0;
    }
    function L(_, V) {
      return (_.length > 1 ? _.charAt(0) + "." + _.slice(1) : _) + (V < 0 ? "e" : "e+") + V;
    }
    function T(_, V, F) {
      var W, N;
      if (V < 0) {
        for (N = F + "."; ++V; N += F)
          ;
        _ = N + _;
      } else if (W = _.length, ++V > W) {
        for (N = F, V -= W; --V; N += F)
          ;
        _ += N;
      } else
        V < W && (_ = _.slice(0, V) + "." + _.slice(V));
      return _;
    }
    n = v(), n.default = n.BigNumber = n, e.exports ? e.exports = n : (t || (t = typeof self < "u" && self ? self : window), t.BigNumber = n);
  })($t);
})(Aa);
var Tu = Aa.exports;
Object.defineProperty(Oi, "__esModule", { value: !0 });
const bu = Tu;
class Au {
  constructor() {
    /**
     * Method to take a string value and return a bignumber object.
     *
     * @protected
     * @type {Function}
     * @memberof Arweave
     */
    q(this, "BigNum");
    this.BigNum = (t, n) => {
      let r = bu.BigNumber.clone({ DECIMAL_PLACES: n });
      return new r(t);
    };
  }
  winstonToAr(t, { formatted: n = !1, decimals: r = 12, trim: i = !0 } = {}) {
    let s = this.stringToBigNum(t, r).shiftedBy(-12);
    return n ? s.toFormat(r) : s.toFixed(r);
  }
  arToWinston(t, { formatted: n = !1 } = {}) {
    let r = this.stringToBigNum(t).shiftedBy(12);
    return n ? r.toFormat() : r.toFixed(0);
  }
  compare(t, n) {
    let r = this.stringToBigNum(t), i = this.stringToBigNum(n);
    return r.comparedTo(i);
  }
  isEqual(t, n) {
    return this.compare(t, n) === 0;
  }
  isLessThan(t, n) {
    let r = this.stringToBigNum(t), i = this.stringToBigNum(n);
    return r.isLessThan(i);
  }
  isGreaterThan(t, n) {
    let r = this.stringToBigNum(t), i = this.stringToBigNum(n);
    return r.isGreaterThan(i);
  }
  add(t, n) {
    let r = this.stringToBigNum(t);
    return this.stringToBigNum(n), r.plus(n).toFixed(0);
  }
  sub(t, n) {
    let r = this.stringToBigNum(t);
    return this.stringToBigNum(n), r.minus(n).toFixed(0);
  }
  stringToBigNum(t, n = 12) {
    return this.BigNum(t, n);
  }
}
Oi.default = Au;
var Ri = {};
Object.defineProperty(Ri, "__esModule", { value: !0 });
class Eu {
  constructor(t) {
    q(this, "METHOD_GET", "GET");
    q(this, "METHOD_POST", "POST");
    q(this, "config");
    this.applyConfig(t);
  }
  applyConfig(t) {
    this.config = this.mergeDefaults(t);
  }
  getConfig() {
    return this.config;
  }
  mergeDefaults(t) {
    const n = t.protocol || "http", r = t.port || (n === "https" ? 443 : 80);
    return {
      host: t.host || "127.0.0.1",
      protocol: n,
      port: r,
      timeout: t.timeout || 2e4,
      logging: t.logging || !1,
      logger: t.logger || console.log,
      network: t.network
    };
  }
  async get(t, n) {
    return await this.request(t, { ...n, method: this.METHOD_GET });
  }
  async post(t, n, r) {
    var s;
    const i = new Headers((r == null ? void 0 : r.headers) || {});
    return (s = i.get("content-type")) != null && s.includes("application/json") || i.append("content-type", "application/json"), i.append("accept", "application/json, text/plain, */*"), await this.request(t, {
      ...r,
      method: this.METHOD_POST,
      body: typeof n != "string" ? JSON.stringify(n) : n,
      headers: i
    });
  }
  async request(t, n) {
    var d;
    const r = new Headers((n == null ? void 0 : n.headers) || {}), i = `${this.config.protocol}://${this.config.host}:${this.config.port}`, s = n == null ? void 0 : n.responseType;
    n == null || delete n.responseType, t.startsWith("/") && (t = t.slice(1)), this.config.network && r.append("x-network", this.config.network), this.config.logging && this.config.logger(`Requesting: ${i}/${t}`);
    let o = await fetch(`${i}/${t}`, {
      ...n || {},
      headers: r
    });
    this.config.logging && this.config.logger(`Response:   ${o.url} - ${o.status}`);
    const a = o.headers.get("content-type"), c = (d = a == null ? void 0 : a.match(/charset=([^()<>@,;:\"/[\]?.=\s]*)/i)) == null ? void 0 : d[1], l = o, u = async () => {
      if (c)
        try {
          l.data = new TextDecoder(c).decode(await o.arrayBuffer());
        } catch {
          l.data = await o.text();
        }
      else
        l.data = await o.text();
    };
    if (s === "arraybuffer")
      l.data = await o.arrayBuffer();
    else if (s === "text")
      await u();
    else if (s === "webstream")
      l.data = Su(o.body);
    else
      try {
        let h = await o.clone().json();
        typeof h != "object" ? await u() : l.data = await o.json(), h = null;
      } catch {
        await u();
      }
    return l;
  }
}
Ri.default = Eu;
const Su = (e) => {
  const t = e;
  return typeof t[Symbol.asyncIterator] > "u" ? (t[Symbol.asyncIterator] = xu(e), t) : e;
}, xu = function(e) {
  return async function* () {
    const n = e.getReader();
    try {
      for (; ; ) {
        const { done: r, value: i } = await n.read();
        if (r)
          return;
        yield i;
      }
    } finally {
      n.releaseLock();
    }
  };
};
var ki = {}, Se = {}, rr = {};
rr.byteLength = _u;
rr.toByteArray = Ru;
rr.fromByteArray = Iu;
var at = [], tt = [], Pu = typeof Uint8Array < "u" ? Uint8Array : Array, Ar = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/";
for (var Dt = 0, Cu = Ar.length; Dt < Cu; ++Dt)
  at[Dt] = Ar[Dt], tt[Ar.charCodeAt(Dt)] = Dt;
tt["-".charCodeAt(0)] = 62;
tt["_".charCodeAt(0)] = 63;
function Ea(e) {
  var t = e.length;
  if (t % 4 > 0)
    throw new Error("Invalid string. Length must be a multiple of 4");
  var n = e.indexOf("=");
  n === -1 && (n = t);
  var r = n === t ? 0 : 4 - n % 4;
  return [n, r];
}
function _u(e) {
  var t = Ea(e), n = t[0], r = t[1];
  return (n + r) * 3 / 4 - r;
}
function Ou(e, t, n) {
  return (t + n) * 3 / 4 - n;
}
function Ru(e) {
  var t, n = Ea(e), r = n[0], i = n[1], s = new Pu(Ou(e, r, i)), o = 0, a = i > 0 ? r - 4 : r, c;
  for (c = 0; c < a; c += 4)
    t = tt[e.charCodeAt(c)] << 18 | tt[e.charCodeAt(c + 1)] << 12 | tt[e.charCodeAt(c + 2)] << 6 | tt[e.charCodeAt(c + 3)], s[o++] = t >> 16 & 255, s[o++] = t >> 8 & 255, s[o++] = t & 255;
  return i === 2 && (t = tt[e.charCodeAt(c)] << 2 | tt[e.charCodeAt(c + 1)] >> 4, s[o++] = t & 255), i === 1 && (t = tt[e.charCodeAt(c)] << 10 | tt[e.charCodeAt(c + 1)] << 4 | tt[e.charCodeAt(c + 2)] >> 2, s[o++] = t >> 8 & 255, s[o++] = t & 255), s;
}
function ku(e) {
  return at[e >> 18 & 63] + at[e >> 12 & 63] + at[e >> 6 & 63] + at[e & 63];
}
function Mu(e, t, n) {
  for (var r, i = [], s = t; s < n; s += 3)
    r = (e[s] << 16 & 16711680) + (e[s + 1] << 8 & 65280) + (e[s + 2] & 255), i.push(ku(r));
  return i.join("");
}
function Iu(e) {
  for (var t, n = e.length, r = n % 3, i = [], s = 16383, o = 0, a = n - r; o < a; o += s)
    i.push(Mu(e, o, o + s > a ? a : o + s));
  return r === 1 ? (t = e[n - 1], i.push(
    at[t >> 2] + at[t << 4 & 63] + "=="
  )) : r === 2 && (t = (e[n - 2] << 8) + e[n - 1], i.push(
    at[t >> 10] + at[t >> 4 & 63] + at[t << 2 & 63] + "="
  )), i.join("");
}
Object.defineProperty(Se, "__esModule", { value: !0 });
Se.b64UrlDecode = Se.b64UrlEncode = Se.bufferTob64Url = Se.bufferTob64 = Se.b64UrlToBuffer = Se.stringToB64Url = Se.stringToBuffer = Se.bufferToString = Se.b64UrlToString = Se.concatBuffers = void 0;
const Sa = rr;
function Lu(e) {
  let t = 0;
  for (let i = 0; i < e.length; i++)
    t += e[i].byteLength;
  let n = new Uint8Array(t), r = 0;
  n.set(new Uint8Array(e[0]), r), r += e[0].byteLength;
  for (let i = 1; i < e.length; i++)
    n.set(new Uint8Array(e[i]), r), r += e[i].byteLength;
  return n;
}
Se.concatBuffers = Lu;
function Du(e) {
  let t = Ca(e);
  return xa(t);
}
Se.b64UrlToString = Du;
function xa(e) {
  return new TextDecoder("utf-8", { fatal: !0 }).decode(e);
}
Se.bufferToString = xa;
function Pa(e) {
  return new TextEncoder().encode(e);
}
Se.stringToBuffer = Pa;
function Vu(e) {
  return Oa(Pa(e));
}
Se.stringToB64Url = Vu;
function Ca(e) {
  return new Uint8Array(Sa.toByteArray(ka(e)));
}
Se.b64UrlToBuffer = Ca;
function _a(e) {
  return Sa.fromByteArray(new Uint8Array(e));
}
Se.bufferTob64 = _a;
function Oa(e) {
  return Ra(_a(e));
}
Se.bufferTob64Url = Oa;
function Ra(e) {
  return e.replace(/\+/g, "-").replace(/\//g, "_").replace(/\=/g, "");
}
Se.b64UrlEncode = Ra;
function ka(e) {
  e = e.replace(/\-/g, "+").replace(/\_/g, "/");
  let t;
  return e.length % 4 == 0 ? t = 0 : t = 4 - e.length % 4, e.concat("=".repeat(t));
}
Se.b64UrlDecode = ka;
Object.defineProperty(ki, "__esModule", { value: !0 });
const pt = Se;
class Nu {
  constructor() {
    q(this, "keyLength", 4096);
    q(this, "publicExponent", 65537);
    q(this, "hashAlgorithm", "sha256");
    q(this, "driver");
    if (!this.detectWebCrypto())
      throw new Error("SubtleCrypto not available!");
    this.driver = crypto.subtle;
  }
  async generateJWK() {
    let t = await this.driver.generateKey({
      name: "RSA-PSS",
      modulusLength: 4096,
      publicExponent: new Uint8Array([1, 0, 1]),
      hash: {
        name: "SHA-256"
      }
    }, !0, ["sign"]), n = await this.driver.exportKey("jwk", t.privateKey);
    return {
      kty: n.kty,
      e: n.e,
      n: n.n,
      d: n.d,
      p: n.p,
      q: n.q,
      dp: n.dp,
      dq: n.dq,
      qi: n.qi
    };
  }
  async sign(t, n, { saltLength: r } = {}) {
    let i = await this.driver.sign({
      name: "RSA-PSS",
      saltLength: 32
    }, await this.jwkToCryptoKey(t), n);
    return new Uint8Array(i);
  }
  async hash(t, n = "SHA-256") {
    let r = await this.driver.digest(n, t);
    return new Uint8Array(r);
  }
  async verify(t, n, r) {
    const i = {
      kty: "RSA",
      e: "AQAB",
      n: t
    }, s = await this.jwkToPublicCryptoKey(i), o = await this.driver.digest("SHA-256", n), a = await this.driver.verify({
      name: "RSA-PSS",
      saltLength: 0
    }, s, r, n), c = await this.driver.verify({
      name: "RSA-PSS",
      saltLength: 32
    }, s, r, n), l = await this.driver.verify({
      name: "RSA-PSS",
      saltLength: Math.ceil((s.algorithm.modulusLength - 1) / 8) - o.byteLength - 2
    }, s, r, n);
    return a || c || l;
  }
  async jwkToCryptoKey(t) {
    return this.driver.importKey("jwk", t, {
      name: "RSA-PSS",
      hash: {
        name: "SHA-256"
      }
    }, !1, ["sign"]);
  }
  async jwkToPublicCryptoKey(t) {
    return this.driver.importKey("jwk", t, {
      name: "RSA-PSS",
      hash: {
        name: "SHA-256"
      }
    }, !1, ["verify"]);
  }
  detectWebCrypto() {
    if (typeof crypto > "u")
      return !1;
    const t = crypto == null ? void 0 : crypto.subtle;
    return t === void 0 ? !1 : [
      "generateKey",
      "importKey",
      "exportKey",
      "digest",
      "sign"
    ].every((r) => typeof t[r] == "function");
  }
  async encrypt(t, n, r) {
    const i = await this.driver.importKey("raw", typeof n == "string" ? pt.stringToBuffer(n) : n, {
      name: "PBKDF2",
      length: 32
    }, !1, ["deriveKey"]), s = await this.driver.deriveKey({
      name: "PBKDF2",
      salt: r ? pt.stringToBuffer(r) : pt.stringToBuffer("salt"),
      iterations: 1e5,
      hash: "SHA-256"
    }, i, {
      name: "AES-CBC",
      length: 256
    }, !1, ["encrypt", "decrypt"]), o = new Uint8Array(16);
    crypto.getRandomValues(o);
    const a = await this.driver.encrypt({
      name: "AES-CBC",
      iv: o
    }, s, t);
    return pt.concatBuffers([o, a]);
  }
  async decrypt(t, n, r) {
    const i = await this.driver.importKey("raw", typeof n == "string" ? pt.stringToBuffer(n) : n, {
      name: "PBKDF2",
      length: 32
    }, !1, ["deriveKey"]), s = await this.driver.deriveKey({
      name: "PBKDF2",
      salt: r ? pt.stringToBuffer(r) : pt.stringToBuffer("salt"),
      iterations: 1e5,
      hash: "SHA-256"
    }, i, {
      name: "AES-CBC",
      length: 256
    }, !1, ["encrypt", "decrypt"]), o = t.slice(0, 16), a = await this.driver.decrypt({
      name: "AES-CBC",
      iv: o
    }, s, t.slice(16));
    return pt.concatBuffers([a]);
  }
}
ki.default = Nu;
var Mi = {};
Object.defineProperty(Mi, "__esModule", { value: !0 });
class Bu {
  constructor(t) {
    q(this, "api");
    this.api = t;
  }
  getInfo() {
    return this.api.get("info").then((t) => t.data);
  }
  getPeers() {
    return this.api.get("peers").then((t) => t.data);
  }
}
Mi.default = Bu;
var _n = {}, bt = {};
Object.defineProperty(bt, "__esModule", { value: !0 });
bt.getError = void 0;
class ju extends Error {
  constructor(n, r = {}) {
    var t = (...args) => {
      super(...args);
      q(this, "type");
      q(this, "response");
    };
    r.message ? t(r.message) : t(), this.type = n, this.response = r.response;
  }
  getType() {
    return this.type;
  }
}
bt.default = ju;
function $u(e) {
  let t = e.data;
  if (typeof e.data == "string")
    try {
      t = JSON.parse(e.data);
    } catch {
    }
  if (e.data instanceof ArrayBuffer || e.data instanceof Uint8Array)
    try {
      t = JSON.parse(t.toString());
    } catch {
    }
  return t ? t.error || t : e.statusText || "unknown";
}
bt.getError = $u;
var Vt = {}, On = {}, Vo;
function Fu() {
  if (Vo)
    return On;
  Vo = 1, Object.defineProperty(On, "__esModule", { value: !0 });
  const e = Fn();
  async function t(r) {
    if (Array.isArray(r)) {
      const o = e.default.utils.concatBuffers([
        e.default.utils.stringToBuffer("list"),
        e.default.utils.stringToBuffer(r.length.toString())
      ]);
      return await n(r, await e.default.crypto.hash(o, "SHA-384"));
    }
    const i = e.default.utils.concatBuffers([
      e.default.utils.stringToBuffer("blob"),
      e.default.utils.stringToBuffer(r.byteLength.toString())
    ]), s = e.default.utils.concatBuffers([
      await e.default.crypto.hash(i, "SHA-384"),
      await e.default.crypto.hash(r, "SHA-384")
    ]);
    return await e.default.crypto.hash(s, "SHA-384");
  }
  On.default = t;
  async function n(r, i) {
    if (r.length < 1)
      return i;
    const s = e.default.utils.concatBuffers([
      i,
      await t(r[0])
    ]), o = await e.default.crypto.hash(s, "SHA-384");
    return await n(r.slice(1), o);
  }
  return On;
}
var Er = {}, No;
function Ma() {
  return No || (No = 1, function(e) {
    Object.defineProperty(e, "__esModule", { value: !0 }), e.debug = e.validatePath = e.arrayCompare = e.bufferToInt = e.intToBuffer = e.arrayFlatten = e.generateProofs = e.buildLayers = e.generateTransactionChunks = e.generateTree = e.computeRootHash = e.generateLeaves = e.chunkData = e.MIN_CHUNK_SIZE = e.MAX_CHUNK_SIZE = void 0;
    const t = Fn(), n = Se;
    e.MAX_CHUNK_SIZE = 256 * 1024, e.MIN_CHUNK_SIZE = 32 * 1024;
    const r = 32, i = 32;
    async function s(T) {
      let _ = [], V = T, F = 0;
      for (; V.byteLength >= e.MAX_CHUNK_SIZE; ) {
        let W = e.MAX_CHUNK_SIZE, N = V.byteLength - e.MAX_CHUNK_SIZE;
        N > 0 && N < e.MIN_CHUNK_SIZE && (W = Math.ceil(V.byteLength / 2));
        const G = V.slice(0, W), ne = await t.default.crypto.hash(G);
        F += G.byteLength, _.push({
          dataHash: ne,
          minByteRange: F - G.byteLength,
          maxByteRange: F
        }), V = V.slice(W);
      }
      return _.push({
        dataHash: await t.default.crypto.hash(V),
        minByteRange: F,
        maxByteRange: F + V.byteLength
      }), _;
    }
    e.chunkData = s;
    async function o(T) {
      return Promise.all(T.map(async ({ dataHash: _, minByteRange: V, maxByteRange: F }) => ({
        type: "leaf",
        id: await w(await Promise.all([w(_), w(I(F))])),
        dataHash: _,
        minByteRange: V,
        maxByteRange: F
      })));
    }
    e.generateLeaves = o;
    async function a(T) {
      return (await c(T)).id;
    }
    e.computeRootHash = a;
    async function c(T) {
      return await u(await o(await s(T)));
    }
    e.generateTree = c;
    async function l(T) {
      const _ = await s(T), V = await o(_), F = await u(V), W = await d(F), N = _.slice(-1)[0];
      return N.maxByteRange - N.minByteRange === 0 && (_.splice(_.length - 1, 1), W.splice(W.length - 1, 1)), {
        data_root: F.id,
        chunks: _,
        proofs: W
      };
    }
    e.generateTransactionChunks = l;
    async function u(T, _ = 0) {
      if (T.length < 2)
        return T[0];
      const V = [];
      for (let F = 0; F < T.length; F += 2)
        V.push(await v(T[F], T[F + 1]));
      return u(V, _ + 1);
    }
    e.buildLayers = u;
    function d(T) {
      const _ = h(T);
      return Array.isArray(_) ? m(_) : [_];
    }
    e.generateProofs = d;
    function h(T, _ = new Uint8Array(), V = 0) {
      if (T.type == "leaf")
        return {
          offset: T.maxByteRange - 1,
          proof: (0, n.concatBuffers)([
            _,
            T.dataHash,
            I(T.maxByteRange)
          ])
        };
      if (T.type == "branch") {
        const F = (0, n.concatBuffers)([
          _,
          T.leftChild.id,
          T.rightChild.id,
          I(T.byteRange)
        ]);
        return [
          h(T.leftChild, F, V + 1),
          h(T.rightChild, F, V + 1)
        ];
      }
      throw new Error("Unexpected node type");
    }
    function m(T) {
      const _ = [];
      return T.forEach((V) => {
        Array.isArray(V) ? _.push(...m(V)) : _.push(V);
      }), _;
    }
    e.arrayFlatten = m;
    async function v(T, _) {
      return _ ? {
        type: "branch",
        id: await w([
          await w(T.id),
          await w(_.id),
          await w(I(T.maxByteRange))
        ]),
        byteRange: T.maxByteRange,
        maxByteRange: _.maxByteRange,
        leftChild: T,
        rightChild: _
      } : T;
    }
    async function w(T) {
      return Array.isArray(T) && (T = t.default.utils.concatBuffers(T)), new Uint8Array(await t.default.crypto.hash(T));
    }
    function I(T) {
      const _ = new Uint8Array(r);
      for (var V = _.length - 1; V >= 0; V--) {
        var F = T % 256;
        _[V] = F, T = (T - F) / 256;
      }
      return _;
    }
    e.intToBuffer = I;
    function E(T) {
      let _ = 0;
      for (var V = 0; V < T.length; V++)
        _ *= 256, _ += T[V];
      return _;
    }
    e.bufferToInt = E;
    const P = (T, _) => T.every((V, F) => _[F] === V);
    e.arrayCompare = P;
    async function M(T, _, V, F, W) {
      if (F <= 0)
        return !1;
      if (_ >= F)
        return M(T, 0, F - 1, F, W);
      if (_ < 0)
        return M(T, 0, 0, F, W);
      if (W.length == i + r) {
        const ge = W.slice(0, i), de = W.slice(ge.length, ge.length + r), Le = await w([
          await w(ge),
          await w(de)
        ]);
        return (0, e.arrayCompare)(T, Le) ? {
          offset: F - 1,
          leftBound: V,
          rightBound: F,
          chunkSize: F - V
        } : !1;
      }
      const N = W.slice(0, i), G = W.slice(N.length, N.length + i), ne = W.slice(N.length + G.length, N.length + G.length + r), J = E(ne), ue = W.slice(N.length + G.length + ne.length), Q = await w([
        await w(N),
        await w(G),
        await w(ne)
      ]);
      return (0, e.arrayCompare)(T, Q) ? _ < J ? await M(N, _, V, Math.min(F, J), ue) : await M(G, _, Math.max(V, J), F, ue) : !1;
    }
    e.validatePath = M;
    async function L(T, _ = "") {
      if (T.byteLength < 1)
        return _;
      const V = T.slice(0, i), F = T.slice(V.length, V.length + i), W = T.slice(V.length + F.length, V.length + F.length + r), N = E(W), G = T.slice(V.length + F.length + W.length), ne = await w([
        await w(V),
        await w(F),
        await w(W)
      ]), J = `${_}
${JSON.stringify(Buffer.from(V))},${JSON.stringify(Buffer.from(F))},${N} => ${JSON.stringify(ne)}`;
      return L(G, J);
    }
    e.debug = L;
  }(Er)), Er;
}
var Bo;
function Ii() {
  if (Bo)
    return Vt;
  Bo = 1, Object.defineProperty(Vt, "__esModule", { value: !0 }), Vt.Tag = void 0;
  const e = Se, t = Fu(), n = Ma();
  class r {
    get(a, c) {
      if (!Object.getOwnPropertyNames(this).includes(a))
        throw new Error(`Field "${a}" is not a property of the Arweave Transaction class.`);
      if (this[a] instanceof Uint8Array)
        return c && c.decode && c.string ? e.bufferToString(this[a]) : c && c.decode && !c.string ? this[a] : e.bufferTob64Url(this[a]);
      if (this[a] instanceof Array) {
        if ((c == null ? void 0 : c.decode) !== void 0 || (c == null ? void 0 : c.string) !== void 0)
          throw a === "tags" && console.warn(`Did you mean to use 'transaction["tags"]' ?`), new Error("Cannot decode or stringify an array.");
        return this[a];
      }
      return c && c.decode == !0 ? c && c.string ? e.b64UrlToString(this[a]) : e.b64UrlToBuffer(this[a]) : this[a];
    }
  }
  class i extends r {
    constructor(c, l, u = !1) {
      super();
      q(this, "name");
      q(this, "value");
      this.name = c, this.value = l;
    }
  }
  Vt.Tag = i;
  class s extends r {
    constructor(c = {}) {
      super();
      q(this, "format", 2);
      q(this, "id", "");
      q(this, "last_tx", "");
      q(this, "owner", "");
      q(this, "tags", []);
      q(this, "target", "");
      q(this, "quantity", "0");
      q(this, "data_size", "0");
      q(this, "data", new Uint8Array());
      q(this, "data_root", "");
      q(this, "reward", "0");
      q(this, "signature", "");
      // Computed when needed.
      q(this, "chunks");
      Object.assign(this, c), typeof this.data == "string" && (this.data = e.b64UrlToBuffer(this.data)), c.tags && (this.tags = c.tags.map((l) => new i(l.name, l.value)));
    }
    addTag(c, l) {
      this.tags.push(new i(e.stringToB64Url(c), e.stringToB64Url(l)));
    }
    toJSON() {
      return {
        format: this.format,
        id: this.id,
        last_tx: this.last_tx,
        owner: this.owner,
        tags: this.tags,
        target: this.target,
        quantity: this.quantity,
        data: e.bufferTob64Url(this.data),
        data_size: this.data_size,
        data_root: this.data_root,
        data_tree: this.data_tree,
        reward: this.reward,
        signature: this.signature
      };
    }
    setOwner(c) {
      this.owner = c;
    }
    setSignature({ id: c, owner: l, reward: u, tags: d, signature: h }) {
      this.id = c, this.owner = l, u && (this.reward = u), d && (this.tags = d), this.signature = h;
    }
    async prepareChunks(c) {
      !this.chunks && c.byteLength > 0 && (this.chunks = await (0, n.generateTransactionChunks)(c), this.data_root = e.bufferTob64Url(this.chunks.data_root)), !this.chunks && c.byteLength === 0 && (this.chunks = {
        chunks: [],
        data_root: new Uint8Array(),
        proofs: []
      }, this.data_root = "");
    }
    // Returns a chunk in a format suitable for posting to /chunk.
    // Similar to `prepareChunks()` this does not operate `this.data`,
    // instead using the data passed in.
    getChunk(c, l) {
      if (!this.chunks)
        throw new Error("Chunks have not been prepared");
      const u = this.chunks.proofs[c], d = this.chunks.chunks[c];
      return {
        data_root: this.data_root,
        data_size: this.data_size,
        data_path: e.bufferTob64Url(u.proof),
        offset: u.offset.toString(),
        chunk: e.bufferTob64Url(l.slice(d.minByteRange, d.maxByteRange))
      };
    }
    async getSignatureData() {
      switch (this.format) {
        case 1:
          let c = this.tags.reduce((u, d) => e.concatBuffers([
            u,
            d.get("name", { decode: !0, string: !1 }),
            d.get("value", { decode: !0, string: !1 })
          ]), new Uint8Array());
          return e.concatBuffers([
            this.get("owner", { decode: !0, string: !1 }),
            this.get("target", { decode: !0, string: !1 }),
            this.get("data", { decode: !0, string: !1 }),
            e.stringToBuffer(this.quantity),
            e.stringToBuffer(this.reward),
            this.get("last_tx", { decode: !0, string: !1 }),
            c
          ]);
        case 2:
          this.data_root || await this.prepareChunks(this.data);
          const l = this.tags.map((u) => [
            u.get("name", { decode: !0, string: !1 }),
            u.get("value", { decode: !0, string: !1 })
          ]);
          return await (0, t.default)([
            e.stringToBuffer(this.format.toString()),
            this.get("owner", { decode: !0, string: !1 }),
            this.get("target", { decode: !0, string: !1 }),
            e.stringToBuffer(this.quantity),
            e.stringToBuffer(this.reward),
            this.get("last_tx", { decode: !0, string: !1 }),
            l,
            e.stringToBuffer(this.data_size),
            this.get("data_root", { decode: !0, string: !1 })
          ]);
        default:
          throw new Error(`Unexpected transaction format: ${this.format}`);
      }
    }
  }
  return Vt.default = s, Vt;
}
var en = {}, jo;
function Uu() {
  if (jo)
    return en;
  jo = 1, Object.defineProperty(en, "__esModule", { value: !0 }), en.TransactionUploader = void 0;
  const e = Ii(), t = Se, n = bt, r = Ma(), i = 1, s = [
    "invalid_json",
    "chunk_too_big",
    "data_path_too_big",
    "offset_too_big",
    "data_size_too_big",
    "chunk_proof_ratio_not_attractive",
    "invalid_proof"
  ], o = 1e3 * 40;
  class a {
    constructor(l, u) {
      q(this, "api");
      q(this, "chunkIndex", 0);
      q(this, "txPosted", !1);
      q(this, "transaction");
      q(this, "lastRequestTimeEnd", 0);
      q(this, "totalErrors", 0);
      // Not serialized.
      q(this, "data");
      q(this, "lastResponseStatus", 0);
      q(this, "lastResponseError", "");
      if (this.api = l, !u.id)
        throw new Error("Transaction is not signed");
      if (!u.chunks)
        throw new Error("Transaction chunks not prepared");
      this.data = u.data, this.transaction = new e.default(Object.assign({}, u, { data: new Uint8Array(0) }));
    }
    get isComplete() {
      return this.txPosted && this.chunkIndex === this.transaction.chunks.chunks.length;
    }
    get totalChunks() {
      return this.transaction.chunks.chunks.length;
    }
    get uploadedChunks() {
      return this.chunkIndex;
    }
    get pctComplete() {
      return Math.trunc(this.uploadedChunks / this.totalChunks * 100);
    }
    /**
     * Uploads the next part of the transaction.
     * On the first call this posts the transaction
     * itself and on any subsequent calls uploads the
     * next chunk until it completes.
     */
    async uploadChunk(l) {
      if (this.isComplete)
        throw new Error("Upload is already complete");
      if (this.lastResponseError !== "" ? this.totalErrors++ : this.totalErrors = 0, this.totalErrors === 100)
        throw new Error(`Unable to complete upload: ${this.lastResponseStatus}: ${this.lastResponseError}`);
      let u = this.lastResponseError === "" ? 0 : Math.max(this.lastRequestTimeEnd + o - Date.now(), o);
      if (u > 0 && (u = u - u * Math.random() * 0.3, await new Promise((v) => setTimeout(v, u))), this.lastResponseError = "", !this.txPosted) {
        await this.postTransaction();
        return;
      }
      l && (this.chunkIndex = l);
      const d = this.transaction.getChunk(l || this.chunkIndex, this.data);
      if (!await (0, r.validatePath)(this.transaction.chunks.data_root, parseInt(d.offset), 0, parseInt(d.data_size), t.b64UrlToBuffer(d.data_path)))
        throw new Error(`Unable to validate chunk ${this.chunkIndex}`);
      const m = await this.api.post("chunk", this.transaction.getChunk(this.chunkIndex, this.data)).catch((v) => (console.error(v.message), { status: -1, data: { error: v.message } }));
      if (this.lastRequestTimeEnd = Date.now(), this.lastResponseStatus = m.status, this.lastResponseStatus == 200)
        this.chunkIndex++;
      else if (this.lastResponseError = (0, n.getError)(m), s.includes(this.lastResponseError))
        throw new Error(`Fatal error uploading chunk ${this.chunkIndex}: ${this.lastResponseError}`);
    }
    /**
     * Reconstructs an upload from its serialized state and data.
     * Checks if data matches the expected data_root.
     *
     * @param serialized
     * @param data
     */
    static async fromSerialized(l, u, d) {
      if (!u || typeof u.chunkIndex != "number" || typeof u.transaction != "object")
        throw new Error("Serialized object does not match expected format.");
      var h = new e.default(u.transaction);
      h.chunks || await h.prepareChunks(d);
      const m = new a(l, h);
      if (m.chunkIndex = u.chunkIndex, m.lastRequestTimeEnd = u.lastRequestTimeEnd, m.lastResponseError = u.lastResponseError, m.lastResponseStatus = u.lastResponseStatus, m.txPosted = u.txPosted, m.data = d, m.transaction.data_root !== u.transaction.data_root)
        throw new Error("Data mismatch: Uploader doesn't match provided data.");
      return m;
    }
    /**
     * Reconstruct an upload from the tx metadata, ie /tx/<id>.
     *
     * @param api
     * @param id
     * @param data
     */
    static async fromTransactionId(l, u) {
      const d = await l.get(`tx/${u}`);
      if (d.status !== 200)
        throw new Error(`Tx ${u} not found: ${d.status}`);
      const h = d.data;
      return h.data = new Uint8Array(0), {
        txPosted: !0,
        chunkIndex: 0,
        lastResponseError: "",
        lastRequestTimeEnd: 0,
        lastResponseStatus: 0,
        transaction: h
      };
    }
    toJSON() {
      return {
        chunkIndex: this.chunkIndex,
        transaction: this.transaction,
        lastRequestTimeEnd: this.lastRequestTimeEnd,
        lastResponseStatus: this.lastResponseStatus,
        lastResponseError: this.lastResponseError,
        txPosted: this.txPosted
      };
    }
    // POST to /tx
    async postTransaction() {
      if (this.totalChunks <= i) {
        this.transaction.data = this.data;
        const d = await this.api.post("tx", this.transaction).catch((h) => (console.error(h), { status: -1, data: { error: h.message } }));
        if (this.lastRequestTimeEnd = Date.now(), this.lastResponseStatus = d.status, this.transaction.data = new Uint8Array(0), d.status >= 200 && d.status < 300) {
          this.txPosted = !0, this.chunkIndex = i;
          return;
        }
        throw this.lastResponseError = (0, n.getError)(d), new Error(`Unable to upload transaction: ${d.status}, ${this.lastResponseError}`);
      }
      const u = await this.api.post("tx", this.transaction);
      if (this.lastRequestTimeEnd = Date.now(), this.lastResponseStatus = u.status, !(u.status >= 200 && u.status < 300))
        throw this.lastResponseError = (0, n.getError)(u), new Error(`Unable to upload transaction: ${u.status}, ${this.lastResponseError}`);
      this.txPosted = !0;
    }
  }
  return en.TransactionUploader = a, en;
}
var $o;
function Hu() {
  if ($o)
    return _n;
  $o = 1, Object.defineProperty(_n, "__esModule", { value: !0 });
  const e = bt, t = Ii(), n = Se, r = Uu();
  class i {
    constructor(o, a, c) {
      q(this, "api");
      q(this, "crypto");
      q(this, "chunks");
      this.api = o, this.crypto = a, this.chunks = c;
    }
    async getTransactionAnchor() {
      const o = await this.api.get("tx_anchor");
      if (!o.data.match(/^[a-z0-9_-]{43,}/i) || !o.ok)
        throw new Error(`Could not getTransactionAnchor. Received: ${o.data}. Status: ${o.status}, ${o.statusText}`);
      return o.data;
    }
    async getPrice(o, a) {
      let c = a ? `price/${o}/${a}` : `price/${o}`;
      const l = await this.api.get(c);
      if (!/^\d+$/.test(l.data) || !l.ok)
        throw new Error(`Could not getPrice. Received: ${l.data}. Status: ${l.status}, ${l.statusText}`);
      return l.data;
    }
    async get(o) {
      const a = await this.api.get(`tx/${o}`);
      if (a.status == 200) {
        const c = parseInt(a.data.data_size);
        if (a.data.format >= 2 && c > 0 && c <= 1024 * 1024 * 12) {
          const l = await this.getData(o);
          return new t.default({
            ...a.data,
            data: l
          });
        }
        return new t.default({
          ...a.data,
          format: a.data.format || 1
        });
      }
      throw a.status == 404 ? new e.default(
        "TX_NOT_FOUND"
        /* ArweaveErrorType.TX_NOT_FOUND */
      ) : a.status == 410 ? new e.default(
        "TX_FAILED"
        /* ArweaveErrorType.TX_FAILED */
      ) : new e.default(
        "TX_INVALID"
        /* ArweaveErrorType.TX_INVALID */
      );
    }
    fromRaw(o) {
      return new t.default(o);
    }
    async search(o, a) {
      return this.api.post("arql", {
        op: "equals",
        expr1: o,
        expr2: a
      }).then((c) => c.data ? c.data : []);
    }
    getStatus(o) {
      return this.api.get(`tx/${o}/status`).then((a) => a.status == 200 ? {
        status: 200,
        confirmed: a.data
      } : {
        status: a.status,
        confirmed: null
      });
    }
    async getData(o, a) {
      let c;
      try {
        c = await this.chunks.downloadChunkedData(o);
      } catch (l) {
        console.error(`Error while trying to download chunked data for ${o}`), console.error(l);
      }
      if (!c) {
        console.warn(`Falling back to gateway cache for ${o}`);
        try {
          const { data: l, ok: u, status: d, statusText: h } = await this.api.get(`/${o}`, { responseType: "arraybuffer" });
          if (!u)
            throw new Error("Bad http status code", {
              cause: { status: d, statusText: h }
            });
          c = l;
        } catch (l) {
          console.error(`Error while trying to download contiguous data from gateway cache for ${o}`), console.error(l);
        }
      }
      if (!c)
        throw new Error(`${o} data was not found!`);
      return a && a.decode && !a.string ? c : a && a.decode && a.string ? n.bufferToString(c) : n.bufferTob64Url(c);
    }
    async sign(o, a, c) {
      const u = typeof a == "object" && ((h) => {
        let m = !0;
        return ["n", "e", "d", "p", "q", "dp", "dq", "qi"].map((v) => !(v in h) && (m = !1)), m;
      })(a), d = typeof arweaveWallet == "object";
      if (!u && !d)
        throw new Error("No valid JWK or external wallet found to sign transaction.");
      if (u) {
        o.setOwner(a.n);
        let h = await o.getSignatureData(), m = await this.crypto.sign(a, h, c), v = await this.crypto.hash(m);
        o.setSignature({
          id: n.bufferTob64Url(v),
          owner: a.n,
          signature: n.bufferTob64Url(m)
        });
      } else if (d) {
        try {
          (await arweaveWallet.getPermissions()).includes("SIGN_TRANSACTION") || await arweaveWallet.connect(["SIGN_TRANSACTION"]);
        } catch {
        }
        const h = await arweaveWallet.sign(o, c);
        o.setSignature({
          id: h.id,
          owner: h.owner,
          reward: h.reward,
          tags: h.tags,
          signature: h.signature
        });
      } else
        throw new Error("An error occurred while signing. Check wallet is valid");
    }
    async verify(o) {
      const a = await o.getSignatureData(), c = o.get("signature", {
        decode: !0,
        string: !1
      }), l = n.bufferTob64Url(await this.crypto.hash(c));
      if (o.id !== l)
        throw new Error("Invalid transaction signature or ID! The transaction ID doesn't match the expected SHA-256 hash of the signature.");
      return this.crypto.verify(o.owner, a, c);
    }
    async post(o) {
      if (typeof o == "string" ? o = new t.default(JSON.parse(o)) : typeof o.readInt32BE == "function" ? o = new t.default(JSON.parse(o.toString())) : typeof o == "object" && !(o instanceof t.default) && (o = new t.default(o)), !(o instanceof t.default))
        throw new Error("Must be Transaction object");
      o.chunks || await o.prepareChunks(o.data);
      const a = await this.getUploader(o, o.data);
      try {
        for (; !a.isComplete; )
          await a.uploadChunk();
      } catch (c) {
        if (a.lastResponseStatus > 0)
          return {
            status: a.lastResponseStatus,
            statusText: a.lastResponseError,
            data: {
              error: a.lastResponseError
            }
          };
        throw c;
      }
      return {
        status: 200,
        statusText: "OK",
        data: {}
      };
    }
    /**
     * Gets an uploader than can be used to upload a transaction chunk by chunk, giving progress
     * and the ability to resume.
     *
     * Usage example:
     *
     * ```
     * const uploader = arweave.transactions.getUploader(transaction);
     * while (!uploader.isComplete) {
     *   await uploader.uploadChunk();
     *   console.log(`${uploader.pctComplete}%`);
     * }
     * ```
     *
     * @param upload a Transaction object, a previously save progress object, or a transaction id.
     * @param data the data of the transaction. Required when resuming an upload.
     */
    async getUploader(o, a) {
      let c;
      if (a instanceof ArrayBuffer && (a = new Uint8Array(a)), o instanceof t.default) {
        if (a || (a = o.data), !(a instanceof Uint8Array))
          throw new Error("Data format is invalid");
        o.chunks || await o.prepareChunks(a), c = new r.TransactionUploader(this.api, o), (!c.data || c.data.length === 0) && (c.data = a);
      } else {
        if (typeof o == "string" && (o = await r.TransactionUploader.fromTransactionId(this.api, o)), !a || !(a instanceof Uint8Array))
          throw new Error("Must provide data when resuming upload");
        c = await r.TransactionUploader.fromSerialized(this.api, o, a);
      }
      return c;
    }
    /**
     * Async generator version of uploader
     *
     * Usage example:
     *
     * ```
     * for await (const uploader of arweave.transactions.upload(tx)) {
     *  console.log(`${uploader.pctComplete}%`);
     * }
     * ```
     *
     * @param upload a Transaction object, a previously save uploader, or a transaction id.
     * @param data the data of the transaction. Required when resuming an upload.
     */
    async *upload(o, a) {
      const c = await this.getUploader(o, a);
      for (; !c.isComplete; )
        await c.uploadChunk(), yield c;
      return c;
    }
  }
  return _n.default = i, _n;
}
var Li = {};
Object.defineProperty(Li, "__esModule", { value: !0 });
const Fo = Se;
class Wu {
  constructor(t, n) {
    q(this, "api");
    q(this, "crypto");
    this.api = t, this.crypto = n;
  }
  /**
   * Get the wallet balance for the given address.
   *
   * @param {string} address - The arweave address to get the balance for.
   *
   * @returns {Promise<string>} - Promise which resolves with a winston string balance.
   */
  getBalance(t) {
    return this.api.get(`wallet/${t}/balance`).then((n) => n.data);
  }
  /**
   * Get the last transaction ID for the given wallet address.
   *
   * @param {string} address - The arweave address to get the transaction for.
   *
   * @returns {Promise<string>} - Promise which resolves with a transaction ID.
   */
  getLastTransactionID(t) {
    return this.api.get(`wallet/${t}/last_tx`).then((n) => n.data);
  }
  generate() {
    return this.crypto.generateJWK();
  }
  async jwkToAddress(t) {
    return !t || t === "use_wallet" ? this.getAddress() : this.getAddress(t);
  }
  async getAddress(t) {
    if (!t || t === "use_wallet") {
      try {
        await arweaveWallet.connect(["ACCESS_ADDRESS"]);
      } catch {
      }
      return arweaveWallet.getActiveAddress();
    } else
      return this.ownerToAddress(t.n);
  }
  async ownerToAddress(t) {
    return Fo.bufferTob64Url(await this.crypto.hash(Fo.b64UrlToBuffer(t)));
  }
}
Li.default = Wu;
var bn = {};
Object.defineProperty(bn, "__esModule", { value: !0 });
bn.SiloResource = void 0;
const Uo = Se;
class qu {
  constructor(t, n, r) {
    q(this, "api");
    q(this, "crypto");
    q(this, "transactions");
    this.api = t, this.crypto = n, this.transactions = r;
  }
  async get(t) {
    if (!t)
      throw new Error("No Silo URI specified");
    const n = await this.parseUri(t), r = await this.transactions.search("Silo-Name", n.getAccessKey());
    if (r.length == 0)
      throw new Error(`No data could be found for the Silo URI: ${t}`);
    const i = await this.transactions.get(r[0]);
    if (!i)
      throw new Error(`No data could be found for the Silo URI: ${t}`);
    const s = i.get("data", { decode: !0, string: !1 });
    return this.crypto.decrypt(s, n.getEncryptionKey());
  }
  async readTransactionData(t, n) {
    if (!n)
      throw new Error("No Silo URI specified");
    const r = await this.parseUri(n), i = t.get("data", { decode: !0, string: !1 });
    return this.crypto.decrypt(i, r.getEncryptionKey());
  }
  async parseUri(t) {
    const n = t.match(/^([a-z0-9-_]+)\.([0-9]+)/i);
    if (!n)
      throw new Error("Invalid Silo name, must be a name in the format of [a-z0-9]+.[0-9]+, e.g. 'bubble.7'");
    const r = n[1], i = Math.pow(2, parseInt(n[2])), s = await this.hash(Uo.stringToBuffer(r), i), o = Uo.bufferTob64(s.slice(0, 15)), a = await this.hash(s.slice(16, 31), 1);
    return new Ia(t, o, a);
  }
  async hash(t, n) {
    let r = await this.crypto.hash(t);
    for (let i = 0; i < n - 1; i++)
      r = await this.crypto.hash(r);
    return r;
  }
}
bn.default = qu;
class Ia {
  constructor(t, n, r) {
    q(this, "uri");
    q(this, "accessKey");
    q(this, "encryptionKey");
    this.uri = t, this.accessKey = n, this.encryptionKey = r;
  }
  getUri() {
    return this.uri;
  }
  getAccessKey() {
    return this.accessKey;
  }
  getEncryptionKey() {
    return this.encryptionKey;
  }
}
bn.SiloResource = Ia;
var Di = {};
Object.defineProperty(Di, "__esModule", { value: !0 });
const Ho = bt, zu = Se;
class Ku {
  constructor(t) {
    q(this, "api");
    this.api = t;
  }
  async getTransactionOffset(t) {
    const n = await this.api.get(`tx/${t}/offset`);
    if (n.status === 200)
      return n.data;
    throw new Error(`Unable to get transaction offset: ${(0, Ho.getError)(n)}`);
  }
  async getChunk(t) {
    const n = await this.api.get(`chunk/${t}`);
    if (n.status === 200)
      return n.data;
    throw new Error(`Unable to get chunk: ${(0, Ho.getError)(n)}`);
  }
  async getChunkData(t) {
    const n = await this.getChunk(t);
    return zu.b64UrlToBuffer(n.chunk);
  }
  firstChunkOffset(t) {
    return parseInt(t.offset) - parseInt(t.size) + 1;
  }
  async downloadChunkedData(t) {
    const n = await this.getTransactionOffset(t), r = parseInt(n.size), s = parseInt(n.offset) - r + 1, o = new Uint8Array(r);
    let a = 0;
    for (; a < r; ) {
      this.api.config.logging && console.log(`[chunk] ${a}/${r}`);
      let c;
      try {
        c = await this.getChunkData(s + a);
      } catch {
        console.error(`[chunk] Failed to fetch chunk at offset ${s + a}`), console.error("[chunk] This could indicate that the chunk wasn't uploaded or hasn't yet seeded properly to a particular gateway/node");
      }
      if (c)
        o.set(c, a), a += c.length;
      else
        throw new Error(`Couldn't complete data download at ${a}/${r}`);
    }
    return o;
  }
}
Di.default = Ku;
var Vi = {};
Object.defineProperty(Vi, "__esModule", { value: !0 });
const Wo = bt, Wt = class Wt {
  constructor(t, n) {
    q(this, "api");
    q(this, "network");
    this.api = t, this.network = n;
  }
  /**
   * Gets a block by its "indep_hash"
   */
  async get(t) {
    const n = await this.api.get(`${Wt.HASH_ENDPOINT}${t}`);
    if (n.status === 200)
      return n.data;
    throw n.status === 404 ? new Wo.default(
      "BLOCK_NOT_FOUND"
      /* ArweaveErrorType.BLOCK_NOT_FOUND */
    ) : new Error(`Error while loading block data: ${n}`);
  }
  /**
   * Gets a block by its "height"
   */
  async getByHeight(t) {
    const n = await this.api.get(`${Wt.HEIGHT_ENDPOINT}${t}`);
    if (n.status === 200)
      return n.data;
    throw n.status === 404 ? new Wo.default(
      "BLOCK_NOT_FOUND"
      /* ArweaveErrorType.BLOCK_NOT_FOUND */
    ) : new Error(`Error while loading block data: ${n}`);
  }
  /**
   * Gets current block data (ie. block with indep_hash = Network.getInfo().current)
   */
  async getCurrent() {
    const { current: t } = await this.network.getInfo();
    return await this.get(t);
  }
};
q(Wt, "HASH_ENDPOINT", "block/hash/"), q(Wt, "HEIGHT_ENDPOINT", "block/height/");
let Yr = Wt;
Vi.default = Yr;
var qo;
function Fn() {
  if (qo)
    return Cn;
  qo = 1, Object.defineProperty(Cn, "__esModule", { value: !0 });
  const e = Oi, t = Ri, n = ki, r = Mi, i = Hu(), s = Li, o = Ii(), a = Se, c = bn, l = Di, u = Vi, h = class h {
    constructor(v) {
      q(this, "api");
      q(this, "wallets");
      q(this, "transactions");
      q(this, "network");
      q(this, "blocks");
      q(this, "ar");
      q(this, "silo");
      q(this, "chunks");
      this.api = new t.default(v), this.wallets = new s.default(this.api, h.crypto), this.chunks = new l.default(this.api), this.transactions = new i.default(this.api, h.crypto, this.chunks), this.silo = new c.default(this.api, this.crypto, this.transactions), this.network = new r.default(this.api), this.blocks = new u.default(this.api, this.network), this.ar = new e.default();
    }
    /** @deprecated */
    get crypto() {
      return h.crypto;
    }
    /** @deprecated */
    get utils() {
      return h.utils;
    }
    getConfig() {
      return {
        api: this.api.getConfig(),
        crypto: null
      };
    }
    async createTransaction(v, w) {
      const I = {};
      if (Object.assign(I, v), !v.data && !(v.target && v.quantity))
        throw new Error("A new Arweave transaction must have a 'data' value, or 'target' and 'quantity' values.");
      if (v.owner == null && w && w !== "use_wallet" && (I.owner = w.n), v.last_tx == null && (I.last_tx = await this.transactions.getTransactionAnchor()), typeof v.data == "string" && (v.data = a.stringToBuffer(v.data)), v.data instanceof ArrayBuffer && (v.data = new Uint8Array(v.data)), v.data && !(v.data instanceof Uint8Array))
        throw new Error("Expected data to be a string, Uint8Array or ArrayBuffer");
      if (v.reward == null) {
        const P = v.data ? v.data.byteLength : 0;
        I.reward = await this.transactions.getPrice(P, I.target);
      }
      I.data_root = "", I.data_size = v.data ? v.data.byteLength.toString() : "0", I.data = v.data || new Uint8Array(0);
      const E = new o.default(I);
      return await E.getSignatureData(), E;
    }
    async createSiloTransaction(v, w, I) {
      const E = {};
      if (Object.assign(E, v), !v.data)
        throw new Error("Silo transactions must have a 'data' value");
      if (!I)
        throw new Error("No Silo URI specified.");
      if (v.target || v.quantity)
        throw new Error("Silo transactions can only be used for storing data, sending AR to other wallets isn't supported.");
      if (v.owner == null) {
        if (!w || !w.n)
          throw new Error("A new Arweave transaction must either have an 'owner' attribute, or you must provide the jwk parameter.");
        E.owner = w.n;
      }
      v.last_tx == null && (E.last_tx = await this.transactions.getTransactionAnchor());
      const P = await this.silo.parseUri(I);
      if (typeof v.data == "string") {
        const L = await this.crypto.encrypt(a.stringToBuffer(v.data), P.getEncryptionKey());
        E.reward = await this.transactions.getPrice(L.byteLength), E.data = a.bufferTob64Url(L);
      }
      if (v.data instanceof Uint8Array) {
        const L = await this.crypto.encrypt(v.data, P.getEncryptionKey());
        E.reward = await this.transactions.getPrice(L.byteLength), E.data = a.bufferTob64Url(L);
      }
      const M = new o.default(E);
      return M.addTag("Silo-Name", P.getAccessKey()), M.addTag("Silo-Version", "0.1.0"), M;
    }
    arql(v) {
      return this.api.post("/arql", v).then((w) => w.data || []);
    }
  };
  q(h, "init"), q(h, "crypto", new n.default()), q(h, "utils", a);
  let d = h;
  return Cn.default = d, Cn;
}
var ir = {};
Object.defineProperty(ir, "__esModule", { value: !0 });
ir.getDefaultConfig = void 0;
const Yu = (e, t) => {
  const n = /^127(?:\.(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)){3}$/, r = t.split("."), i = r[r.length - 1], s = ["localhost", "[::1]"];
  return s.includes(t) || e == "file" || s.includes(i) || !!t.match(n) || !!i.match(n);
}, Gu = (e) => {
  const t = e.charAt(0) === "[", n = /^(([0-9]|[1-9][0-9]|1[0-9]{2}|2[0-4][0-9]|25[0-5])\.){3}([0-9]|[1-9][0-9]|1[0-9]{2}|2[0-4][0-9]|25[0-5])$/;
  return !!e.match(n) || t;
}, Xu = (e, t) => {
  if (Yu(e, t))
    return {
      protocol: "https",
      host: "arweave.net",
      port: 443
    };
  if (!Gu(t)) {
    let n = t.split(".");
    if (n.length >= 3) {
      n.shift();
      const r = n.join(".");
      return {
        protocol: e,
        host: r
      };
    }
  }
  return {
    protocol: e,
    host: t
  };
};
ir.getDefaultConfig = Xu;
(function(e) {
  var t = $t && $t.__createBinding || (Object.create ? function(s, o, a, c) {
    c === void 0 && (c = a);
    var l = Object.getOwnPropertyDescriptor(o, a);
    (!l || ("get" in l ? !o.__esModule : l.writable || l.configurable)) && (l = { enumerable: !0, get: function() {
      return o[a];
    } }), Object.defineProperty(s, c, l);
  } : function(s, o, a, c) {
    c === void 0 && (c = a), s[c] = o[a];
  }), n = $t && $t.__exportStar || function(s, o) {
    for (var a in s)
      a !== "default" && !Object.prototype.hasOwnProperty.call(o, a) && t(o, s, a);
  };
  Object.defineProperty(e, "__esModule", { value: !0 });
  const r = Fn(), i = ir;
  r.default.init = function(s = {}) {
    const o = {
      host: "arweave.net",
      port: 443,
      protocol: "https"
    };
    if (typeof location != "object" || !location.protocol || !location.hostname)
      return new r.default({
        ...s,
        ...o
      });
    const a = location.protocol.replace(":", ""), c = location.hostname, l = location.port ? parseInt(location.port) : a == "https" ? 443 : 80, u = (0, i.getDefaultConfig)(a, c), d = s.protocol || u.protocol, h = s.host || u.host, m = s.port || u.port || l;
    return new r.default({
      ...s,
      host: h,
      protocol: d,
      port: m
    });
  }, typeof globalThis == "object" ? globalThis.Arweave = r.default : typeof self == "object" && (self.Arweave = r.default), n(Fn(), e), e.default = r.default;
})(ba);
const Zu = /* @__PURE__ */ Tn(ba);
function La() {
  var r;
  const [e, t] = He(0), { state: n } = We();
  return Te(() => {
    (async () => {
      var o;
      if (!n.activeAddress)
        return;
      const i = new Zu(
        ((o = n == null ? void 0 : n.config) == null ? void 0 : o.gatewayConfig) || {
          host: "arweave.net",
          port: 443,
          protocol: "https"
        }
      ), s = i.ar.winstonToAr(
        await i.wallets.getBalance(n.activeAddress)
      );
      t(Number(s));
    })();
  }, [n == null ? void 0 : n.activeAddress, (r = n == null ? void 0 : n.config) == null ? void 0 : r.gatewayConfig]), e;
}
function Ju(e) {
  var t = /* @__PURE__ */ Object.create(null);
  return function(n) {
    return t[n] === void 0 && (t[n] = e(n)), t[n];
  };
}
var Qu = /^((children|dangerouslySetInnerHTML|key|ref|autoFocus|defaultValue|defaultChecked|innerHTML|suppressContentEditableWarning|suppressHydrationWarning|valueLink|abbr|accept|acceptCharset|accessKey|action|allow|allowUserMedia|allowPaymentRequest|allowFullScreen|allowTransparency|alt|async|autoComplete|autoPlay|capture|cellPadding|cellSpacing|challenge|charSet|checked|cite|classID|className|cols|colSpan|content|contentEditable|contextMenu|controls|controlsList|coords|crossOrigin|data|dateTime|decoding|default|defer|dir|disabled|disablePictureInPicture|download|draggable|encType|enterKeyHint|form|formAction|formEncType|formMethod|formNoValidate|formTarget|frameBorder|headers|height|hidden|high|href|hrefLang|htmlFor|httpEquiv|id|inputMode|integrity|is|keyParams|keyType|kind|label|lang|list|loading|loop|low|marginHeight|marginWidth|max|maxLength|media|mediaGroup|method|min|minLength|multiple|muted|name|nonce|noValidate|open|optimum|pattern|placeholder|playsInline|poster|preload|profile|radioGroup|readOnly|referrerPolicy|rel|required|reversed|role|rows|rowSpan|sandbox|scope|scoped|scrolling|seamless|selected|shape|size|sizes|slot|span|spellCheck|src|srcDoc|srcLang|srcSet|start|step|style|summary|tabIndex|target|title|translate|type|useMap|value|width|wmode|wrap|about|datatype|inlist|prefix|property|resource|typeof|vocab|autoCapitalize|autoCorrect|autoSave|color|incremental|fallback|inert|itemProp|itemScope|itemType|itemID|itemRef|on|option|results|security|unselectable|accentHeight|accumulate|additive|alignmentBaseline|allowReorder|alphabetic|amplitude|arabicForm|ascent|attributeName|attributeType|autoReverse|azimuth|baseFrequency|baselineShift|baseProfile|bbox|begin|bias|by|calcMode|capHeight|clip|clipPathUnits|clipPath|clipRule|colorInterpolation|colorInterpolationFilters|colorProfile|colorRendering|contentScriptType|contentStyleType|cursor|cx|cy|d|decelerate|descent|diffuseConstant|direction|display|divisor|dominantBaseline|dur|dx|dy|edgeMode|elevation|enableBackground|end|exponent|externalResourcesRequired|fill|fillOpacity|fillRule|filter|filterRes|filterUnits|floodColor|floodOpacity|focusable|fontFamily|fontSize|fontSizeAdjust|fontStretch|fontStyle|fontVariant|fontWeight|format|from|fr|fx|fy|g1|g2|glyphName|glyphOrientationHorizontal|glyphOrientationVertical|glyphRef|gradientTransform|gradientUnits|hanging|horizAdvX|horizOriginX|ideographic|imageRendering|in|in2|intercept|k|k1|k2|k3|k4|kernelMatrix|kernelUnitLength|kerning|keyPoints|keySplines|keyTimes|lengthAdjust|letterSpacing|lightingColor|limitingConeAngle|local|markerEnd|markerMid|markerStart|markerHeight|markerUnits|markerWidth|mask|maskContentUnits|maskUnits|mathematical|mode|numOctaves|offset|opacity|operator|order|orient|orientation|origin|overflow|overlinePosition|overlineThickness|panose1|paintOrder|pathLength|patternContentUnits|patternTransform|patternUnits|pointerEvents|points|pointsAtX|pointsAtY|pointsAtZ|preserveAlpha|preserveAspectRatio|primitiveUnits|r|radius|refX|refY|renderingIntent|repeatCount|repeatDur|requiredExtensions|requiredFeatures|restart|result|rotate|rx|ry|scale|seed|shapeRendering|slope|spacing|specularConstant|specularExponent|speed|spreadMethod|startOffset|stdDeviation|stemh|stemv|stitchTiles|stopColor|stopOpacity|strikethroughPosition|strikethroughThickness|string|stroke|strokeDasharray|strokeDashoffset|strokeLinecap|strokeLinejoin|strokeMiterlimit|strokeOpacity|strokeWidth|surfaceScale|systemLanguage|tableValues|targetX|targetY|textAnchor|textDecoration|textRendering|textLength|to|transform|u1|u2|underlinePosition|underlineThickness|unicode|unicodeBidi|unicodeRange|unitsPerEm|vAlphabetic|vHanging|vIdeographic|vMathematical|values|vectorEffect|version|vertAdvY|vertOriginX|vertOriginY|viewBox|viewTarget|visibility|widths|wordSpacing|writingMode|x|xHeight|x1|x2|xChannelSelector|xlinkActuate|xlinkArcrole|xlinkHref|xlinkRole|xlinkShow|xlinkTitle|xlinkType|xmlBase|xmlns|xmlnsXlink|xmlLang|xmlSpace|y|y1|y2|yChannelSelector|z|zoomAndPan|for|class|autofocus)|(([Dd][Aa][Tt][Aa]|[Aa][Rr][Ii][Aa]|x)-.*))$/, Sr = /* @__PURE__ */ Ju(
  function(e) {
    return Qu.test(e) || e.charCodeAt(0) === 111 && e.charCodeAt(1) === 110 && e.charCodeAt(2) < 91;
  }
  /* Z+1 */
), ef = function() {
  const t = Array.prototype.slice.call(arguments).filter(Boolean), n = {}, r = [];
  t.forEach((s) => {
    (s ? s.split(" ") : []).forEach((a) => {
      if (a.startsWith("atm_")) {
        const [, c] = a.split("_");
        n[c] = a;
      } else
        r.push(a);
    });
  });
  const i = [];
  for (const s in n)
    Object.prototype.hasOwnProperty.call(n, s) && i.push(n[s]);
  return i.push(...r), i.join(" ");
}, zo = ef, tf = (e) => e.toUpperCase() === e, nf = (e) => (t) => e.indexOf(t) === -1, Da = (e, t) => {
  const n = {};
  return Object.keys(e).filter(nf(t)).forEach((r) => {
    n[r] = e[r];
  }), n;
};
function rf(e, t, n) {
  const r = Da(t, n);
  if (!e) {
    const i = typeof Sr == "function" ? { default: Sr } : Sr;
    Object.keys(r).forEach((s) => {
      i.default(s) || delete r[s];
    });
  }
  return r;
}
var of = (e, t) => {
  if (process.env.NODE_ENV !== "production") {
    if (typeof e == "string" || // eslint-disable-next-line no-self-compare,no-restricted-globals
    typeof e == "number" && isFinite(e))
      return;
    const n = typeof e == "object" ? JSON.stringify(e) : String(e);
    console.warn(
      `An interpolation evaluated to '${n}' in the component '${t}', which is probably a mistake. You should explicitly cast or transform the value to a string.`
    );
  }
}, sf = 0;
function Ko(e) {
  let t = "";
  return process.env.NODE_ENV === "test" && (t += `mocked-styled-${sf++}`, e && e.__wyw_meta && e.__wyw_meta.className && (t += ` ${e.__wyw_meta.className}`)), (n) => {
    if (process.env.NODE_ENV !== "production" && process.env.NODE_ENV !== "test" && Array.isArray(n))
      throw new Error(
        'Using the "styled" tag in runtime is not supported. Make sure you have set up the Babel plugin correctly. See https://github.com/callstack/linaria#setup'
      );
    const r = (s, o) => {
      const { as: a = e, class: c = t } = s, l = n.propsAsIs === void 0 ? !(typeof a == "string" && a.indexOf("-") === -1 && !tf(a[0])) : n.propsAsIs, u = rf(l, s, [
        "as",
        "class"
      ]);
      u.ref = o, u.className = n.atomic ? zo(n.class, u.className || c) : zo(u.className || c, n.class);
      const { vars: d } = n;
      if (d) {
        const h = {};
        for (const w in d) {
          const I = d[w], E = I[0], P = I[1] || "", M = typeof E == "function" ? E(s) : E;
          of(M, n.name), h[`--${w}`] = `${M}${P}`;
        }
        const m = u.style || {}, v = Object.keys(m);
        v.length > 0 && v.forEach((w) => {
          h[w] = m[w];
        }), u.style = h;
      }
      return e.__wyw_meta && e !== a ? (u.as = a, je.createElement(e, u)) : je.createElement(a, u);
    }, i = je.forwardRef ? je.forwardRef(r) : (
      // React.forwardRef won't available on older React versions and in Preact
      // Fallback to a innerRef prop in that case
      (s) => {
        const o = Da(s, ["innerRef"]);
        return r(o, s.innerRef);
      }
    );
    return i.displayName = n.name, i.__wyw_meta = {
      className: n.class || t,
      extends: e
    }, i;
  };
}
var ce = process.env.NODE_ENV !== "production" ? new Proxy(Ko, {
  get(e, t) {
    return e(t);
  }
}) : Ko;
function Ni() {
  var n;
  const { state: e } = We();
  return ze(() => {
    var i;
    const r = (i = e == null ? void 0 : e.config) == null ? void 0 : i.gatewayConfig;
    return r ? `${r.protocol}://${r.host}:${r.port}` : "https://arweave.net";
  }, [(n = e == null ? void 0 : e.config) == null ? void 0 : n.gatewayConfig]);
}
function Va() {
  const [e, t] = He(), n = er(), r = Ni();
  return Te(() => {
    (async () => {
      if (!n)
        return t(void 0);
      try {
        const s = await (await fetch(
          `https://ans-stats.decent.land/profile/${n}`
        )).json();
        if (!(s != null && s.currentLabel))
          return t(void 0);
        t({
          ...s,
          currentLabel: s.currentLabel + ".ar",
          avatar: s.avatar ? `${r}/${s.avatar}` : void 0
        });
      } catch (i) {
        console.error(
          `[Arweave Wallet Kit] Failed to fetch ans profile
${(i == null ? void 0 : i.message) || i}`
        );
      }
    })();
  }, [n, r]), e;
}
const af = () => (e) => e.theme.theme, cf = () => (e) => ({
  default: 30,
  minimal: 6,
  none: 0
})[e.theme.themeConfig.radius] + "px", lf = () => (e) => e.theme.displayTheme === "light" ? `0px 0px 2px rgba(${e.theme.displayTheme === "light" ? "0, 0, 0" : "255, 255, 255"}, .15), 0px 4px 7px rgba(${e.theme.displayTheme === "light" ? "0, 0, 0" : "255, 255, 255"}, .1)` : "none", vt = Be(/* @__PURE__ */ ce("button")({
  name: "Button",
  class: "b1cb9caz",
  propsAsIs: !1,
  vars: {
    "b1cb9caz-0": [af()],
    "b1cb9caz-1": [cf()],
    "b1cb9caz-2": [lf()]
  }
}));
function fv({
  accent: e,
  showBalance: t = !0,
  showProfilePicture: n = !0,
  onClick: r,
  useAns: i = !0,
  profileModal: s = !0,
  ...o
}) {
  const {
    connected: a,
    connect: c,
    disconnect: l
  } = _i(), u = er(), d = La(), h = Va(), m = wu();
  return /* @__PURE__ */ K(hf, {
    accent: e,
    onClick: async (v) => {
      if (a ? s ? m.setOpen(!0) : await l() : await c(), r)
        return r(v);
    },
    ...o,
    children: a && /* @__PURE__ */ ye(hn, {
      children: [t && /* @__PURE__ */ K(vf, {
        children: d.toLocaleString(void 0, {
          maximumFractionDigits: 2
        }) + " AR"
      }), /* @__PURE__ */ ye(yf, {
        showBalance: t,
        children: [n && /* @__PURE__ */ K(hn, {
          children: (h == null ? void 0 : h.avatar) && i && /* @__PURE__ */ K(Af, {
            src: h == null ? void 0 : h.avatar,
            draggable: !1
          }) || /* @__PURE__ */ K(Pf, {
            children: /* @__PURE__ */ K(Sf, {})
          })
        }), i && (h == null ? void 0 : h.currentLabel) || da(u || "", 5), /* @__PURE__ */ K(Tf, {})]
      })]
    }) || /* @__PURE__ */ K(pf, {
      children: "Connect Wallet"
    })
  });
}
const uf = () => vt, ff = () => (e) => ({
  default: 18,
  minimal: 10,
  none: 0
})[e.theme.themeConfig.radius] + "px", df = () => (e) => e.accent || `rgb(${e.theme.theme})`, hf = Be(/* @__PURE__ */ ce(uf())({
  name: "Wrapper",
  class: "w14emrir",
  propsAsIs: !0,
  vars: {
    "w14emrir-0": [ff()],
    "w14emrir-1": [df()]
  }
})), pf = /* @__PURE__ */ ce("span")({
  name: "ConnectText",
  class: "czh4f0e",
  propsAsIs: !1
}), mf = () => (e) => e.showBalance ? e.theme.background : "transparent", gf = () => (e) => ({
  default: 18,
  minimal: 10,
  none: 0
})[e.theme.themeConfig.radius] - 3 + "px", yf = Be(/* @__PURE__ */ ce("div")({
  name: "ProfileSection",
  class: "pwkn5es",
  propsAsIs: !1,
  vars: {
    "pwkn5es-0": [mf()],
    "pwkn5es-1": [gf()]
  }
})), vf = /* @__PURE__ */ ce("span")({
  name: "Balance",
  class: "bdt02oh",
  propsAsIs: !1
}), wf = () => kl, Tf = /* @__PURE__ */ ce(wf())({
  name: "ExpandIcon",
  class: "e3hlv71",
  propsAsIs: !0
}), bf = () => (e) => ({
  default: "100%",
  minimal: "5px",
  none: "0px"
})[e.theme.themeConfig.radius], Af = Be(/* @__PURE__ */ ce("img")({
  name: "Avatar",
  class: "a1jsmwxp",
  propsAsIs: !1,
  vars: {
    "a1jsmwxp-0": [bf()]
  }
})), Ef = () => ha, Sf = /* @__PURE__ */ ce(Ef())({
  name: "AvatarIcon",
  class: "as6ir6f",
  propsAsIs: !0
}), xf = () => (e) => ({
  default: "100%",
  minimal: "5px",
  none: "0px"
})[e.theme.themeConfig.radius], Pf = Be(/* @__PURE__ */ ce("span")({
  name: "AvatarPlaceholder",
  class: "av7js2i",
  propsAsIs: !1,
  vars: {
    "av7js2i-0": [xf()]
  }
})), Cf = {
  strategies: [],
  permissions: ["ACCESS_ADDRESS", "ACCESS_ALL_ADDRESSES"],
  ensurePermissions: !1
}, _f = "0.0.1-beta.3";
function Of(e = 720) {
  const [t, n] = He(!1), r = ze(() => typeof window > "u" ? null : window.matchMedia(`(max-width: ${e}px)`), [e]);
  return Te(() => {
    if (!r)
      return;
    const i = (s) => n(s.matches);
    return r.addEventListener("change", i), n(r.matches), () => r.removeEventListener("change", i);
  }, [r]), t;
}
const Bi = kt({
  transformPagePoint: (e) => e,
  isStatic: !1,
  reducedMotion: "never"
}), or = kt({});
function Rf() {
  return $e(or).visualElement;
}
const An = kt(null), sr = typeof document < "u", Un = sr ? vl : Te, Na = kt({ strict: !1 });
function kf(e, t, n, r) {
  const i = Rf(), s = $e(Na), o = $e(An), a = $e(Bi).reducedMotion, c = nt();
  r = r || s.renderer, !c.current && r && (c.current = r(e, {
    visualState: t,
    parent: i,
    props: n,
    presenceId: o ? o.id : void 0,
    blockInitialAnimation: o ? o.initial === !1 : !1,
    reducedMotionConfig: a
  }));
  const l = c.current;
  return Un(() => {
    l && l.render();
  }), (window.HandoffAppearAnimations ? Un : Te)(() => {
    l && l.animationState && l.animationState.animateChanges();
  }), l;
}
function Ft(e) {
  return typeof e == "object" && Object.prototype.hasOwnProperty.call(e, "current");
}
function Mf(e, t, n) {
  return Rt(
    (r) => {
      r && e.mount && e.mount(r), t && (r ? t.mount(r) : t.unmount()), n && (typeof n == "function" ? n(r) : Ft(n) && (n.current = r));
    },
    /**
     * Only pass a new ref callback to React if we've received a visual element
     * factory. Otherwise we'll be mounting/remounting every time externalRef
     * or other dependencies change.
     */
    [t]
  );
}
function pn(e) {
  return typeof e == "string" || Array.isArray(e);
}
function ar(e) {
  return typeof e == "object" && typeof e.start == "function";
}
const If = [
  "initial",
  "animate",
  "exit",
  "whileHover",
  "whileDrag",
  "whileTap",
  "whileFocus",
  "whileInView"
];
function cr(e) {
  return ar(e.animate) || If.some((t) => pn(e[t]));
}
function Ba(e) {
  return !!(cr(e) || e.variants);
}
function Lf(e, t) {
  if (cr(e)) {
    const { initial: n, animate: r } = e;
    return {
      initial: n === !1 || pn(n) ? n : void 0,
      animate: pn(r) ? r : void 0
    };
  }
  return e.inherit !== !1 ? t : {};
}
function Df(e) {
  const { initial: t, animate: n } = Lf(e, $e(or));
  return ze(() => ({ initial: t, animate: n }), [Yo(t), Yo(n)]);
}
function Yo(e) {
  return Array.isArray(e) ? e.join(" ") : e;
}
const ft = (e) => ({
  isEnabled: (t) => e.some((n) => !!t[n])
}), mn = {
  measureLayout: ft(["layout", "layoutId", "drag"]),
  animation: ft([
    "animate",
    "exit",
    "variants",
    "whileHover",
    "whileTap",
    "whileFocus",
    "whileDrag",
    "whileInView"
  ]),
  exit: ft(["exit"]),
  drag: ft(["drag", "dragControls"]),
  focus: ft(["whileFocus"]),
  hover: ft(["whileHover", "onHoverStart", "onHoverEnd"]),
  tap: ft(["whileTap", "onTap", "onTapStart", "onTapCancel"]),
  pan: ft([
    "onPan",
    "onPanStart",
    "onPanSessionStart",
    "onPanEnd"
  ]),
  inView: ft([
    "whileInView",
    "onViewportEnter",
    "onViewportLeave"
  ])
};
function Vf(e) {
  for (const t in e)
    t === "projectionNodeConstructor" ? mn.projectionNodeConstructor = e[t] : mn[t].Component = e[t];
}
function lr(e) {
  const t = nt(null);
  return t.current === null && (t.current = e()), t.current;
}
const an = {
  /**
   * Global flag as to whether the tree has animated since the last time
   * we resized the window
   */
  hasAnimatedSinceResize: !0,
  /**
   * We set this to true once, on the first update. Any nodes added to the tree beyond that
   * update will be given a `data-projection-id` attribute.
   */
  hasEverUpdated: !1
};
let Nf = 1;
function Bf() {
  return lr(() => {
    if (an.hasEverUpdated)
      return Nf++;
  });
}
const ji = kt({});
class jf extends je.Component {
  /**
   * Update visual element props as soon as we know this update is going to be commited.
   */
  getSnapshotBeforeUpdate() {
    const { visualElement: t, props: n } = this.props;
    return t && t.setProps(n), null;
  }
  componentDidUpdate() {
  }
  render() {
    return this.props.children;
  }
}
const ja = kt({}), $f = Symbol.for("motionComponentSymbol");
function Ff({ preloadedFeatures: e, createVisualElement: t, projectionNodeConstructor: n, useRender: r, useVisualState: i, Component: s }) {
  e && Vf(e);
  function o(c, l) {
    const u = {
      ...$e(Bi),
      ...c,
      layoutId: Uf(c)
    }, { isStatic: d } = u;
    let h = null;
    const m = Df(c), v = d ? void 0 : Bf(), w = i(c, d);
    if (!d && sr) {
      m.visualElement = kf(s, w, u, t);
      const I = $e(Na).strict, E = $e(ja);
      m.visualElement && (h = m.visualElement.loadFeatures(
        // Note: Pass the full new combined props to correctly re-render dynamic feature components.
        u,
        I,
        e,
        v,
        n || mn.projectionNodeConstructor,
        E
      ));
    }
    return ve.createElement(
      jf,
      { visualElement: m.visualElement, props: u },
      h,
      ve.createElement(or.Provider, { value: m }, r(s, c, v, Mf(w, m.visualElement, l), w, d, m.visualElement))
    );
  }
  const a = wl(o);
  return a[$f] = s, a;
}
function Uf({ layoutId: e }) {
  const t = $e(ji).id;
  return t && e !== void 0 ? t + "-" + e : e;
}
function Hf(e) {
  function t(r, i = {}) {
    return Ff(e(r, i));
  }
  if (typeof Proxy > "u")
    return t;
  const n = /* @__PURE__ */ new Map();
  return new Proxy(t, {
    /**
     * Called when `motion` is referenced with a prop: `motion.div`, `motion.input` etc.
     * The prop name is passed through as `key` and we can use that to generate a `motion`
     * DOM component with that name.
     */
    get: (r, i) => (n.has(i) || n.set(i, t(i)), n.get(i))
  });
}
const Wf = [
  "animate",
  "circle",
  "defs",
  "desc",
  "ellipse",
  "g",
  "image",
  "line",
  "filter",
  "marker",
  "mask",
  "metadata",
  "path",
  "pattern",
  "polygon",
  "polyline",
  "rect",
  "stop",
  "switch",
  "symbol",
  "svg",
  "text",
  "tspan",
  "use",
  "view"
];
function $i(e) {
  return (
    /**
     * If it's not a string, it's a custom React component. Currently we only support
     * HTML custom React components.
     */
    typeof e != "string" || /**
     * If it contains a dash, the element is a custom HTML webcomponent.
     */
    e.includes("-") ? !1 : (
      /**
       * If it's in our list of lowercase SVG tags, it's an SVG component
       */
      !!(Wf.indexOf(e) > -1 || /**
       * If it contains a capital letter, it's an SVG component
       */
      /[A-Z]/.test(e))
    )
  );
}
const Hn = {};
function qf(e) {
  Object.assign(Hn, e);
}
const Wn = [
  "transformPerspective",
  "x",
  "y",
  "z",
  "translateX",
  "translateY",
  "translateZ",
  "scale",
  "scaleX",
  "scaleY",
  "rotate",
  "rotateX",
  "rotateY",
  "rotateZ",
  "skew",
  "skewX",
  "skewY"
], Gt = new Set(Wn);
function $a(e, { layout: t, layoutId: n }) {
  return Gt.has(e) || e.startsWith("origin") || (t || n !== void 0) && (!!Hn[e] || e === "opacity");
}
const Ze = (e) => !!(e != null && e.getVelocity), zf = {
  x: "translateX",
  y: "translateY",
  z: "translateZ",
  transformPerspective: "perspective"
}, Kf = (e, t) => Wn.indexOf(e) - Wn.indexOf(t);
function Yf({ transform: e, transformKeys: t }, { enableHardwareAcceleration: n = !0, allowTransformNone: r = !0 }, i, s) {
  let o = "";
  t.sort(Kf);
  for (const a of t)
    o += `${zf[a] || a}(${e[a]}) `;
  return n && !e.z && (o += "translateZ(0)"), o = o.trim(), s ? o = s(e, i ? "" : o) : r && i && (o = "none"), o;
}
function Fa(e) {
  return e.startsWith("--");
}
const Gf = (e, t) => t && typeof e == "number" ? t.transform(e) : e, Kt = (e, t, n) => Math.min(Math.max(n, e), t), Mt = {
  test: (e) => typeof e == "number",
  parse: parseFloat,
  transform: (e) => e
}, cn = {
  ...Mt,
  transform: (e) => Kt(0, 1, e)
}, Rn = {
  ...Mt,
  default: 1
}, ln = (e) => Math.round(e * 1e5) / 1e5, gn = /(-)?([\d]*\.?[\d])+/g, Gr = /(#[0-9a-f]{3,8}|(rgb|hsl)a?\((-?[\d\.]+%?[,\s]+){2}(-?[\d\.]+%?)\s*[\,\/]?\s*[\d\.]*%?\))/gi, Xf = /^(#[0-9a-f]{3,8}|(rgb|hsl)a?\((-?[\d\.]+%?[,\s]+){2}(-?[\d\.]+%?)\s*[\,\/]?\s*[\d\.]*%?\))$/i;
function En(e) {
  return typeof e == "string";
}
const Sn = (e) => ({
  test: (t) => En(t) && t.endsWith(e) && t.split(" ").length === 1,
  parse: parseFloat,
  transform: (t) => `${t}${e}`
}), mt = Sn("deg"), ct = Sn("%"), Z = Sn("px"), Zf = Sn("vh"), Jf = Sn("vw"), Go = {
  ...ct,
  parse: (e) => ct.parse(e) / 100,
  transform: (e) => ct.transform(e * 100)
}, Xo = {
  ...Mt,
  transform: Math.round
}, Ua = {
  // Border props
  borderWidth: Z,
  borderTopWidth: Z,
  borderRightWidth: Z,
  borderBottomWidth: Z,
  borderLeftWidth: Z,
  borderRadius: Z,
  radius: Z,
  borderTopLeftRadius: Z,
  borderTopRightRadius: Z,
  borderBottomRightRadius: Z,
  borderBottomLeftRadius: Z,
  // Positioning props
  width: Z,
  maxWidth: Z,
  height: Z,
  maxHeight: Z,
  size: Z,
  top: Z,
  right: Z,
  bottom: Z,
  left: Z,
  // Spacing props
  padding: Z,
  paddingTop: Z,
  paddingRight: Z,
  paddingBottom: Z,
  paddingLeft: Z,
  margin: Z,
  marginTop: Z,
  marginRight: Z,
  marginBottom: Z,
  marginLeft: Z,
  // Transform props
  rotate: mt,
  rotateX: mt,
  rotateY: mt,
  rotateZ: mt,
  scale: Rn,
  scaleX: Rn,
  scaleY: Rn,
  scaleZ: Rn,
  skew: mt,
  skewX: mt,
  skewY: mt,
  distance: Z,
  translateX: Z,
  translateY: Z,
  translateZ: Z,
  x: Z,
  y: Z,
  z: Z,
  perspective: Z,
  transformPerspective: Z,
  opacity: cn,
  originX: Go,
  originY: Go,
  originZ: Z,
  // Misc
  zIndex: Xo,
  // SVG
  fillOpacity: cn,
  strokeOpacity: cn,
  numOctaves: Xo
};
function Fi(e, t, n, r) {
  const { style: i, vars: s, transform: o, transformKeys: a, transformOrigin: c } = e;
  a.length = 0;
  let l = !1, u = !1, d = !0;
  for (const h in t) {
    const m = t[h];
    if (Fa(h)) {
      s[h] = m;
      continue;
    }
    const v = Ua[h], w = Gf(m, v);
    if (Gt.has(h)) {
      if (l = !0, o[h] = w, a.push(h), !d)
        continue;
      m !== (v.default || 0) && (d = !1);
    } else
      h.startsWith("origin") ? (u = !0, c[h] = w) : i[h] = w;
  }
  if (t.transform || (l || r ? i.transform = Yf(e, n, d, r) : i.transform && (i.transform = "none")), u) {
    const { originX: h = "50%", originY: m = "50%", originZ: v = 0 } = c;
    i.transformOrigin = `${h} ${m} ${v}`;
  }
}
const Ui = () => ({
  style: {},
  transform: {},
  transformKeys: [],
  transformOrigin: {},
  vars: {}
});
function Ha(e, t, n) {
  for (const r in t)
    !Ze(t[r]) && !$a(r, n) && (e[r] = t[r]);
}
function Qf({ transformTemplate: e }, t, n) {
  return ze(() => {
    const r = Ui();
    return Fi(r, t, { enableHardwareAcceleration: !n }, e), Object.assign({}, r.vars, r.style);
  }, [t]);
}
function ed(e, t, n) {
  const r = e.style || {}, i = {};
  return Ha(i, r, e), Object.assign(i, Qf(e, t, n)), e.transformValues ? e.transformValues(i) : i;
}
function td(e, t, n) {
  const r = {}, i = ed(e, t, n);
  return e.drag && e.dragListener !== !1 && (r.draggable = !1, i.userSelect = i.WebkitUserSelect = i.WebkitTouchCallout = "none", i.touchAction = e.drag === !0 ? "none" : `pan-${e.drag === "x" ? "y" : "x"}`), r.style = i, r;
}
const nd = /* @__PURE__ */ new Set([
  "animate",
  "exit",
  "variants",
  "initial",
  "style",
  "values",
  "variants",
  "transition",
  "transformTemplate",
  "transformValues",
  "custom",
  "inherit",
  "onLayoutAnimationStart",
  "onLayoutAnimationComplete",
  "onLayoutMeasure",
  "onBeforeLayoutMeasure",
  "onAnimationStart",
  "onAnimationComplete",
  "onUpdate",
  "onDragStart",
  "onDrag",
  "onDragEnd",
  "onMeasureDragConstraints",
  "onDirectionLock",
  "onDragTransitionEnd",
  "_dragX",
  "_dragY",
  "onHoverStart",
  "onHoverEnd",
  "onViewportEnter",
  "onViewportLeave",
  "viewport"
]);
function qn(e) {
  return e.startsWith("while") || e.startsWith("drag") && e !== "draggable" || e.startsWith("layout") || e.startsWith("onTap") || e.startsWith("onPan") || nd.has(e);
}
let Wa = (e) => !qn(e);
function rd(e) {
  e && (Wa = (t) => t.startsWith("on") ? !qn(t) : e(t));
}
try {
  rd(require("@emotion/is-prop-valid").default);
} catch {
}
function id(e, t, n) {
  const r = {};
  for (const i in e)
    i === "values" && typeof e.values == "object" || (Wa(i) || n === !0 && qn(i) || !t && !qn(i) || // If trying to use native HTML drag events, forward drag listeners
    e.draggable && i.startsWith("onDrag")) && (r[i] = e[i]);
  return r;
}
function Zo(e, t, n) {
  return typeof e == "string" ? e : Z.transform(t + n * e);
}
function od(e, t, n) {
  const r = Zo(t, e.x, e.width), i = Zo(n, e.y, e.height);
  return `${r} ${i}`;
}
const sd = {
  offset: "stroke-dashoffset",
  array: "stroke-dasharray"
}, ad = {
  offset: "strokeDashoffset",
  array: "strokeDasharray"
};
function cd(e, t, n = 1, r = 0, i = !0) {
  e.pathLength = 1;
  const s = i ? sd : ad;
  e[s.offset] = Z.transform(-r);
  const o = Z.transform(t), a = Z.transform(n);
  e[s.array] = `${o} ${a}`;
}
function Hi(e, {
  attrX: t,
  attrY: n,
  originX: r,
  originY: i,
  pathLength: s,
  pathSpacing: o = 1,
  pathOffset: a = 0,
  // This is object creation, which we try to avoid per-frame.
  ...c
}, l, u, d) {
  if (Fi(e, c, l, d), u) {
    e.style.viewBox && (e.attrs.viewBox = e.style.viewBox);
    return;
  }
  e.attrs = e.style, e.style = {};
  const { attrs: h, style: m, dimensions: v } = e;
  h.transform && (v && (m.transform = h.transform), delete h.transform), v && (r !== void 0 || i !== void 0 || m.transform) && (m.transformOrigin = od(v, r !== void 0 ? r : 0.5, i !== void 0 ? i : 0.5)), t !== void 0 && (h.x = t), n !== void 0 && (h.y = n), s !== void 0 && cd(h, s, o, a, !1);
}
const qa = () => ({
  ...Ui(),
  attrs: {}
}), Wi = (e) => typeof e == "string" && e.toLowerCase() === "svg";
function ld(e, t, n, r) {
  const i = ze(() => {
    const s = qa();
    return Hi(s, t, { enableHardwareAcceleration: !1 }, Wi(r), e.transformTemplate), {
      ...s.attrs,
      style: { ...s.style }
    };
  }, [t]);
  if (e.style) {
    const s = {};
    Ha(s, e.style, e), i.style = { ...s, ...i.style };
  }
  return i;
}
function ud(e = !1) {
  return (n, r, i, s, { latestValues: o }, a) => {
    const l = ($i(n) ? ld : td)(r, o, a, n), d = {
      ...id(r, typeof n == "string", e),
      ...l,
      ref: s
    }, { children: h } = r, m = ze(() => Ze(h) ? h.get() : h, [h]);
    return i && (d["data-projection-id"] = i), la(n, {
      ...d,
      children: m
    });
  };
}
const qi = (e) => e.replace(/([a-z])([A-Z])/g, "$1-$2").toLowerCase();
function za(e, { style: t, vars: n }, r, i) {
  Object.assign(e.style, t, i && i.getProjectionStyles(r));
  for (const s in n)
    e.style.setProperty(s, n[s]);
}
const Ka = /* @__PURE__ */ new Set([
  "baseFrequency",
  "diffuseConstant",
  "kernelMatrix",
  "kernelUnitLength",
  "keySplines",
  "keyTimes",
  "limitingConeAngle",
  "markerHeight",
  "markerWidth",
  "numOctaves",
  "targetX",
  "targetY",
  "surfaceScale",
  "specularConstant",
  "specularExponent",
  "stdDeviation",
  "tableValues",
  "viewBox",
  "gradientTransform",
  "pathLength",
  "startOffset",
  "textLength",
  "lengthAdjust"
]);
function Ya(e, t, n, r) {
  za(e, t, void 0, r);
  for (const i in t.attrs)
    e.setAttribute(Ka.has(i) ? i : qi(i), t.attrs[i]);
}
function zi(e, t) {
  const { style: n } = e, r = {};
  for (const i in n)
    (Ze(n[i]) || t.style && Ze(t.style[i]) || $a(i, e)) && (r[i] = n[i]);
  return r;
}
function Ga(e, t) {
  const n = zi(e, t);
  for (const r in e)
    if (Ze(e[r]) || Ze(t[r])) {
      const i = r === "x" || r === "y" ? "attr" + r.toUpperCase() : r;
      n[i] = e[r];
    }
  return n;
}
function Ki(e, t, n, r = {}, i = {}) {
  return typeof t == "function" && (t = t(n !== void 0 ? n : e.custom, r, i)), typeof t == "string" && (t = e.variants && e.variants[t]), typeof t == "function" && (t = t(n !== void 0 ? n : e.custom, r, i)), t;
}
const zn = (e) => Array.isArray(e), fd = (e) => !!(e && typeof e == "object" && e.mix && e.toValue), dd = (e) => zn(e) ? e[e.length - 1] || 0 : e;
function Nn(e) {
  const t = Ze(e) ? e.get() : e;
  return fd(t) ? t.toValue() : t;
}
function hd({ scrapeMotionValuesFromProps: e, createRenderState: t, onMount: n }, r, i, s) {
  const o = {
    latestValues: pd(r, i, s, e),
    renderState: t()
  };
  return n && (o.mount = (a) => n(r, a, o)), o;
}
const Xa = (e) => (t, n) => {
  const r = $e(or), i = $e(An), s = () => hd(e, t, r, i);
  return n ? s() : lr(s);
};
function pd(e, t, n, r) {
  const i = {}, s = r(e, {});
  for (const h in s)
    i[h] = Nn(s[h]);
  let { initial: o, animate: a } = e;
  const c = cr(e), l = Ba(e);
  t && l && !c && e.inherit !== !1 && (o === void 0 && (o = t.initial), a === void 0 && (a = t.animate));
  let u = n ? n.initial === !1 : !1;
  u = u || o === !1;
  const d = u ? a : o;
  return d && typeof d != "boolean" && !ar(d) && (Array.isArray(d) ? d : [d]).forEach((m) => {
    const v = Ki(e, m);
    if (!v)
      return;
    const { transitionEnd: w, transition: I, ...E } = v;
    for (const P in E) {
      let M = E[P];
      if (Array.isArray(M)) {
        const L = u ? M.length - 1 : 0;
        M = M[L];
      }
      M !== null && (i[P] = M);
    }
    for (const P in w)
      i[P] = w[P];
  }), i;
}
const md = {
  useVisualState: Xa({
    scrapeMotionValuesFromProps: Ga,
    createRenderState: qa,
    onMount: (e, t, { renderState: n, latestValues: r }) => {
      try {
        n.dimensions = typeof t.getBBox == "function" ? t.getBBox() : t.getBoundingClientRect();
      } catch {
        n.dimensions = {
          x: 0,
          y: 0,
          width: 0,
          height: 0
        };
      }
      Hi(n, r, { enableHardwareAcceleration: !1 }, Wi(t.tagName), e.transformTemplate), Ya(t, n);
    }
  })
}, gd = {
  useVisualState: Xa({
    scrapeMotionValuesFromProps: zi,
    createRenderState: Ui
  })
};
function yd(e, { forwardMotionProps: t = !1 }, n, r, i) {
  return {
    ...$i(e) ? md : gd,
    preloadedFeatures: n,
    useRender: ud(t),
    createVisualElement: r,
    projectionNodeConstructor: i,
    Component: e
  };
}
var Pe;
(function(e) {
  e.Animate = "animate", e.Hover = "whileHover", e.Tap = "whileTap", e.Drag = "whileDrag", e.Focus = "whileFocus", e.InView = "whileInView", e.Exit = "exit";
})(Pe || (Pe = {}));
function ur(e, t, n, r = { passive: !0 }) {
  return e.addEventListener(t, n, r), () => e.removeEventListener(t, n);
}
function Xr(e, t, n, r) {
  Te(() => {
    const i = e.current;
    if (n && i)
      return ur(i, t, n, r);
  }, [e, t, n, r]);
}
function vd({ whileFocus: e, visualElement: t }) {
  const { animationState: n } = t, r = Rt(() => {
    n && n.setActive(Pe.Focus, !0);
  }, [n]), i = Rt(() => {
    n && n.setActive(Pe.Focus, !1);
  }, [n]);
  Xr(t, "focus", e ? r : void 0), Xr(t, "blur", e ? i : void 0);
}
const Za = (e) => e.pointerType === "mouse" ? typeof e.button != "number" || e.button <= 0 : e.isPrimary !== !1;
function Yi(e, t = "page") {
  return {
    point: {
      x: e[t + "X"],
      y: e[t + "Y"]
    }
  };
}
const Ja = (e) => (t) => Za(t) && e(t, Yi(t));
function qt(e, t, n, r) {
  return ur(e, t, Ja(n), r);
}
function Kn(e, t, n, r) {
  return Xr(e, t, n && Ja(n), r);
}
function Qa(e) {
  let t = null;
  return () => {
    const n = () => {
      t = null;
    };
    return t === null ? (t = e, n) : !1;
  };
}
const Jo = Qa("dragHorizontal"), Qo = Qa("dragVertical");
function ec(e) {
  let t = !1;
  if (e === "y")
    t = Qo();
  else if (e === "x")
    t = Jo();
  else {
    const n = Jo(), r = Qo();
    n && r ? t = () => {
      n(), r();
    } : (n && n(), r && r());
  }
  return t;
}
function tc() {
  const e = ec(!0);
  return e ? (e(), !1) : !0;
}
function es(e, t, n, r) {
  return (i, s) => {
    i.type === "touch" || tc() || (n && e.animationState && e.animationState.setActive(Pe.Hover, t), r && r(i, s));
  };
}
function wd({ onHoverStart: e, onHoverEnd: t, whileHover: n, visualElement: r }) {
  Kn(r, "pointerenter", ze(() => e || n ? es(r, !0, !!n, e) : void 0, [e, !!n, r]), { passive: !e }), Kn(r, "pointerleave", ze(() => t || n ? es(r, !1, !!n, t) : void 0, [e, !!n, r]), { passive: !t });
}
const nc = (e, t) => t ? e === t ? !0 : nc(e, t.parentElement) : !1;
function Gi(e) {
  return Te(() => () => e(), []);
}
const Td = (e, t) => (n) => t(e(n)), fr = (...e) => e.reduce(Td);
function bd({ onTap: e, onTapStart: t, onTapCancel: n, whileTap: r, visualElement: i, ...s }) {
  const o = e || t || n || r, a = nt(!1), c = nt(null), l = {
    passive: !(t || e || n || s.onPointerDown)
  };
  function u() {
    c.current && c.current(), c.current = null;
  }
  function d() {
    return u(), a.current = !1, i.getProps().whileTap && i.animationState && i.animationState.setActive(Pe.Tap, !1), !tc();
  }
  function h(w, I) {
    var E, P, M, L;
    d() && (nc(i.current, w.target) ? (L = (M = i.getProps()).onTap) === null || L === void 0 || L.call(M, w, I) : (P = (E = i.getProps()).onTapCancel) === null || P === void 0 || P.call(E, w, I));
  }
  function m(w, I) {
    var E, P;
    d() && ((P = (E = i.getProps()).onTapCancel) === null || P === void 0 || P.call(E, w, I));
  }
  const v = Rt((w, I) => {
    var E;
    if (u(), a.current)
      return;
    a.current = !0, c.current = fr(qt(window, "pointerup", h, l), qt(window, "pointercancel", m, l));
    const P = i.getProps();
    P.whileTap && i.animationState && i.animationState.setActive(Pe.Tap, !0), (E = P.onTapStart) === null || E === void 0 || E.call(P, w, I);
  }, [!!t, i]);
  Kn(i, "pointerdown", o ? v : void 0, l), Gi(u);
}
const ts = /* @__PURE__ */ new Set();
function dr(e, t, n) {
  e || ts.has(t) || (console.warn(t), n && console.warn(n), ts.add(t));
}
const Zr = /* @__PURE__ */ new WeakMap(), xr = /* @__PURE__ */ new WeakMap(), Ad = (e) => {
  const t = Zr.get(e.target);
  t && t(e);
}, Ed = (e) => {
  e.forEach(Ad);
};
function Sd({ root: e, ...t }) {
  const n = e || document;
  xr.has(n) || xr.set(n, {});
  const r = xr.get(n), i = JSON.stringify(t);
  return r[i] || (r[i] = new IntersectionObserver(Ed, { root: e, ...t })), r[i];
}
function xd(e, t, n) {
  const r = Sd(t);
  return Zr.set(e, n), r.observe(e), () => {
    Zr.delete(e), r.unobserve(e);
  };
}
function Pd({ visualElement: e, whileInView: t, onViewportEnter: n, onViewportLeave: r, viewport: i = {} }) {
  const s = nt({
    hasEnteredView: !1,
    isInView: !1
  });
  let o = !!(t || n || r);
  i.once && s.current.hasEnteredView && (o = !1), (typeof IntersectionObserver > "u" ? Od : _d)(o, s.current, e, i);
}
const Cd = {
  some: 0,
  all: 1
};
function _d(e, t, n, { root: r, margin: i, amount: s = "some", once: o }) {
  Te(() => {
    if (!e || !n.current)
      return;
    const a = {
      root: r == null ? void 0 : r.current,
      rootMargin: i,
      threshold: typeof s == "number" ? s : Cd[s]
    }, c = (l) => {
      const { isIntersecting: u } = l;
      if (t.isInView === u || (t.isInView = u, o && !u && t.hasEnteredView))
        return;
      u && (t.hasEnteredView = !0), n.animationState && n.animationState.setActive(Pe.InView, u);
      const d = n.getProps(), h = u ? d.onViewportEnter : d.onViewportLeave;
      h && h(l);
    };
    return xd(n.current, a, c);
  }, [e, r, i, s]);
}
function Od(e, t, n, { fallback: r = !0 }) {
  Te(() => {
    !e || !r || (process.env.NODE_ENV !== "production" && dr(!1, "IntersectionObserver not available on this device. whileInView animations will trigger on mount."), requestAnimationFrame(() => {
      t.hasEnteredView = !0;
      const { onViewportEnter: i } = n.getProps();
      i && i(null), n.animationState && n.animationState.setActive(Pe.InView, !0);
    }));
  }, [e]);
}
const yt = (e) => (t) => (e(t), null), Rd = {
  inView: yt(Pd),
  tap: yt(bd),
  focus: yt(vd),
  hover: yt(wd)
};
function rc() {
  const e = $e(An);
  if (e === null)
    return [!0, null];
  const { isPresent: t, onExitComplete: n, register: r } = e, i = wi();
  return Te(() => r(i), []), !t && n ? [!1, () => n && n(i)] : [!0];
}
function ic(e, t) {
  if (!Array.isArray(t))
    return !1;
  const n = t.length;
  if (n !== e.length)
    return !1;
  for (let r = 0; r < n; r++)
    if (t[r] !== e[r])
      return !1;
  return !0;
}
const kd = (e) => /^\-?\d*\.?\d+$/.test(e), Md = (e) => /^0[^.\s]+$/.test(e), ht = {
  delta: 0,
  timestamp: 0
}, oc = 1 / 60 * 1e3, Id = typeof performance < "u" ? () => performance.now() : () => Date.now(), sc = typeof window < "u" ? (e) => window.requestAnimationFrame(e) : (e) => setTimeout(() => e(Id()), oc);
function Ld(e) {
  let t = [], n = [], r = 0, i = !1, s = !1;
  const o = /* @__PURE__ */ new WeakSet(), a = {
    /**
     * Schedule a process to run on the next frame.
     */
    schedule: (c, l = !1, u = !1) => {
      const d = u && i, h = d ? t : n;
      return l && o.add(c), h.indexOf(c) === -1 && (h.push(c), d && i && (r = t.length)), c;
    },
    /**
     * Cancel the provided callback from running on the next frame.
     */
    cancel: (c) => {
      const l = n.indexOf(c);
      l !== -1 && n.splice(l, 1), o.delete(c);
    },
    /**
     * Execute all schedule callbacks.
     */
    process: (c) => {
      if (i) {
        s = !0;
        return;
      }
      if (i = !0, [t, n] = [n, t], n.length = 0, r = t.length, r)
        for (let l = 0; l < r; l++) {
          const u = t[l];
          u(c), o.has(u) && (a.schedule(u), e());
        }
      i = !1, s && (s = !1, a.process(c));
    }
  };
  return a;
}
const Dd = 40;
let Jr = !0, yn = !1, Qr = !1;
const xn = [
  "read",
  "update",
  "preRender",
  "render",
  "postRender"
], hr = xn.reduce((e, t) => (e[t] = Ld(() => yn = !0), e), {}), qe = xn.reduce((e, t) => {
  const n = hr[t];
  return e[t] = (r, i = !1, s = !1) => (yn || Nd(), n.schedule(r, i, s)), e;
}, {}), wt = xn.reduce((e, t) => (e[t] = hr[t].cancel, e), {}), Pr = xn.reduce((e, t) => (e[t] = () => hr[t].process(ht), e), {}), Vd = (e) => hr[e].process(ht), ac = (e) => {
  yn = !1, ht.delta = Jr ? oc : Math.max(Math.min(e - ht.timestamp, Dd), 1), ht.timestamp = e, Qr = !0, xn.forEach(Vd), Qr = !1, yn && (Jr = !1, sc(ac));
}, Nd = () => {
  yn = !0, Jr = !0, Qr || sc(ac);
};
function Xi(e, t) {
  e.indexOf(t) === -1 && e.push(t);
}
function Zi(e, t) {
  const n = e.indexOf(t);
  n > -1 && e.splice(n, 1);
}
class Ji {
  constructor() {
    this.subscriptions = [];
  }
  add(t) {
    return Xi(this.subscriptions, t), () => Zi(this.subscriptions, t);
  }
  notify(t, n, r) {
    const i = this.subscriptions.length;
    if (i)
      if (i === 1)
        this.subscriptions[0](t, n, r);
      else
        for (let s = 0; s < i; s++) {
          const o = this.subscriptions[s];
          o && o(t, n, r);
        }
  }
  getSize() {
    return this.subscriptions.length;
  }
  clear() {
    this.subscriptions.length = 0;
  }
}
function Qi(e, t) {
  return t ? e * (1e3 / t) : 0;
}
const Bd = (e) => !isNaN(parseFloat(e));
class jd {
  /**
   * @param init - The initiating value
   * @param config - Optional configuration options
   *
   * -  `transformer`: A function to transform incoming values with.
   *
   * @internal
   */
  constructor(t, n = {}) {
    this.version = "8.5.5", this.timeDelta = 0, this.lastUpdated = 0, this.canTrackVelocity = !1, this.events = {}, this.updateAndNotify = (r, i = !0) => {
      this.prev = this.current, this.current = r;
      const { delta: s, timestamp: o } = ht;
      this.lastUpdated !== o && (this.timeDelta = s, this.lastUpdated = o, qe.postRender(this.scheduleVelocityCheck)), this.prev !== this.current && this.events.change && this.events.change.notify(this.current), this.events.velocityChange && this.events.velocityChange.notify(this.getVelocity()), i && this.events.renderRequest && this.events.renderRequest.notify(this.current);
    }, this.scheduleVelocityCheck = () => qe.postRender(this.velocityCheck), this.velocityCheck = ({ timestamp: r }) => {
      r !== this.lastUpdated && (this.prev = this.current, this.events.velocityChange && this.events.velocityChange.notify(this.getVelocity()));
    }, this.hasAnimated = !1, this.prev = this.current = t, this.canTrackVelocity = Bd(this.current), this.owner = n.owner;
  }
  /**
   * Adds a function that will be notified when the `MotionValue` is updated.
   *
   * It returns a function that, when called, will cancel the subscription.
   *
   * When calling `onChange` inside a React component, it should be wrapped with the
   * `useEffect` hook. As it returns an unsubscribe function, this should be returned
   * from the `useEffect` function to ensure you don't add duplicate subscribers..
   *
   * ```jsx
   * export const MyComponent = () => {
   *   const x = useMotionValue(0)
   *   const y = useMotionValue(0)
   *   const opacity = useMotionValue(1)
   *
   *   useEffect(() => {
   *     function updateOpacity() {
   *       const maxXY = Math.max(x.get(), y.get())
   *       const newOpacity = transform(maxXY, [0, 100], [1, 0])
   *       opacity.set(newOpacity)
   *     }
   *
   *     const unsubscribeX = x.on("change", updateOpacity)
   *     const unsubscribeY = y.on("change", updateOpacity)
   *
   *     return () => {
   *       unsubscribeX()
   *       unsubscribeY()
   *     }
   *   }, [])
   *
   *   return <motion.div style={{ x }} />
   * }
   * ```
   *
   * @param subscriber - A function that receives the latest value.
   * @returns A function that, when called, will cancel this subscription.
   *
   * @deprecated
   */
  onChange(t) {
    return this.on("change", t);
  }
  on(t, n) {
    this.events[t] || (this.events[t] = new Ji());
    const r = this.events[t].add(n);
    return t === "change" ? () => {
      r(), qe.read(() => {
        this.events.change.getSize() || this.stop();
      });
    } : r;
  }
  clearListeners() {
    for (const t in this.events)
      this.events[t].clear();
  }
  /**
   * Attaches a passive effect to the `MotionValue`.
   *
   * @internal
   */
  attach(t, n) {
    this.passiveEffect = t, this.stopPassiveEffect = n;
  }
  /**
   * Sets the state of the `MotionValue`.
   *
   * @remarks
   *
   * ```jsx
   * const x = useMotionValue(0)
   * x.set(10)
   * ```
   *
   * @param latest - Latest value to set.
   * @param render - Whether to notify render subscribers. Defaults to `true`
   *
   * @public
   */
  set(t, n = !0) {
    !n || !this.passiveEffect ? this.updateAndNotify(t, n) : this.passiveEffect(t, this.updateAndNotify);
  }
  setWithVelocity(t, n, r) {
    this.set(n), this.prev = t, this.timeDelta = r;
  }
  /**
   * Set the state of the `MotionValue`, stopping any active animations,
   * effects, and resets velocity to `0`.
   */
  jump(t) {
    this.updateAndNotify(t), this.prev = t, this.stop(), this.stopPassiveEffect && this.stopPassiveEffect();
  }
  /**
   * Returns the latest state of `MotionValue`
   *
   * @returns - The latest state of `MotionValue`
   *
   * @public
   */
  get() {
    return this.current;
  }
  /**
   * @public
   */
  getPrevious() {
    return this.prev;
  }
  /**
   * Returns the latest velocity of `MotionValue`
   *
   * @returns - The latest velocity of `MotionValue`. Returns `0` if the state is non-numerical.
   *
   * @public
   */
  getVelocity() {
    return this.canTrackVelocity ? (
      // These casts could be avoided if parseFloat would be typed better
      Qi(parseFloat(this.current) - parseFloat(this.prev), this.timeDelta)
    ) : 0;
  }
  /**
   * Registers a new animation to control this `MotionValue`. Only one
   * animation can drive a `MotionValue` at one time.
   *
   * ```jsx
   * value.start()
   * ```
   *
   * @param animation - A function that starts the provided animation
   *
   * @internal
   */
  start(t) {
    return this.stop(), new Promise((n) => {
      this.hasAnimated = !0, this.animation = t(n) || null, this.events.animationStart && this.events.animationStart.notify();
    }).then(() => {
      this.events.animationComplete && this.events.animationComplete.notify(), this.clearAnimation();
    });
  }
  /**
   * Stop the currently active animation.
   *
   * @public
   */
  stop() {
    this.animation && (this.animation.stop(), this.events.animationCancel && this.events.animationCancel.notify()), this.clearAnimation();
  }
  /**
   * Returns `true` if this value is currently animating.
   *
   * @public
   */
  isAnimating() {
    return !!this.animation;
  }
  clearAnimation() {
    this.animation = null;
  }
  /**
   * Destroy and clean up subscribers to this `MotionValue`.
   *
   * The `MotionValue` hooks like `useMotionValue` and `useTransform` automatically
   * handle the lifecycle of the returned `MotionValue`, so this method is only necessary if you've manually
   * created a `MotionValue` via the `motionValue` function.
   *
   * @public
   */
  destroy() {
    this.clearListeners(), this.stop(), this.stopPassiveEffect && this.stopPassiveEffect();
  }
}
function Yt(e, t) {
  return new jd(e, t);
}
const eo = (e, t) => (n) => !!(En(n) && Xf.test(n) && n.startsWith(e) || t && Object.prototype.hasOwnProperty.call(n, t)), cc = (e, t, n) => (r) => {
  if (!En(r))
    return r;
  const [i, s, o, a] = r.match(gn);
  return {
    [e]: parseFloat(i),
    [t]: parseFloat(s),
    [n]: parseFloat(o),
    alpha: a !== void 0 ? parseFloat(a) : 1
  };
}, $d = (e) => Kt(0, 255, e), Cr = {
  ...Mt,
  transform: (e) => Math.round($d(e))
}, _t = {
  test: eo("rgb", "red"),
  parse: cc("red", "green", "blue"),
  transform: ({ red: e, green: t, blue: n, alpha: r = 1 }) => "rgba(" + Cr.transform(e) + ", " + Cr.transform(t) + ", " + Cr.transform(n) + ", " + ln(cn.transform(r)) + ")"
};
function Fd(e) {
  let t = "", n = "", r = "", i = "";
  return e.length > 5 ? (t = e.substring(1, 3), n = e.substring(3, 5), r = e.substring(5, 7), i = e.substring(7, 9)) : (t = e.substring(1, 2), n = e.substring(2, 3), r = e.substring(3, 4), i = e.substring(4, 5), t += t, n += n, r += r, i += i), {
    red: parseInt(t, 16),
    green: parseInt(n, 16),
    blue: parseInt(r, 16),
    alpha: i ? parseInt(i, 16) / 255 : 1
  };
}
const ei = {
  test: eo("#"),
  parse: Fd,
  transform: _t.transform
}, Ut = {
  test: eo("hsl", "hue"),
  parse: cc("hue", "saturation", "lightness"),
  transform: ({ hue: e, saturation: t, lightness: n, alpha: r = 1 }) => "hsla(" + Math.round(e) + ", " + ct.transform(ln(t)) + ", " + ct.transform(ln(n)) + ", " + ln(cn.transform(r)) + ")"
}, Ye = {
  test: (e) => _t.test(e) || ei.test(e) || Ut.test(e),
  parse: (e) => _t.test(e) ? _t.parse(e) : Ut.test(e) ? Ut.parse(e) : ei.parse(e),
  transform: (e) => En(e) ? e : e.hasOwnProperty("red") ? _t.transform(e) : Ut.transform(e)
}, lc = "${c}", uc = "${n}";
function Ud(e) {
  var t, n;
  return isNaN(e) && En(e) && (((t = e.match(gn)) === null || t === void 0 ? void 0 : t.length) || 0) + (((n = e.match(Gr)) === null || n === void 0 ? void 0 : n.length) || 0) > 0;
}
function Yn(e) {
  typeof e == "number" && (e = `${e}`);
  const t = [];
  let n = 0, r = 0;
  const i = e.match(Gr);
  i && (n = i.length, e = e.replace(Gr, lc), t.push(...i.map(Ye.parse)));
  const s = e.match(gn);
  return s && (r = s.length, e = e.replace(gn, uc), t.push(...s.map(Mt.parse))), { values: t, numColors: n, numNumbers: r, tokenised: e };
}
function fc(e) {
  return Yn(e).values;
}
function dc(e) {
  const { values: t, numColors: n, tokenised: r } = Yn(e), i = t.length;
  return (s) => {
    let o = r;
    for (let a = 0; a < i; a++)
      o = o.replace(a < n ? lc : uc, a < n ? Ye.transform(s[a]) : ln(s[a]));
    return o;
  };
}
const Hd = (e) => typeof e == "number" ? 0 : e;
function Wd(e) {
  const t = fc(e);
  return dc(e)(t.map(Hd));
}
const Tt = { test: Ud, parse: fc, createTransformer: dc, getAnimatableNone: Wd }, qd = /* @__PURE__ */ new Set(["brightness", "contrast", "saturate", "opacity"]);
function zd(e) {
  const [t, n] = e.slice(0, -1).split("(");
  if (t === "drop-shadow")
    return e;
  const [r] = n.match(gn) || [];
  if (!r)
    return e;
  const i = n.replace(r, "");
  let s = qd.has(t) ? 1 : 0;
  return r !== n && (s *= 100), t + "(" + s + i + ")";
}
const Kd = /([a-z-]*)\(.*?\)/g, ti = {
  ...Tt,
  getAnimatableNone: (e) => {
    const t = e.match(Kd);
    return t ? t.map(zd).join(" ") : e;
  }
}, Yd = {
  ...Ua,
  // Color props
  color: Ye,
  backgroundColor: Ye,
  outlineColor: Ye,
  fill: Ye,
  stroke: Ye,
  // Border props
  borderColor: Ye,
  borderTopColor: Ye,
  borderRightColor: Ye,
  borderBottomColor: Ye,
  borderLeftColor: Ye,
  filter: ti,
  WebkitFilter: ti
}, to = (e) => Yd[e];
function no(e, t) {
  var n;
  let r = to(e);
  return r !== ti && (r = Tt), (n = r.getAnimatableNone) === null || n === void 0 ? void 0 : n.call(r, t);
}
const hc = (e) => (t) => t.test(e), Gd = {
  test: (e) => e === "auto",
  parse: (e) => e
}, pc = [Mt, Z, ct, mt, Jf, Zf, Gd], tn = (e) => pc.find(hc(e)), Xd = [...pc, Ye, Tt], Zd = (e) => Xd.find(hc(e));
function Jd(e) {
  const t = {};
  return e.values.forEach((n, r) => t[r] = n.get()), t;
}
function Qd(e) {
  const t = {};
  return e.values.forEach((n, r) => t[r] = n.getVelocity()), t;
}
function pr(e, t, n) {
  const r = e.getProps();
  return Ki(r, t, n !== void 0 ? n : r.custom, Jd(e), Qd(e));
}
function eh(e, t, n) {
  e.hasValue(t) ? e.getValue(t).set(n) : e.addValue(t, Yt(n));
}
function th(e, t) {
  const n = pr(e, t);
  let { transitionEnd: r = {}, transition: i = {}, ...s } = n ? e.makeTargetAnimatable(n, !1) : {};
  s = { ...s, ...r };
  for (const o in s) {
    const a = dd(s[o]);
    eh(e, o, a);
  }
}
function nh(e, t, n) {
  var r, i;
  const s = Object.keys(t).filter((a) => !e.hasValue(a)), o = s.length;
  if (o)
    for (let a = 0; a < o; a++) {
      const c = s[a], l = t[c];
      let u = null;
      Array.isArray(l) && (u = l[0]), u === null && (u = (i = (r = n[c]) !== null && r !== void 0 ? r : e.readValue(c)) !== null && i !== void 0 ? i : t[c]), u != null && (typeof u == "string" && (kd(u) || Md(u)) ? u = parseFloat(u) : !Zd(u) && Tt.test(l) && (u = no(c, l)), e.addValue(c, Yt(u, { owner: e })), n[c] === void 0 && (n[c] = u), u !== null && e.setBaseTarget(c, u));
    }
}
function rh(e, t) {
  return t ? (t[e] || t.default || t).from : void 0;
}
function ih(e, t, n) {
  var r;
  const i = {};
  for (const s in e) {
    const o = rh(s, t);
    i[s] = o !== void 0 ? o : (r = n.getValue(s)) === null || r === void 0 ? void 0 : r.get();
  }
  return i;
}
function Gn(e) {
  return !!(Ze(e) && e.add);
}
const oh = "framerAppearId", sh = "data-" + qi(oh);
var mr = function() {
}, ot = function() {
};
process.env.NODE_ENV !== "production" && (mr = function(e, t) {
  !e && typeof console < "u" && console.warn(t);
}, ot = function(e, t) {
  if (!e)
    throw new Error(t);
});
const Bn = (e) => e * 1e3, ah = {
  current: !1
}, ro = (e) => (t) => t <= 0.5 ? e(2 * t) / 2 : (2 - e(2 * (1 - t))) / 2, io = (e) => (t) => 1 - e(1 - t), oo = (e) => e * e, ch = io(oo), so = ro(oo), Me = (e, t, n) => -n * e + n * t + e;
function _r(e, t, n) {
  return n < 0 && (n += 1), n > 1 && (n -= 1), n < 1 / 6 ? e + (t - e) * 6 * n : n < 1 / 2 ? t : n < 2 / 3 ? e + (t - e) * (2 / 3 - n) * 6 : e;
}
function lh({ hue: e, saturation: t, lightness: n, alpha: r }) {
  e /= 360, t /= 100, n /= 100;
  let i = 0, s = 0, o = 0;
  if (!t)
    i = s = o = n;
  else {
    const a = n < 0.5 ? n * (1 + t) : n + t - n * t, c = 2 * n - a;
    i = _r(c, a, e + 1 / 3), s = _r(c, a, e), o = _r(c, a, e - 1 / 3);
  }
  return {
    red: Math.round(i * 255),
    green: Math.round(s * 255),
    blue: Math.round(o * 255),
    alpha: r
  };
}
const Or = (e, t, n) => {
  const r = e * e;
  return Math.sqrt(Math.max(0, n * (t * t - r) + r));
}, uh = [ei, _t, Ut], fh = (e) => uh.find((t) => t.test(e));
function ns(e) {
  const t = fh(e);
  ot(!!t, `'${e}' is not an animatable color. Use the equivalent color code instead.`);
  let n = t.parse(e);
  return t === Ut && (n = lh(n)), n;
}
const mc = (e, t) => {
  const n = ns(e), r = ns(t), i = { ...n };
  return (s) => (i.red = Or(n.red, r.red, s), i.green = Or(n.green, r.green, s), i.blue = Or(n.blue, r.blue, s), i.alpha = Me(n.alpha, r.alpha, s), _t.transform(i));
};
function gc(e, t) {
  return typeof e == "number" ? (n) => Me(e, t, n) : Ye.test(e) ? mc(e, t) : vc(e, t);
}
const yc = (e, t) => {
  const n = [...e], r = n.length, i = e.map((s, o) => gc(s, t[o]));
  return (s) => {
    for (let o = 0; o < r; o++)
      n[o] = i[o](s);
    return n;
  };
}, dh = (e, t) => {
  const n = { ...e, ...t }, r = {};
  for (const i in n)
    e[i] !== void 0 && t[i] !== void 0 && (r[i] = gc(e[i], t[i]));
  return (i) => {
    for (const s in r)
      n[s] = r[s](i);
    return n;
  };
}, vc = (e, t) => {
  const n = Tt.createTransformer(t), r = Yn(e), i = Yn(t);
  return r.numColors === i.numColors && r.numNumbers >= i.numNumbers ? fr(yc(r.values, i.values), n) : (mr(!0, `Complex values '${e}' and '${t}' too different to mix. Ensure all colors are of the same type, and that each contains the same quantity of number and color values. Falling back to instant transition.`), (o) => `${o > 0 ? t : e}`);
}, Xn = (e, t, n) => {
  const r = t - e;
  return r === 0 ? 1 : (n - e) / r;
}, rs = (e, t) => (n) => Me(e, t, n);
function hh(e) {
  return typeof e == "number" ? rs : typeof e == "string" ? Ye.test(e) ? mc : vc : Array.isArray(e) ? yc : typeof e == "object" ? dh : rs;
}
function ph(e, t, n) {
  const r = [], i = n || hh(e[0]), s = e.length - 1;
  for (let o = 0; o < s; o++) {
    let a = i(e[o], e[o + 1]);
    if (t) {
      const c = Array.isArray(t) ? t[o] : t;
      a = fr(c, a);
    }
    r.push(a);
  }
  return r;
}
function wc(e, t, { clamp: n = !0, ease: r, mixer: i } = {}) {
  const s = e.length;
  ot(s === t.length, "Both input and output ranges must be the same length"), ot(!r || !Array.isArray(r) || r.length === s - 1, "Array of easing functions must be of length `input.length - 1`, as it applies to the transitions **between** the defined values."), e[0] > e[s - 1] && (e = [...e].reverse(), t = [...t].reverse());
  const o = ph(t, r, i), a = o.length, c = (l) => {
    let u = 0;
    if (a > 1)
      for (; u < e.length - 2 && !(l < e[u + 1]); u++)
        ;
    const d = Xn(e[u], e[u + 1], l);
    return o[u](d);
  };
  return n ? (l) => c(Kt(e[0], e[s - 1], l)) : c;
}
const ao = (e) => e, Tc = (e, t, n) => (((1 - 3 * n + 3 * t) * e + (3 * n - 6 * t)) * e + 3 * t) * e, mh = 1e-7, gh = 12;
function yh(e, t, n, r, i) {
  let s, o, a = 0;
  do
    o = t + (n - t) / 2, s = Tc(o, r, i) - e, s > 0 ? n = o : t = o;
  while (Math.abs(s) > mh && ++a < gh);
  return o;
}
function bc(e, t, n, r) {
  if (e === t && n === r)
    return ao;
  const i = (s) => yh(s, 0, 1, e, n);
  return (s) => s === 0 || s === 1 ? s : Tc(i(s), t, r);
}
const Ac = (e) => 1 - Math.sin(Math.acos(e)), co = io(Ac), vh = ro(co), Ec = bc(0.33, 1.53, 0.69, 0.99), lo = io(Ec), wh = ro(lo), Th = (e) => (e *= 2) < 1 ? 0.5 * lo(e) : 0.5 * (2 - Math.pow(2, -10 * (e - 1))), is = {
  linear: ao,
  easeIn: oo,
  easeInOut: so,
  easeOut: ch,
  circIn: Ac,
  circInOut: vh,
  circOut: co,
  backIn: lo,
  backInOut: wh,
  backOut: Ec,
  anticipate: Th
}, os = (e) => {
  if (Array.isArray(e)) {
    ot(e.length === 4, "Cubic bezier arrays must contain four numerical values.");
    const [t, n, r, i] = e;
    return bc(t, n, r, i);
  } else if (typeof e == "string")
    return ot(is[e] !== void 0, `Invalid easing type '${e}'`), is[e];
  return e;
}, bh = (e) => Array.isArray(e) && typeof e[0] != "number";
function Ah(e, t) {
  return e.map(() => t || so).splice(0, e.length - 1);
}
function Eh(e) {
  const t = e.length;
  return e.map((n, r) => r !== 0 ? r / (t - 1) : 0);
}
function Sh(e, t) {
  return e.map((n) => n * t);
}
function ni({ keyframes: e, ease: t = so, times: n, duration: r = 300 }) {
  e = [...e];
  const i = bh(t) ? t.map(os) : os(t), s = {
    done: !1,
    value: e[0]
  }, o = Sh(
    // Only use the provided offsets if they're the correct length
    // TODO Maybe we should warn here if there's a length mismatch
    n && n.length === e.length ? n : Eh(e),
    r
  );
  function a() {
    return wc(o, e, {
      ease: Array.isArray(i) ? i : Ah(e, i)
    });
  }
  let c = a();
  return {
    next: (l) => (s.value = c(l), s.done = l >= r, s),
    flipTarget: () => {
      e.reverse(), c = a();
    }
  };
}
const Rr = 1e-3, xh = 0.01, ss = 10, Ph = 0.05, Ch = 1;
function _h({ duration: e = 800, bounce: t = 0.25, velocity: n = 0, mass: r = 1 }) {
  let i, s;
  mr(e <= ss * 1e3, "Spring duration must be 10 seconds or less");
  let o = 1 - t;
  o = Kt(Ph, Ch, o), e = Kt(xh, ss, e / 1e3), o < 1 ? (i = (l) => {
    const u = l * o, d = u * e, h = u - n, m = ri(l, o), v = Math.exp(-d);
    return Rr - h / m * v;
  }, s = (l) => {
    const d = l * o * e, h = d * n + n, m = Math.pow(o, 2) * Math.pow(l, 2) * e, v = Math.exp(-d), w = ri(Math.pow(l, 2), o);
    return (-i(l) + Rr > 0 ? -1 : 1) * ((h - m) * v) / w;
  }) : (i = (l) => {
    const u = Math.exp(-l * e), d = (l - n) * e + 1;
    return -Rr + u * d;
  }, s = (l) => {
    const u = Math.exp(-l * e), d = (n - l) * (e * e);
    return u * d;
  });
  const a = 5 / e, c = Rh(i, s, a);
  if (e = e * 1e3, isNaN(c))
    return {
      stiffness: 100,
      damping: 10,
      duration: e
    };
  {
    const l = Math.pow(c, 2) * r;
    return {
      stiffness: l,
      damping: o * 2 * Math.sqrt(r * l),
      duration: e
    };
  }
}
const Oh = 12;
function Rh(e, t, n) {
  let r = n;
  for (let i = 1; i < Oh; i++)
    r = r - e(r) / t(r);
  return r;
}
function ri(e, t) {
  return e * Math.sqrt(1 - t * t);
}
const kh = ["duration", "bounce"], Mh = ["stiffness", "damping", "mass"];
function as(e, t) {
  return t.some((n) => e[n] !== void 0);
}
function Ih(e) {
  let t = {
    velocity: 0,
    stiffness: 100,
    damping: 10,
    mass: 1,
    isResolvedFromDuration: !1,
    ...e
  };
  if (!as(e, Mh) && as(e, kh)) {
    const n = _h(e);
    t = {
      ...t,
      ...n,
      velocity: 0,
      mass: 1
    }, t.isResolvedFromDuration = !0;
  }
  return t;
}
const Lh = 5;
function Sc({ keyframes: e, restDelta: t, restSpeed: n, ...r }) {
  let i = e[0], s = e[e.length - 1];
  const o = { done: !1, value: i }, { stiffness: a, damping: c, mass: l, velocity: u, duration: d, isResolvedFromDuration: h } = Ih(r);
  let m = Dh, v = u ? -(u / 1e3) : 0;
  const w = c / (2 * Math.sqrt(a * l));
  function I() {
    const E = s - i, P = Math.sqrt(a / l) / 1e3, M = Math.abs(E) < 5;
    if (n || (n = M ? 0.01 : 2), t || (t = M ? 5e-3 : 0.5), w < 1) {
      const L = ri(P, w);
      m = (T) => {
        const _ = Math.exp(-w * P * T);
        return s - _ * ((v + w * P * E) / L * Math.sin(L * T) + E * Math.cos(L * T));
      };
    } else if (w === 1)
      m = (L) => s - Math.exp(-P * L) * (E + (v + P * E) * L);
    else {
      const L = P * Math.sqrt(w * w - 1);
      m = (T) => {
        const _ = Math.exp(-w * P * T), V = Math.min(L * T, 300);
        return s - _ * ((v + w * P * E) * Math.sinh(V) + L * E * Math.cosh(V)) / L;
      };
    }
  }
  return I(), {
    next: (E) => {
      const P = m(E);
      if (h)
        o.done = E >= d;
      else {
        let M = v;
        if (E !== 0)
          if (w < 1) {
            const _ = Math.max(0, E - Lh);
            M = Qi(P - m(_), E - _);
          } else
            M = 0;
        const L = Math.abs(M) <= n, T = Math.abs(s - P) <= t;
        o.done = L && T;
      }
      return o.value = o.done ? s : P, o;
    },
    flipTarget: () => {
      v = -v, [i, s] = [s, i], I();
    }
  };
}
Sc.needsInterpolation = (e, t) => typeof e == "string" || typeof t == "string";
const Dh = (e) => 0;
function Vh({
  /**
   * The decay animation dynamically calculates an end of the animation
   * based on the initial keyframe, so we only need to define a single keyframe
   * as default.
   */
  keyframes: e = [0],
  velocity: t = 0,
  power: n = 0.8,
  timeConstant: r = 350,
  restDelta: i = 0.5,
  modifyTarget: s
}) {
  const o = e[0], a = { done: !1, value: o };
  let c = n * t;
  const l = o + c, u = s === void 0 ? l : s(l);
  return u !== l && (c = u - o), {
    next: (d) => {
      const h = -c * Math.exp(-d / r);
      return a.done = !(h > i || h < -i), a.value = a.done ? u : u + h, a;
    },
    flipTarget: () => {
    }
  };
}
const Nh = {
  decay: Vh,
  keyframes: ni,
  tween: ni,
  spring: Sc
};
function xc(e, t, n = 0) {
  return e - t - n;
}
function Bh(e, t = 0, n = 0, r = !0) {
  return r ? xc(t + -e, t, n) : t - (e - t) + n;
}
function jh(e, t, n, r) {
  return r ? e >= t + n : e <= -n;
}
const $h = (e) => {
  const t = ({ delta: n }) => e(n);
  return {
    start: () => qe.update(t, !0),
    stop: () => wt.update(t)
  };
};
function Zn({ duration: e, driver: t = $h, elapsed: n = 0, repeat: r = 0, repeatType: i = "loop", repeatDelay: s = 0, keyframes: o, autoplay: a = !0, onPlay: c, onStop: l, onComplete: u, onRepeat: d, onUpdate: h, type: m = "keyframes", ...v }) {
  var w, I;
  const E = n;
  let P, M = 0, L = e, T = !1, _ = !0, V;
  const F = Nh[o.length > 2 ? "keyframes" : m] || ni, W = o[0], N = o[o.length - 1];
  let G = { done: !1, value: W };
  !((I = (w = F).needsInterpolation) === null || I === void 0) && I.call(w, W, N) && (V = wc([0, 100], [W, N], {
    clamp: !1
  }), o = [0, 100]);
  const ne = F({
    ...v,
    duration: e,
    keyframes: o
  });
  function J() {
    M++, i === "reverse" ? (_ = M % 2 === 0, n = Bh(n, L, s, _)) : (n = xc(n, L, s), i === "mirror" && ne.flipTarget()), T = !1, d && d();
  }
  function ue() {
    P && P.stop(), u && u();
  }
  function Q(de) {
    _ || (de = -de), n += de, T || (G = ne.next(Math.max(0, n)), V && (G.value = V(G.value)), T = _ ? G.done : n <= 0), h && h(G.value), T && (M === 0 && (L = L !== void 0 ? L : n), M < r ? jh(n, L, s, _) && J() : ue());
  }
  function ge() {
    c && c(), P = t(Q), P.start();
  }
  return a && ge(), {
    stop: () => {
      l && l(), P && P.stop();
    },
    /**
     * Set the current time of the animation. This is purposefully
     * mirroring the WAAPI animation API to make them interchanagable.
     * Going forward this file should be ported more towards
     * https://github.com/motiondivision/motionone/blob/main/packages/animation/src/Animation.ts
     * Which behaviourally adheres to WAAPI as far as possible.
     *
     * WARNING: This is not safe to use for most animations. We currently
     * only use it for handoff from WAAPI within Framer.
     *
     * This animation function consumes time every frame rather than being sampled for time.
     * So the sample() method performs some headless frames to ensure
     * repeats are handled correctly. Ideally in the future we will replace
     * that method with this, once repeat calculations are pure.
     */
    set currentTime(de) {
      n = E, Q(de);
    },
    /**
     * animate() can't yet be sampled for time, instead it
     * consumes time. So to sample it we have to run a low
     * temporal-resolution version.
     */
    sample: (de) => {
      n = E;
      const Le = e && typeof e == "number" ? Math.max(e * 0.5, 50) : 50;
      let Fe = 0;
      for (Q(0); Fe <= de; ) {
        const j = de - Fe;
        Q(Math.min(j, Le)), Fe += Le;
      }
      return G;
    }
  };
}
function Fh(e) {
  return !e || // Default easing
  Array.isArray(e) || // Bezier curve
  typeof e == "string" && Pc[e];
}
const sn = ([e, t, n, r]) => `cubic-bezier(${e}, ${t}, ${n}, ${r})`, Pc = {
  linear: "linear",
  ease: "ease",
  easeIn: "ease-in",
  easeOut: "ease-out",
  easeInOut: "ease-in-out",
  circIn: sn([0, 0.65, 0.55, 1]),
  circOut: sn([0.55, 0, 1, 0.45]),
  backIn: sn([0.31, 0.01, 0.66, -0.59]),
  backOut: sn([0.33, 1.53, 0.69, 0.99])
};
function Uh(e) {
  if (e)
    return Array.isArray(e) ? sn(e) : Pc[e];
}
function Hh(e, t, n, { delay: r = 0, duration: i, repeat: s = 0, repeatType: o = "loop", ease: a, times: c } = {}) {
  return e.animate({ [t]: n, offset: c }, {
    delay: r,
    duration: i,
    easing: Uh(a),
    fill: "both",
    iterations: s + 1,
    direction: o === "reverse" ? "alternate" : "normal"
  });
}
const cs = {
  waapi: () => Object.hasOwnProperty.call(Element.prototype, "animate")
}, kr = {}, Cc = {};
for (const e in cs)
  Cc[e] = () => (kr[e] === void 0 && (kr[e] = cs[e]()), kr[e]);
function Wh(e, { repeat: t, repeatType: n = "loop" }) {
  const r = t && n !== "loop" && t % 2 === 1 ? 0 : e.length - 1;
  return e[r];
}
const qh = /* @__PURE__ */ new Set(["opacity"]), kn = 10;
function zh(e, t, { onUpdate: n, onComplete: r, ...i }) {
  if (!(Cc.waapi() && qh.has(t) && !i.repeatDelay && i.repeatType !== "mirror" && i.damping !== 0))
    return !1;
  let { keyframes: o, duration: a = 300, elapsed: c = 0, ease: l } = i;
  if (i.type === "spring" || !Fh(i.ease)) {
    if (i.repeat === 1 / 0)
      return;
    const d = Zn({ ...i, elapsed: 0 });
    let h = { done: !1, value: o[0] };
    const m = [];
    let v = 0;
    for (; !h.done && v < 2e4; )
      h = d.sample(v), m.push(h.value), v += kn;
    o = m, a = v - kn, l = "linear";
  }
  const u = Hh(e.owner.current, t, o, {
    ...i,
    delay: -c,
    duration: a,
    /**
     * This function is currently not called if ease is provided
     * as a function so the cast is safe.
     *
     * However it would be possible for a future refinement to port
     * in easing pregeneration from Motion One for browsers that
     * support the upcoming `linear()` easing function.
     */
    ease: l
  });
  return u.onfinish = () => {
    e.set(Wh(o, i)), qe.update(() => u.cancel()), r && r();
  }, {
    get currentTime() {
      return u.currentTime || 0;
    },
    set currentTime(d) {
      u.currentTime = d;
    },
    stop: () => {
      const { currentTime: d } = u;
      if (d) {
        const h = Zn({ ...i, autoplay: !1 });
        e.setWithVelocity(h.sample(d - kn).value, h.sample(d).value, kn);
      }
      qe.update(() => u.cancel());
    }
  };
}
function _c(e, t) {
  const n = performance.now(), r = ({ timestamp: i }) => {
    const s = i - n;
    s >= t && (wt.read(r), e(s - t));
  };
  return qe.read(r, !0), () => wt.read(r);
}
function Kh({ keyframes: e, elapsed: t, onUpdate: n, onComplete: r }) {
  const i = () => {
    n && n(e[e.length - 1]), r && r();
  };
  return t ? { stop: _c(i, -t) } : i();
}
function Yh({ keyframes: e, velocity: t = 0, min: n, max: r, power: i = 0.8, timeConstant: s = 750, bounceStiffness: o = 500, bounceDamping: a = 10, restDelta: c = 1, modifyTarget: l, driver: u, onUpdate: d, onComplete: h, onStop: m }) {
  const v = e[0];
  let w;
  function I(L) {
    return n !== void 0 && L < n || r !== void 0 && L > r;
  }
  function E(L) {
    return n === void 0 ? r : r === void 0 || Math.abs(n - L) < Math.abs(r - L) ? n : r;
  }
  function P(L) {
    w == null || w.stop(), w = Zn({
      keyframes: [0, 1],
      velocity: 0,
      ...L,
      driver: u,
      onUpdate: (T) => {
        var _;
        d == null || d(T), (_ = L.onUpdate) === null || _ === void 0 || _.call(L, T);
      },
      onComplete: h,
      onStop: m
    });
  }
  function M(L) {
    P({
      type: "spring",
      stiffness: o,
      damping: a,
      restDelta: c,
      ...L
    });
  }
  if (I(v))
    M({
      velocity: t,
      keyframes: [v, E(v)]
    });
  else {
    let L = i * t + v;
    typeof l < "u" && (L = l(L));
    const T = E(L), _ = T === n ? -1 : 1;
    let V, F;
    const W = (N) => {
      V = F, F = N, t = Qi(N - V, ht.delta), (_ === 1 && N > T || _ === -1 && N < T) && M({ keyframes: [N, T], velocity: t });
    };
    P({
      type: "decay",
      keyframes: [v, 0],
      velocity: t,
      timeConstant: s,
      power: i,
      restDelta: c,
      modifyTarget: l,
      onUpdate: I(L) ? W : void 0
    });
  }
  return {
    stop: () => w == null ? void 0 : w.stop()
  };
}
const xt = () => ({
  type: "spring",
  stiffness: 500,
  damping: 25,
  restSpeed: 10
}), Mn = (e) => ({
  type: "spring",
  stiffness: 550,
  damping: e === 0 ? 2 * Math.sqrt(550) : 30,
  restSpeed: 10
}), Mr = () => ({
  type: "keyframes",
  ease: "linear",
  duration: 0.3
}), Gh = {
  type: "keyframes",
  duration: 0.8
}, ls = {
  x: xt,
  y: xt,
  z: xt,
  rotate: xt,
  rotateX: xt,
  rotateY: xt,
  rotateZ: xt,
  scaleX: Mn,
  scaleY: Mn,
  scale: Mn,
  opacity: Mr,
  backgroundColor: Mr,
  color: Mr,
  default: Mn
}, Xh = (e, { keyframes: t }) => t.length > 2 ? Gh : (ls[e] || ls.default)(t[1]), ii = (e, t) => e === "zIndex" ? !1 : !!(typeof t == "number" || Array.isArray(t) || typeof t == "string" && // It's animatable if we have a string
Tt.test(t) && // And it contains numbers and/or colors
!t.startsWith("url("));
function Zh({ when: e, delay: t, delayChildren: n, staggerChildren: r, staggerDirection: i, repeat: s, repeatType: o, repeatDelay: a, from: c, elapsed: l, ...u }) {
  return !!Object.keys(u).length;
}
function us(e) {
  return e === 0 || typeof e == "string" && parseFloat(e) === 0 && e.indexOf(" ") === -1;
}
function fs(e) {
  return typeof e == "number" ? 0 : no("", e);
}
function Oc(e, t) {
  return e[t] || e.default || e;
}
function Jh(e, t, n, r) {
  const i = ii(t, n);
  let s = r.from !== void 0 ? r.from : e.get();
  return s === "none" && i && typeof n == "string" ? s = no(t, n) : us(s) && typeof n == "string" ? s = fs(n) : !Array.isArray(n) && us(n) && typeof s == "string" && (n = fs(s)), Array.isArray(n) ? (n[0] === null && (n[0] = s), n) : [s, n];
}
const uo = (e, t, n, r = {}) => (i) => {
  const s = Oc(r, e) || {}, o = s.delay || r.delay || 0;
  let { elapsed: a = 0 } = r;
  a = a - Bn(o);
  const c = Jh(t, e, n, s), l = c[0], u = c[c.length - 1], d = ii(e, l), h = ii(e, u);
  mr(d === h, `You are trying to animate ${e} from "${l}" to "${u}". ${l} is not an animatable value - to enable this animation set ${l} to a value animatable to ${u} via the \`style\` property.`);
  let m = {
    keyframes: c,
    velocity: t.getVelocity(),
    ...s,
    elapsed: a,
    onUpdate: (I) => {
      t.set(I), s.onUpdate && s.onUpdate(I);
    },
    onComplete: () => {
      i(), s.onComplete && s.onComplete();
    }
  };
  if (!d || !h || ah.current || s.type === !1)
    return Kh(m);
  if (s.type === "inertia")
    return Yh(m);
  Zh(s) || (m = {
    ...m,
    ...Xh(e, m)
  }), m.duration && (m.duration = Bn(m.duration)), m.repeatDelay && (m.repeatDelay = Bn(m.repeatDelay));
  const v = t.owner, w = v && v.current;
  if (v && w instanceof HTMLElement && !(v != null && v.getProps().onUpdate)) {
    const I = zh(t, e, m);
    if (I)
      return I;
  }
  return Zn(m);
};
function Qh(e, t, n = {}) {
  e.notify("AnimationStart", t);
  let r;
  if (Array.isArray(t)) {
    const i = t.map((s) => oi(e, s, n));
    r = Promise.all(i);
  } else if (typeof t == "string")
    r = oi(e, t, n);
  else {
    const i = typeof t == "function" ? pr(e, t, n.custom) : t;
    r = Rc(e, i, n);
  }
  return r.then(() => e.notify("AnimationComplete", t));
}
function oi(e, t, n = {}) {
  var r;
  const i = pr(e, t, n.custom);
  let { transition: s = e.getDefaultTransition() || {} } = i || {};
  n.transitionOverride && (s = n.transitionOverride);
  const o = i ? () => Rc(e, i, n) : () => Promise.resolve(), a = !((r = e.variantChildren) === null || r === void 0) && r.size ? (l = 0) => {
    const { delayChildren: u = 0, staggerChildren: d, staggerDirection: h } = s;
    return ep(e, t, u + l, d, h, n);
  } : () => Promise.resolve(), { when: c } = s;
  if (c) {
    const [l, u] = c === "beforeChildren" ? [o, a] : [a, o];
    return l().then(u);
  } else
    return Promise.all([o(), a(n.delay)]);
}
function Rc(e, t, { delay: n = 0, transitionOverride: r, type: i } = {}) {
  var s;
  let { transition: o = e.getDefaultTransition(), transitionEnd: a, ...c } = e.makeTargetAnimatable(t);
  const l = e.getValue("willChange");
  r && (o = r);
  const u = [], d = i && ((s = e.animationState) === null || s === void 0 ? void 0 : s.getState()[i]);
  for (const h in c) {
    const m = e.getValue(h), v = c[h];
    if (!m || v === void 0 || d && np(d, h))
      continue;
    const w = { delay: n, elapsed: 0, ...o };
    if (window.HandoffAppearAnimations && !m.hasAnimated) {
      const E = e.getProps()[sh];
      E && (w.elapsed = window.HandoffAppearAnimations(E, h, m, qe));
    }
    let I = m.start(uo(h, m, v, e.shouldReduceMotion && Gt.has(h) ? { type: !1 } : w));
    Gn(l) && (l.add(h), I = I.then(() => l.remove(h))), u.push(I);
  }
  return Promise.all(u).then(() => {
    a && th(e, a);
  });
}
function ep(e, t, n = 0, r = 0, i = 1, s) {
  const o = [], a = (e.variantChildren.size - 1) * r, c = i === 1 ? (l = 0) => l * r : (l = 0) => a - l * r;
  return Array.from(e.variantChildren).sort(tp).forEach((l, u) => {
    l.notify("AnimationStart", t), o.push(oi(l, t, {
      ...s,
      delay: n + c(u)
    }).then(() => l.notify("AnimationComplete", t)));
  }), Promise.all(o);
}
function tp(e, t) {
  return e.sortNodePosition(t);
}
function np({ protectedKeys: e, needsAnimating: t }, n) {
  const r = e.hasOwnProperty(n) && t[n] !== !0;
  return t[n] = !1, r;
}
const fo = [
  Pe.Animate,
  Pe.InView,
  Pe.Focus,
  Pe.Hover,
  Pe.Tap,
  Pe.Drag,
  Pe.Exit
], rp = [...fo].reverse(), ip = fo.length;
function op(e) {
  return (t) => Promise.all(t.map(({ animation: n, options: r }) => Qh(e, n, r)));
}
function sp(e) {
  let t = op(e);
  const n = cp();
  let r = !0;
  const i = (c, l) => {
    const u = pr(e, l);
    if (u) {
      const { transition: d, transitionEnd: h, ...m } = u;
      c = { ...c, ...m, ...h };
    }
    return c;
  };
  function s(c) {
    t = c(e);
  }
  function o(c, l) {
    const u = e.getProps(), d = e.getVariantContext(!0) || {}, h = [], m = /* @__PURE__ */ new Set();
    let v = {}, w = 1 / 0;
    for (let E = 0; E < ip; E++) {
      const P = rp[E], M = n[P], L = u[P] !== void 0 ? u[P] : d[P], T = pn(L), _ = P === l ? M.isActive : null;
      _ === !1 && (w = E);
      let V = L === d[P] && L !== u[P] && T;
      if (V && r && e.manuallyAnimateOnMount && (V = !1), M.protectedKeys = { ...v }, // If it isn't active and hasn't *just* been set as inactive
      !M.isActive && _ === null || // If we didn't and don't have any defined prop for this animation type
      !L && !M.prevProp || // Or if the prop doesn't define an animation
      ar(L) || typeof L == "boolean")
        continue;
      const F = ap(M.prevProp, L);
      let W = F || // If we're making this variant active, we want to always make it active
      P === l && M.isActive && !V && T || // If we removed a higher-priority variant (i is in reverse order)
      E > w && T;
      const N = Array.isArray(L) ? L : [L];
      let G = N.reduce(i, {});
      _ === !1 && (G = {});
      const { prevResolvedValues: ne = {} } = M, J = {
        ...ne,
        ...G
      }, ue = (Q) => {
        W = !0, m.delete(Q), M.needsAnimating[Q] = !0;
      };
      for (const Q in J) {
        const ge = G[Q], de = ne[Q];
        v.hasOwnProperty(Q) || (ge !== de ? zn(ge) && zn(de) ? !ic(ge, de) || F ? ue(Q) : M.protectedKeys[Q] = !0 : ge !== void 0 ? ue(Q) : m.add(Q) : ge !== void 0 && m.has(Q) ? ue(Q) : M.protectedKeys[Q] = !0);
      }
      M.prevProp = L, M.prevResolvedValues = G, M.isActive && (v = { ...v, ...G }), r && e.blockInitialAnimation && (W = !1), W && !V && h.push(...N.map((Q) => ({
        animation: Q,
        options: { type: P, ...c }
      })));
    }
    if (m.size) {
      const E = {};
      m.forEach((P) => {
        const M = e.getBaseTarget(P);
        M !== void 0 && (E[P] = M);
      }), h.push({ animation: E });
    }
    let I = !!h.length;
    return r && u.initial === !1 && !e.manuallyAnimateOnMount && (I = !1), r = !1, I ? t(h) : Promise.resolve();
  }
  function a(c, l, u) {
    var d;
    if (n[c].isActive === l)
      return Promise.resolve();
    (d = e.variantChildren) === null || d === void 0 || d.forEach((m) => {
      var v;
      return (v = m.animationState) === null || v === void 0 ? void 0 : v.setActive(c, l);
    }), n[c].isActive = l;
    const h = o(u, c);
    for (const m in n)
      n[m].protectedKeys = {};
    return h;
  }
  return {
    animateChanges: o,
    setActive: a,
    setAnimateFunction: s,
    getState: () => n
  };
}
function ap(e, t) {
  return typeof t == "string" ? t !== e : Array.isArray(t) ? !ic(t, e) : !1;
}
function Pt(e = !1) {
  return {
    isActive: e,
    protectedKeys: {},
    needsAnimating: {},
    prevResolvedValues: {}
  };
}
function cp() {
  return {
    [Pe.Animate]: Pt(!0),
    [Pe.InView]: Pt(),
    [Pe.Hover]: Pt(),
    [Pe.Tap]: Pt(),
    [Pe.Drag]: Pt(),
    [Pe.Focus]: Pt(),
    [Pe.Exit]: Pt()
  };
}
const lp = {
  animation: yt(({ visualElement: e, animate: t }) => {
    e.animationState || (e.animationState = sp(e)), ar(t) && Te(() => t.subscribe(e), [t]);
  }),
  exit: yt((e) => {
    const { custom: t, visualElement: n } = e, [r, i] = rc(), s = $e(An);
    Te(() => {
      n.isPresent = r;
      const o = n.animationState && n.animationState.setActive(Pe.Exit, !r, {
        custom: s && s.custom || t
      });
      o && !r && o.then(i);
    }, [r]);
  })
}, ds = (e, t) => Math.abs(e - t);
function up(e, t) {
  const n = ds(e.x, t.x), r = ds(e.y, t.y);
  return Math.sqrt(n ** 2 + r ** 2);
}
class kc {
  constructor(t, n, { transformPagePoint: r } = {}) {
    if (this.startEvent = null, this.lastMoveEvent = null, this.lastMoveEventInfo = null, this.handlers = {}, this.updatePoint = () => {
      if (!(this.lastMoveEvent && this.lastMoveEventInfo))
        return;
      const l = Lr(this.lastMoveEventInfo, this.history), u = this.startEvent !== null, d = up(l.offset, { x: 0, y: 0 }) >= 3;
      if (!u && !d)
        return;
      const { point: h } = l, { timestamp: m } = ht;
      this.history.push({ ...h, timestamp: m });
      const { onStart: v, onMove: w } = this.handlers;
      u || (v && v(this.lastMoveEvent, l), this.startEvent = this.lastMoveEvent), w && w(this.lastMoveEvent, l);
    }, this.handlePointerMove = (l, u) => {
      this.lastMoveEvent = l, this.lastMoveEventInfo = Ir(u, this.transformPagePoint), qe.update(this.updatePoint, !0);
    }, this.handlePointerUp = (l, u) => {
      if (this.end(), !(this.lastMoveEvent && this.lastMoveEventInfo))
        return;
      const { onEnd: d, onSessionEnd: h } = this.handlers, m = Lr(l.type === "pointercancel" ? this.lastMoveEventInfo : Ir(u, this.transformPagePoint), this.history);
      this.startEvent && d && d(l, m), h && h(l, m);
    }, !Za(t))
      return;
    this.handlers = n, this.transformPagePoint = r;
    const i = Yi(t), s = Ir(i, this.transformPagePoint), { point: o } = s, { timestamp: a } = ht;
    this.history = [{ ...o, timestamp: a }];
    const { onSessionStart: c } = n;
    c && c(t, Lr(s, this.history)), this.removeListeners = fr(qt(window, "pointermove", this.handlePointerMove), qt(window, "pointerup", this.handlePointerUp), qt(window, "pointercancel", this.handlePointerUp));
  }
  updateHandlers(t) {
    this.handlers = t;
  }
  end() {
    this.removeListeners && this.removeListeners(), wt.update(this.updatePoint);
  }
}
function Ir(e, t) {
  return t ? { point: t(e.point) } : e;
}
function hs(e, t) {
  return { x: e.x - t.x, y: e.y - t.y };
}
function Lr({ point: e }, t) {
  return {
    point: e,
    delta: hs(e, Mc(t)),
    offset: hs(e, fp(t)),
    velocity: dp(t, 0.1)
  };
}
function fp(e) {
  return e[0];
}
function Mc(e) {
  return e[e.length - 1];
}
function dp(e, t) {
  if (e.length < 2)
    return { x: 0, y: 0 };
  let n = e.length - 1, r = null;
  const i = Mc(e);
  for (; n >= 0 && (r = e[n], !(i.timestamp - r.timestamp > Bn(t))); )
    n--;
  if (!r)
    return { x: 0, y: 0 };
  const s = (i.timestamp - r.timestamp) / 1e3;
  if (s === 0)
    return { x: 0, y: 0 };
  const o = {
    x: (i.x - r.x) / s,
    y: (i.y - r.y) / s
  };
  return o.x === 1 / 0 && (o.x = 0), o.y === 1 / 0 && (o.y = 0), o;
}
function Je(e) {
  return e.max - e.min;
}
function si(e, t = 0, n = 0.01) {
  return Math.abs(e - t) <= n;
}
function ps(e, t, n, r = 0.5) {
  e.origin = r, e.originPoint = Me(t.min, t.max, e.origin), e.scale = Je(n) / Je(t), (si(e.scale, 1, 1e-4) || isNaN(e.scale)) && (e.scale = 1), e.translate = Me(n.min, n.max, e.origin) - e.originPoint, (si(e.translate) || isNaN(e.translate)) && (e.translate = 0);
}
function un(e, t, n, r) {
  ps(e.x, t.x, n.x, r == null ? void 0 : r.originX), ps(e.y, t.y, n.y, r == null ? void 0 : r.originY);
}
function ms(e, t, n) {
  e.min = n.min + t.min, e.max = e.min + Je(t);
}
function hp(e, t, n) {
  ms(e.x, t.x, n.x), ms(e.y, t.y, n.y);
}
function gs(e, t, n) {
  e.min = t.min - n.min, e.max = e.min + Je(t);
}
function fn(e, t, n) {
  gs(e.x, t.x, n.x), gs(e.y, t.y, n.y);
}
function pp(e, { min: t, max: n }, r) {
  return t !== void 0 && e < t ? e = r ? Me(t, e, r.min) : Math.max(e, t) : n !== void 0 && e > n && (e = r ? Me(n, e, r.max) : Math.min(e, n)), e;
}
function ys(e, t, n) {
  return {
    min: t !== void 0 ? e.min + t : void 0,
    max: n !== void 0 ? e.max + n - (e.max - e.min) : void 0
  };
}
function mp(e, { top: t, left: n, bottom: r, right: i }) {
  return {
    x: ys(e.x, n, i),
    y: ys(e.y, t, r)
  };
}
function vs(e, t) {
  let n = t.min - e.min, r = t.max - e.max;
  return t.max - t.min < e.max - e.min && ([n, r] = [r, n]), { min: n, max: r };
}
function gp(e, t) {
  return {
    x: vs(e.x, t.x),
    y: vs(e.y, t.y)
  };
}
function yp(e, t) {
  let n = 0.5;
  const r = Je(e), i = Je(t);
  return i > r ? n = Xn(t.min, t.max - r, e.min) : r > i && (n = Xn(e.min, e.max - i, t.min)), Kt(0, 1, n);
}
function vp(e, t) {
  const n = {};
  return t.min !== void 0 && (n.min = t.min - e.min), t.max !== void 0 && (n.max = t.max - e.min), n;
}
const ai = 0.35;
function wp(e = ai) {
  return e === !1 ? e = 0 : e === !0 && (e = ai), {
    x: ws(e, "left", "right"),
    y: ws(e, "top", "bottom")
  };
}
function ws(e, t, n) {
  return {
    min: Ts(e, t),
    max: Ts(e, n)
  };
}
function Ts(e, t) {
  return typeof e == "number" ? e : e[t] || 0;
}
const bs = () => ({
  translate: 0,
  scale: 1,
  origin: 0,
  originPoint: 0
}), dn = () => ({
  x: bs(),
  y: bs()
}), As = () => ({ min: 0, max: 0 }), Ne = () => ({
  x: As(),
  y: As()
});
function st(e) {
  return [e("x"), e("y")];
}
function Ic({ top: e, left: t, right: n, bottom: r }) {
  return {
    x: { min: t, max: n },
    y: { min: e, max: r }
  };
}
function Tp({ x: e, y: t }) {
  return { top: t.min, right: e.max, bottom: t.max, left: e.min };
}
function bp(e, t) {
  if (!t)
    return e;
  const n = t({ x: e.left, y: e.top }), r = t({ x: e.right, y: e.bottom });
  return {
    top: n.y,
    left: n.x,
    bottom: r.y,
    right: r.x
  };
}
function Dr(e) {
  return e === void 0 || e === 1;
}
function ci({ scale: e, scaleX: t, scaleY: n }) {
  return !Dr(e) || !Dr(t) || !Dr(n);
}
function Ct(e) {
  return ci(e) || Lc(e) || e.z || e.rotate || e.rotateX || e.rotateY;
}
function Lc(e) {
  return Es(e.x) || Es(e.y);
}
function Es(e) {
  return e && e !== "0%";
}
function Jn(e, t, n) {
  const r = e - n, i = t * r;
  return n + i;
}
function Ss(e, t, n, r, i) {
  return i !== void 0 && (e = Jn(e, i, r)), Jn(e, n, r) + t;
}
function li(e, t = 0, n = 1, r, i) {
  e.min = Ss(e.min, t, n, r, i), e.max = Ss(e.max, t, n, r, i);
}
function Dc(e, { x: t, y: n }) {
  li(e.x, t.translate, t.scale, t.originPoint), li(e.y, n.translate, n.scale, n.originPoint);
}
function Ap(e, t, n, r = !1) {
  var i, s;
  const o = n.length;
  if (!o)
    return;
  t.x = t.y = 1;
  let a, c;
  for (let l = 0; l < o; l++)
    a = n[l], c = a.projectionDelta, ((s = (i = a.instance) === null || i === void 0 ? void 0 : i.style) === null || s === void 0 ? void 0 : s.display) !== "contents" && (r && a.options.layoutScroll && a.scroll && a !== a.root && Ht(e, {
      x: -a.scroll.offset.x,
      y: -a.scroll.offset.y
    }), c && (t.x *= c.x.scale, t.y *= c.y.scale, Dc(e, c)), r && Ct(a.latestValues) && Ht(e, a.latestValues));
  t.x = xs(t.x), t.y = xs(t.y);
}
function xs(e) {
  return Number.isInteger(e) || e > 1.0000000000001 || e < 0.999999999999 ? e : 1;
}
function gt(e, t) {
  e.min = e.min + t, e.max = e.max + t;
}
function Ps(e, t, [n, r, i]) {
  const s = t[i] !== void 0 ? t[i] : 0.5, o = Me(e.min, e.max, s);
  li(e, t[n], t[r], o, t.scale);
}
const Ep = ["x", "scaleX", "originX"], Sp = ["y", "scaleY", "originY"];
function Ht(e, t) {
  Ps(e.x, t, Ep), Ps(e.y, t, Sp);
}
function Vc(e, t) {
  return Ic(bp(e.getBoundingClientRect(), t));
}
function xp(e, t, n) {
  const r = Vc(e, n), { scroll: i } = t;
  return i && (gt(r.x, i.offset.x), gt(r.y, i.offset.y)), r;
}
const Pp = /* @__PURE__ */ new WeakMap();
class Cp {
  constructor(t) {
    this.openGlobalLock = null, this.isDragging = !1, this.currentDirection = null, this.originPoint = { x: 0, y: 0 }, this.constraints = !1, this.hasMutatedConstraints = !1, this.elastic = Ne(), this.visualElement = t;
  }
  start(t, { snapToCursor: n = !1 } = {}) {
    if (this.visualElement.isPresent === !1)
      return;
    const r = (a) => {
      this.stopAnimation(), n && this.snapToCursor(Yi(a, "page").point);
    }, i = (a, c) => {
      var l;
      const { drag: u, dragPropagation: d, onDragStart: h } = this.getProps();
      u && !d && (this.openGlobalLock && this.openGlobalLock(), this.openGlobalLock = ec(u), !this.openGlobalLock) || (this.isDragging = !0, this.currentDirection = null, this.resolveConstraints(), this.visualElement.projection && (this.visualElement.projection.isAnimationBlocked = !0, this.visualElement.projection.target = void 0), st((m) => {
        var v, w;
        let I = this.getAxisMotionValue(m).get() || 0;
        if (ct.test(I)) {
          const E = (w = (v = this.visualElement.projection) === null || v === void 0 ? void 0 : v.layout) === null || w === void 0 ? void 0 : w.layoutBox[m];
          E && (I = Je(E) * (parseFloat(I) / 100));
        }
        this.originPoint[m] = I;
      }), h == null || h(a, c), (l = this.visualElement.animationState) === null || l === void 0 || l.setActive(Pe.Drag, !0));
    }, s = (a, c) => {
      const { dragPropagation: l, dragDirectionLock: u, onDirectionLock: d, onDrag: h } = this.getProps();
      if (!l && !this.openGlobalLock)
        return;
      const { offset: m } = c;
      if (u && this.currentDirection === null) {
        this.currentDirection = _p(m), this.currentDirection !== null && (d == null || d(this.currentDirection));
        return;
      }
      this.updateAxis("x", c.point, m), this.updateAxis("y", c.point, m), this.visualElement.render(), h == null || h(a, c);
    }, o = (a, c) => this.stop(a, c);
    this.panSession = new kc(t, {
      onSessionStart: r,
      onStart: i,
      onMove: s,
      onSessionEnd: o
    }, { transformPagePoint: this.visualElement.getTransformPagePoint() });
  }
  stop(t, n) {
    const r = this.isDragging;
    if (this.cancel(), !r)
      return;
    const { velocity: i } = n;
    this.startAnimation(i);
    const { onDragEnd: s } = this.getProps();
    s == null || s(t, n);
  }
  cancel() {
    var t, n;
    this.isDragging = !1, this.visualElement.projection && (this.visualElement.projection.isAnimationBlocked = !1), (t = this.panSession) === null || t === void 0 || t.end(), this.panSession = void 0;
    const { dragPropagation: r } = this.getProps();
    !r && this.openGlobalLock && (this.openGlobalLock(), this.openGlobalLock = null), (n = this.visualElement.animationState) === null || n === void 0 || n.setActive(Pe.Drag, !1);
  }
  updateAxis(t, n, r) {
    const { drag: i } = this.getProps();
    if (!r || !In(t, i, this.currentDirection))
      return;
    const s = this.getAxisMotionValue(t);
    let o = this.originPoint[t] + r[t];
    this.constraints && this.constraints[t] && (o = pp(o, this.constraints[t], this.elastic[t])), s.set(o);
  }
  resolveConstraints() {
    const { dragConstraints: t, dragElastic: n } = this.getProps(), { layout: r } = this.visualElement.projection || {}, i = this.constraints;
    t && Ft(t) ? this.constraints || (this.constraints = this.resolveRefConstraints()) : t && r ? this.constraints = mp(r.layoutBox, t) : this.constraints = !1, this.elastic = wp(n), i !== this.constraints && r && this.constraints && !this.hasMutatedConstraints && st((s) => {
      this.getAxisMotionValue(s) && (this.constraints[s] = vp(r.layoutBox[s], this.constraints[s]));
    });
  }
  resolveRefConstraints() {
    const { dragConstraints: t, onMeasureDragConstraints: n } = this.getProps();
    if (!t || !Ft(t))
      return !1;
    const r = t.current;
    ot(r !== null, "If `dragConstraints` is set as a React ref, that ref must be passed to another component's `ref` prop.");
    const { projection: i } = this.visualElement;
    if (!i || !i.layout)
      return !1;
    const s = xp(r, i.root, this.visualElement.getTransformPagePoint());
    let o = gp(i.layout.layoutBox, s);
    if (n) {
      const a = n(Tp(o));
      this.hasMutatedConstraints = !!a, a && (o = Ic(a));
    }
    return o;
  }
  startAnimation(t) {
    const { drag: n, dragMomentum: r, dragElastic: i, dragTransition: s, dragSnapToOrigin: o, onDragTransitionEnd: a } = this.getProps(), c = this.constraints || {}, l = st((u) => {
      if (!In(u, n, this.currentDirection))
        return;
      let d = (c == null ? void 0 : c[u]) || {};
      o && (d = { min: 0, max: 0 });
      const h = i ? 200 : 1e6, m = i ? 40 : 1e7, v = {
        type: "inertia",
        velocity: r ? t[u] : 0,
        bounceStiffness: h,
        bounceDamping: m,
        timeConstant: 750,
        restDelta: 1,
        restSpeed: 10,
        ...s,
        ...d
      };
      return this.startAxisValueAnimation(u, v);
    });
    return Promise.all(l).then(a);
  }
  startAxisValueAnimation(t, n) {
    const r = this.getAxisMotionValue(t);
    return r.start(uo(t, r, 0, n));
  }
  stopAnimation() {
    st((t) => this.getAxisMotionValue(t).stop());
  }
  /**
   * Drag works differently depending on which props are provided.
   *
   * - If _dragX and _dragY are provided, we output the gesture delta directly to those motion values.
   * - Otherwise, we apply the delta to the x/y motion values.
   */
  getAxisMotionValue(t) {
    var n;
    const r = "_drag" + t.toUpperCase(), i = this.visualElement.getProps()[r];
    return i || this.visualElement.getValue(t, ((n = this.visualElement.getProps().initial) === null || n === void 0 ? void 0 : n[t]) || 0);
  }
  snapToCursor(t) {
    st((n) => {
      const { drag: r } = this.getProps();
      if (!In(n, r, this.currentDirection))
        return;
      const { projection: i } = this.visualElement, s = this.getAxisMotionValue(n);
      if (i && i.layout) {
        const { min: o, max: a } = i.layout.layoutBox[n];
        s.set(t[n] - Me(o, a, 0.5));
      }
    });
  }
  /**
   * When the viewport resizes we want to check if the measured constraints
   * have changed and, if so, reposition the element within those new constraints
   * relative to where it was before the resize.
   */
  scalePositionWithinConstraints() {
    var t;
    if (!this.visualElement.current)
      return;
    const { drag: n, dragConstraints: r } = this.getProps(), { projection: i } = this.visualElement;
    if (!Ft(r) || !i || !this.constraints)
      return;
    this.stopAnimation();
    const s = { x: 0, y: 0 };
    st((a) => {
      const c = this.getAxisMotionValue(a);
      if (c) {
        const l = c.get();
        s[a] = yp({ min: l, max: l }, this.constraints[a]);
      }
    });
    const { transformTemplate: o } = this.visualElement.getProps();
    this.visualElement.current.style.transform = o ? o({}, "") : "none", (t = i.root) === null || t === void 0 || t.updateScroll(), i.updateLayout(), this.resolveConstraints(), st((a) => {
      if (!In(a, n, null))
        return;
      const c = this.getAxisMotionValue(a), { min: l, max: u } = this.constraints[a];
      c.set(Me(l, u, s[a]));
    });
  }
  addListeners() {
    var t;
    if (!this.visualElement.current)
      return;
    Pp.set(this.visualElement, this);
    const n = this.visualElement.current, r = qt(n, "pointerdown", (l) => {
      const { drag: u, dragListener: d = !0 } = this.getProps();
      u && d && this.start(l);
    }), i = () => {
      const { dragConstraints: l } = this.getProps();
      Ft(l) && (this.constraints = this.resolveRefConstraints());
    }, { projection: s } = this.visualElement, o = s.addEventListener("measure", i);
    s && !s.layout && ((t = s.root) === null || t === void 0 || t.updateScroll(), s.updateLayout()), i();
    const a = ur(window, "resize", () => this.scalePositionWithinConstraints()), c = s.addEventListener("didUpdate", ({ delta: l, hasLayoutChanged: u }) => {
      this.isDragging && u && (st((d) => {
        const h = this.getAxisMotionValue(d);
        h && (this.originPoint[d] += l[d].translate, h.set(h.get() + l[d].translate));
      }), this.visualElement.render());
    });
    return () => {
      a(), r(), o(), c == null || c();
    };
  }
  getProps() {
    const t = this.visualElement.getProps(), { drag: n = !1, dragDirectionLock: r = !1, dragPropagation: i = !1, dragConstraints: s = !1, dragElastic: o = ai, dragMomentum: a = !0 } = t;
    return {
      ...t,
      drag: n,
      dragDirectionLock: r,
      dragPropagation: i,
      dragConstraints: s,
      dragElastic: o,
      dragMomentum: a
    };
  }
}
function In(e, t, n) {
  return (t === !0 || t === e) && (n === null || n === e);
}
function _p(e, t = 10) {
  let n = null;
  return Math.abs(e.y) > t ? n = "y" : Math.abs(e.x) > t && (n = "x"), n;
}
function Op(e) {
  const { dragControls: t, visualElement: n } = e, r = lr(() => new Cp(n));
  Te(() => t && t.subscribe(r), [r, t]), Te(() => r.addListeners(), [r]);
}
function Rp({ onPan: e, onPanStart: t, onPanEnd: n, onPanSessionStart: r, visualElement: i }) {
  const s = e || t || n || r, o = nt(null), { transformPagePoint: a } = $e(Bi), c = {
    onSessionStart: r,
    onStart: t,
    onMove: e,
    onEnd: (u, d) => {
      o.current = null, n && n(u, d);
    }
  };
  Te(() => {
    o.current !== null && o.current.updateHandlers(c);
  });
  function l(u) {
    o.current = new kc(u, c, {
      transformPagePoint: a
    });
  }
  Kn(i, "pointerdown", s && l), Gi(() => o.current && o.current.end());
}
const kp = {
  pan: yt(Rp),
  drag: yt(Op)
};
function ui(e) {
  return typeof e == "string" && e.startsWith("var(--");
}
const Nc = /var\((--[a-zA-Z0-9-_]+),? ?([a-zA-Z0-9 ()%#.,-]+)?\)/;
function Mp(e) {
  const t = Nc.exec(e);
  if (!t)
    return [,];
  const [, n, r] = t;
  return [n, r];
}
const Ip = 4;
function fi(e, t, n = 1) {
  ot(n <= Ip, `Max CSS variable fallback depth detected in property "${e}". This may indicate a circular fallback dependency.`);
  const [r, i] = Mp(e);
  if (!r)
    return;
  const s = window.getComputedStyle(t).getPropertyValue(r);
  return s ? s.trim() : ui(i) ? fi(i, t, n + 1) : i;
}
function Lp(e, { ...t }, n) {
  const r = e.current;
  if (!(r instanceof Element))
    return { target: t, transitionEnd: n };
  n && (n = { ...n }), e.values.forEach((i) => {
    const s = i.get();
    if (!ui(s))
      return;
    const o = fi(s, r);
    o && i.set(o);
  });
  for (const i in t) {
    const s = t[i];
    if (!ui(s))
      continue;
    const o = fi(s, r);
    o && (t[i] = o, n && n[i] === void 0 && (n[i] = s));
  }
  return { target: t, transitionEnd: n };
}
const Dp = /* @__PURE__ */ new Set([
  "width",
  "height",
  "top",
  "left",
  "right",
  "bottom",
  "x",
  "y"
]), Bc = (e) => Dp.has(e), Vp = (e) => Object.keys(e).some(Bc), Ln = (e) => e === Mt || e === Z;
var Cs;
(function(e) {
  e.width = "width", e.height = "height", e.left = "left", e.right = "right", e.top = "top", e.bottom = "bottom";
})(Cs || (Cs = {}));
const _s = (e, t) => parseFloat(e.split(", ")[t]), Os = (e, t) => (n, { transform: r }) => {
  if (r === "none" || !r)
    return 0;
  const i = r.match(/^matrix3d\((.+)\)$/);
  if (i)
    return _s(i[1], t);
  {
    const s = r.match(/^matrix\((.+)\)$/);
    return s ? _s(s[1], e) : 0;
  }
}, Np = /* @__PURE__ */ new Set(["x", "y", "z"]), Bp = Wn.filter((e) => !Np.has(e));
function jp(e) {
  const t = [];
  return Bp.forEach((n) => {
    const r = e.getValue(n);
    r !== void 0 && (t.push([n, r.get()]), r.set(n.startsWith("scale") ? 1 : 0));
  }), t.length && e.render(), t;
}
const Rs = {
  // Dimensions
  width: ({ x: e }, { paddingLeft: t = "0", paddingRight: n = "0" }) => e.max - e.min - parseFloat(t) - parseFloat(n),
  height: ({ y: e }, { paddingTop: t = "0", paddingBottom: n = "0" }) => e.max - e.min - parseFloat(t) - parseFloat(n),
  top: (e, { top: t }) => parseFloat(t),
  left: (e, { left: t }) => parseFloat(t),
  bottom: ({ y: e }, { top: t }) => parseFloat(t) + (e.max - e.min),
  right: ({ x: e }, { left: t }) => parseFloat(t) + (e.max - e.min),
  // Transform
  x: Os(4, 13),
  y: Os(5, 14)
}, $p = (e, t, n) => {
  const r = t.measureViewportBox(), i = t.current, s = getComputedStyle(i), { display: o } = s, a = {};
  o === "none" && t.setStaticValue("display", e.display || "block"), n.forEach((l) => {
    a[l] = Rs[l](r, s);
  }), t.render();
  const c = t.measureViewportBox();
  return n.forEach((l) => {
    const u = t.getValue(l);
    u && u.jump(a[l]), e[l] = Rs[l](c, s);
  }), e;
}, Fp = (e, t, n = {}, r = {}) => {
  t = { ...t }, r = { ...r };
  const i = Object.keys(t).filter(Bc);
  let s = [], o = !1;
  const a = [];
  if (i.forEach((c) => {
    const l = e.getValue(c);
    if (!e.hasValue(c))
      return;
    let u = n[c], d = tn(u);
    const h = t[c];
    let m;
    if (zn(h)) {
      const v = h.length, w = h[0] === null ? 1 : 0;
      u = h[w], d = tn(u);
      for (let I = w; I < v; I++)
        m ? ot(tn(h[I]) === m, "All keyframes must be of the same type") : (m = tn(h[I]), ot(m === d || Ln(d) && Ln(m), "Keyframes must be of the same dimension as the current value"));
    } else
      m = tn(h);
    if (d !== m)
      if (Ln(d) && Ln(m)) {
        const v = l.get();
        typeof v == "string" && l.set(parseFloat(v)), typeof h == "string" ? t[c] = parseFloat(h) : Array.isArray(h) && m === Z && (t[c] = h.map(parseFloat));
      } else
        d != null && d.transform && (m != null && m.transform) && (u === 0 || h === 0) ? u === 0 ? l.set(m.transform(u)) : t[c] = d.transform(h) : (o || (s = jp(e), o = !0), a.push(c), r[c] = r[c] !== void 0 ? r[c] : t[c], l.jump(h));
  }), a.length) {
    const c = a.indexOf("height") >= 0 ? window.pageYOffset : null, l = $p(t, e, a);
    return s.length && s.forEach(([u, d]) => {
      e.getValue(u).set(d);
    }), e.render(), sr && c !== null && window.scrollTo({ top: c }), { target: l, transitionEnd: r };
  } else
    return { target: t, transitionEnd: r };
};
function Up(e, t, n, r) {
  return Vp(t) ? Fp(e, t, n, r) : { target: t, transitionEnd: r };
}
const Hp = (e, t, n, r) => {
  const i = Lp(e, t, r);
  return t = i.target, r = i.transitionEnd, Up(e, t, n, r);
}, di = { current: null }, jc = { current: !1 };
function Wp() {
  if (jc.current = !0, !!sr)
    if (window.matchMedia) {
      const e = window.matchMedia("(prefers-reduced-motion)"), t = () => di.current = e.matches;
      e.addListener(t), t();
    } else
      di.current = !1;
}
function qp(e, t, n) {
  const { willChange: r } = t;
  for (const i in t) {
    const s = t[i], o = n[i];
    if (Ze(s))
      e.addValue(i, s), Gn(r) && r.add(i), process.env.NODE_ENV === "development" && dr(s.version === "8.5.5", `Attempting to mix Framer Motion versions ${s.version} with 8.5.5 may not work as expected.`);
    else if (Ze(o))
      e.addValue(i, Yt(s, { owner: e })), Gn(r) && r.remove(i);
    else if (o !== s)
      if (e.hasValue(i)) {
        const a = e.getValue(i);
        !a.hasAnimated && a.set(s);
      } else {
        const a = e.getStaticValue(i);
        e.addValue(i, Yt(a !== void 0 ? a : s, { owner: e }));
      }
  }
  for (const i in n)
    t[i] === void 0 && e.removeValue(i);
  return t;
}
const $c = Object.keys(mn), zp = $c.length, ks = [
  "AnimationStart",
  "AnimationComplete",
  "Update",
  "BeforeLayoutMeasure",
  "LayoutMeasure",
  "LayoutAnimationStart",
  "LayoutAnimationComplete"
];
class Kp {
  constructor({ parent: t, props: n, reducedMotionConfig: r, visualState: i }, s = {}) {
    this.current = null, this.children = /* @__PURE__ */ new Set(), this.isVariantNode = !1, this.isControllingVariants = !1, this.shouldReduceMotion = null, this.values = /* @__PURE__ */ new Map(), this.isPresent = !0, this.valueSubscriptions = /* @__PURE__ */ new Map(), this.prevMotionValues = {}, this.events = {}, this.propEventSubscriptions = {}, this.notifyUpdate = () => this.notify("Update", this.latestValues), this.render = () => {
      this.current && (this.triggerBuild(), this.renderInstance(this.current, this.renderState, this.props.style, this.projection));
    }, this.scheduleRender = () => qe.render(this.render, !1, !0);
    const { latestValues: o, renderState: a } = i;
    this.latestValues = o, this.baseTarget = { ...o }, this.initialValues = n.initial ? { ...o } : {}, this.renderState = a, this.parent = t, this.props = n, this.depth = t ? t.depth + 1 : 0, this.reducedMotionConfig = r, this.options = s, this.isControllingVariants = cr(n), this.isVariantNode = Ba(n), this.isVariantNode && (this.variantChildren = /* @__PURE__ */ new Set()), this.manuallyAnimateOnMount = !!(t && t.current);
    const { willChange: c, ...l } = this.scrapeMotionValuesFromProps(n, {});
    for (const u in l) {
      const d = l[u];
      o[u] !== void 0 && Ze(d) && (d.set(o[u], !1), Gn(c) && c.add(u));
    }
  }
  /**
   * This method takes React props and returns found MotionValues. For example, HTML
   * MotionValues will be found within the style prop, whereas for Three.js within attribute arrays.
   *
   * This isn't an abstract method as it needs calling in the constructor, but it is
   * intended to be one.
   */
  scrapeMotionValuesFromProps(t, n) {
    return {};
  }
  mount(t) {
    var n;
    this.current = t, this.projection && this.projection.mount(t), this.parent && this.isVariantNode && !this.isControllingVariants && (this.removeFromVariantTree = (n = this.parent) === null || n === void 0 ? void 0 : n.addVariantChild(this)), this.values.forEach((r, i) => this.bindToMotionValue(i, r)), jc.current || Wp(), this.shouldReduceMotion = this.reducedMotionConfig === "never" ? !1 : this.reducedMotionConfig === "always" ? !0 : di.current, process.env.NODE_ENV !== "production" && dr(this.shouldReduceMotion !== !0, "You have Reduced Motion enabled on your device. Animations may not appear as expected."), this.parent && this.parent.children.add(this), this.setProps(this.props);
  }
  unmount() {
    var t, n, r;
    (t = this.projection) === null || t === void 0 || t.unmount(), wt.update(this.notifyUpdate), wt.render(this.render), this.valueSubscriptions.forEach((i) => i()), (n = this.removeFromVariantTree) === null || n === void 0 || n.call(this), (r = this.parent) === null || r === void 0 || r.children.delete(this);
    for (const i in this.events)
      this.events[i].clear();
    this.current = null;
  }
  bindToMotionValue(t, n) {
    const r = Gt.has(t), i = n.on("change", (o) => {
      this.latestValues[t] = o, this.props.onUpdate && qe.update(this.notifyUpdate, !1, !0), r && this.projection && (this.projection.isTransformDirty = !0);
    }), s = n.on("renderRequest", this.scheduleRender);
    this.valueSubscriptions.set(t, () => {
      i(), s();
    });
  }
  sortNodePosition(t) {
    return !this.current || !this.sortInstanceNodePosition || this.type !== t.type ? 0 : this.sortInstanceNodePosition(this.current, t.current);
  }
  loadFeatures({ children: t, ...n }, r, i, s, o, a) {
    const c = [];
    process.env.NODE_ENV !== "production" && i && r && ot(!1, "You have rendered a `motion` component within a `LazyMotion` component. This will break tree shaking. Import and render a `m` component instead.");
    for (let l = 0; l < zp; l++) {
      const u = $c[l], { isEnabled: d, Component: h } = mn[u];
      d(n) && h && c.push(la(h, {
        key: u,
        ...n,
        visualElement: this
      }));
    }
    if (!this.projection && o) {
      this.projection = new o(s, this.latestValues, this.parent && this.parent.projection);
      const { layoutId: l, layout: u, drag: d, dragConstraints: h, layoutScroll: m, layoutRoot: v } = n;
      this.projection.setOptions({
        layoutId: l,
        layout: u,
        alwaysMeasureLayout: !!d || h && Ft(h),
        visualElement: this,
        scheduleRender: () => this.scheduleRender(),
        /**
         * TODO: Update options in an effect. This could be tricky as it'll be too late
         * to update by the time layout animations run.
         * We also need to fix this safeToRemove by linking it up to the one returned by usePresence,
         * ensuring it gets called if there's no potential layout animations.
         *
         */
        animationType: typeof u == "string" ? u : "both",
        initialPromotionConfig: a,
        layoutScroll: m,
        layoutRoot: v
      });
    }
    return c;
  }
  triggerBuild() {
    this.build(this.renderState, this.latestValues, this.options, this.props);
  }
  /**
   * Measure the current viewport box with or without transforms.
   * Only measures axis-aligned boxes, rotate and skew must be manually
   * removed with a re-render to work.
   */
  measureViewportBox() {
    return this.current ? this.measureInstanceViewportBox(this.current, this.props) : Ne();
  }
  getStaticValue(t) {
    return this.latestValues[t];
  }
  setStaticValue(t, n) {
    this.latestValues[t] = n;
  }
  /**
   * Make a target animatable by Popmotion. For instance, if we're
   * trying to animate width from 100px to 100vw we need to measure 100vw
   * in pixels to determine what we really need to animate to. This is also
   * pluggable to support Framer's custom value types like Color,
   * and CSS variables.
   */
  makeTargetAnimatable(t, n = !0) {
    return this.makeTargetAnimatableFromInstance(t, this.props, n);
  }
  /**
   * Update the provided props. Ensure any newly-added motion values are
   * added to our map, old ones removed, and listeners updated.
   */
  setProps(t) {
    (t.transformTemplate || this.props.transformTemplate) && this.scheduleRender();
    const n = this.props;
    this.props = t;
    for (let r = 0; r < ks.length; r++) {
      const i = ks[r];
      this.propEventSubscriptions[i] && (this.propEventSubscriptions[i](), delete this.propEventSubscriptions[i]);
      const s = t["on" + i];
      s && (this.propEventSubscriptions[i] = this.on(i, s));
    }
    this.prevMotionValues = qp(this, this.scrapeMotionValuesFromProps(t, n), this.prevMotionValues), this.handleChildMotionValue && this.handleChildMotionValue();
  }
  getProps() {
    return this.props;
  }
  /**
   * Returns the variant definition with a given name.
   */
  getVariant(t) {
    var n;
    return (n = this.props.variants) === null || n === void 0 ? void 0 : n[t];
  }
  /**
   * Returns the defined default transition on this component.
   */
  getDefaultTransition() {
    return this.props.transition;
  }
  getTransformPagePoint() {
    return this.props.transformPagePoint;
  }
  getClosestVariantNode() {
    var t;
    return this.isVariantNode ? this : (t = this.parent) === null || t === void 0 ? void 0 : t.getClosestVariantNode();
  }
  getVariantContext(t = !1) {
    var n, r;
    if (t)
      return (n = this.parent) === null || n === void 0 ? void 0 : n.getVariantContext();
    if (!this.isControllingVariants) {
      const s = ((r = this.parent) === null || r === void 0 ? void 0 : r.getVariantContext()) || {};
      return this.props.initial !== void 0 && (s.initial = this.props.initial), s;
    }
    const i = {};
    for (let s = 0; s < Yp; s++) {
      const o = Fc[s], a = this.props[o];
      (pn(a) || a === !1) && (i[o] = a);
    }
    return i;
  }
  /**
   * Add a child visual element to our set of children.
   */
  addVariantChild(t) {
    var n;
    const r = this.getClosestVariantNode();
    if (r)
      return (n = r.variantChildren) === null || n === void 0 || n.add(t), () => r.variantChildren.delete(t);
  }
  /**
   * Add a motion value and bind it to this visual element.
   */
  addValue(t, n) {
    n !== this.values.get(t) && (this.removeValue(t), this.bindToMotionValue(t, n)), this.values.set(t, n), this.latestValues[t] = n.get();
  }
  /**
   * Remove a motion value and unbind any active subscriptions.
   */
  removeValue(t) {
    var n;
    this.values.delete(t), (n = this.valueSubscriptions.get(t)) === null || n === void 0 || n(), this.valueSubscriptions.delete(t), delete this.latestValues[t], this.removeValueFromRenderState(t, this.renderState);
  }
  /**
   * Check whether we have a motion value for this key
   */
  hasValue(t) {
    return this.values.has(t);
  }
  getValue(t, n) {
    if (this.props.values && this.props.values[t])
      return this.props.values[t];
    let r = this.values.get(t);
    return r === void 0 && n !== void 0 && (r = Yt(n, { owner: this }), this.addValue(t, r)), r;
  }
  /**
   * If we're trying to animate to a previously unencountered value,
   * we need to check for it in our state and as a last resort read it
   * directly from the instance (which might have performance implications).
   */
  readValue(t) {
    return this.latestValues[t] !== void 0 || !this.current ? this.latestValues[t] : this.readValueFromInstance(this.current, t, this.options);
  }
  /**
   * Set the base target to later animate back to. This is currently
   * only hydrated on creation and when we first read a value.
   */
  setBaseTarget(t, n) {
    this.baseTarget[t] = n;
  }
  /**
   * Find the base target for a value thats been removed from all animation
   * props.
   */
  getBaseTarget(t) {
    var n;
    const { initial: r } = this.props, i = typeof r == "string" || typeof r == "object" ? (n = Ki(this.props, r)) === null || n === void 0 ? void 0 : n[t] : void 0;
    if (r && i !== void 0)
      return i;
    const s = this.getBaseTargetFromProps(this.props, t);
    return s !== void 0 && !Ze(s) ? s : this.initialValues[t] !== void 0 && i === void 0 ? void 0 : this.baseTarget[t];
  }
  on(t, n) {
    return this.events[t] || (this.events[t] = new Ji()), this.events[t].add(n);
  }
  notify(t, ...n) {
    var r;
    (r = this.events[t]) === null || r === void 0 || r.notify(...n);
  }
}
const Fc = ["initial", ...fo], Yp = Fc.length;
class Uc extends Kp {
  sortInstanceNodePosition(t, n) {
    return t.compareDocumentPosition(n) & 2 ? 1 : -1;
  }
  getBaseTargetFromProps(t, n) {
    var r;
    return (r = t.style) === null || r === void 0 ? void 0 : r[n];
  }
  removeValueFromRenderState(t, { vars: n, style: r }) {
    delete n[t], delete r[t];
  }
  makeTargetAnimatableFromInstance({ transition: t, transitionEnd: n, ...r }, { transformValues: i }, s) {
    let o = ih(r, t || {}, this);
    if (i && (n && (n = i(n)), r && (r = i(r)), o && (o = i(o))), s) {
      nh(this, r, o);
      const a = Hp(this, r, o, n);
      n = a.transitionEnd, r = a.target;
    }
    return {
      transition: t,
      transitionEnd: n,
      ...r
    };
  }
}
function Gp(e) {
  return window.getComputedStyle(e);
}
class Xp extends Uc {
  readValueFromInstance(t, n) {
    if (Gt.has(n)) {
      const r = to(n);
      return r && r.default || 0;
    } else {
      const r = Gp(t), i = (Fa(n) ? r.getPropertyValue(n) : r[n]) || 0;
      return typeof i == "string" ? i.trim() : i;
    }
  }
  measureInstanceViewportBox(t, { transformPagePoint: n }) {
    return Vc(t, n);
  }
  build(t, n, r, i) {
    Fi(t, n, r, i.transformTemplate);
  }
  scrapeMotionValuesFromProps(t, n) {
    return zi(t, n);
  }
  handleChildMotionValue() {
    this.childSubscription && (this.childSubscription(), delete this.childSubscription);
    const { children: t } = this.props;
    Ze(t) && (this.childSubscription = t.on("change", (n) => {
      this.current && (this.current.textContent = `${n}`);
    }));
  }
  renderInstance(t, n, r, i) {
    za(t, n, r, i);
  }
}
class Zp extends Uc {
  constructor() {
    super(...arguments), this.isSVGTag = !1;
  }
  getBaseTargetFromProps(t, n) {
    return t[n];
  }
  readValueFromInstance(t, n) {
    var r;
    return Gt.has(n) ? ((r = to(n)) === null || r === void 0 ? void 0 : r.default) || 0 : (n = Ka.has(n) ? n : qi(n), t.getAttribute(n));
  }
  measureInstanceViewportBox() {
    return Ne();
  }
  scrapeMotionValuesFromProps(t, n) {
    return Ga(t, n);
  }
  build(t, n, r, i) {
    Hi(t, n, r, this.isSVGTag, i.transformTemplate);
  }
  renderInstance(t, n, r, i) {
    Ya(t, n, r, i);
  }
  mount(t) {
    this.isSVGTag = Wi(t.tagName), super.mount(t);
  }
}
const Jp = (e, t) => $i(e) ? new Zp(t, { enableHardwareAcceleration: !1 }) : new Xp(t, { enableHardwareAcceleration: !0 });
function Ms(e, t) {
  return t.max === t.min ? 0 : e / (t.max - t.min) * 100;
}
const nn = {
  correct: (e, t) => {
    if (!t.target)
      return e;
    if (typeof e == "string")
      if (Z.test(e))
        e = parseFloat(e);
      else
        return e;
    const n = Ms(e, t.target.x), r = Ms(e, t.target.y);
    return `${n}% ${r}%`;
  }
}, Is = "_$css", Qp = {
  correct: (e, { treeScale: t, projectionDelta: n }) => {
    const r = e, i = e.includes("var("), s = [];
    i && (e = e.replace(Nc, (m) => (s.push(m), Is)));
    const o = Tt.parse(e);
    if (o.length > 5)
      return r;
    const a = Tt.createTransformer(e), c = typeof o[0] != "number" ? 1 : 0, l = n.x.scale * t.x, u = n.y.scale * t.y;
    o[0 + c] /= l, o[1 + c] /= u;
    const d = Me(l, u, 0.5);
    typeof o[2 + c] == "number" && (o[2 + c] /= d), typeof o[3 + c] == "number" && (o[3 + c] /= d);
    let h = a(o);
    if (i) {
      let m = 0;
      h = h.replace(Is, () => {
        const v = s[m];
        return m++, v;
      });
    }
    return h;
  }
};
class em extends je.Component {
  /**
   * This only mounts projection nodes for components that
   * need measuring, we might want to do it for all components
   * in order to incorporate transforms
   */
  componentDidMount() {
    const { visualElement: t, layoutGroup: n, switchLayoutGroup: r, layoutId: i } = this.props, { projection: s } = t;
    qf(nm), s && (n.group && n.group.add(s), r && r.register && i && r.register(s), s.root.didUpdate(), s.addEventListener("animationComplete", () => {
      this.safeToRemove();
    }), s.setOptions({
      ...s.options,
      onExitComplete: () => this.safeToRemove()
    })), an.hasEverUpdated = !0;
  }
  getSnapshotBeforeUpdate(t) {
    const { layoutDependency: n, visualElement: r, drag: i, isPresent: s } = this.props, o = r.projection;
    return o && (o.isPresent = s, i || t.layoutDependency !== n || n === void 0 ? o.willUpdate() : this.safeToRemove(), t.isPresent !== s && (s ? o.promote() : o.relegate() || qe.postRender(() => {
      var a;
      !((a = o.getStack()) === null || a === void 0) && a.members.length || this.safeToRemove();
    }))), null;
  }
  componentDidUpdate() {
    const { projection: t } = this.props.visualElement;
    t && (t.root.didUpdate(), !t.currentAnimation && t.isLead() && this.safeToRemove());
  }
  componentWillUnmount() {
    const { visualElement: t, layoutGroup: n, switchLayoutGroup: r } = this.props, { projection: i } = t;
    i && (i.scheduleCheckAfterUnmount(), n != null && n.group && n.group.remove(i), r != null && r.deregister && r.deregister(i));
  }
  safeToRemove() {
    const { safeToRemove: t } = this.props;
    t == null || t();
  }
  render() {
    return null;
  }
}
function tm(e) {
  const [t, n] = rc(), r = $e(ji);
  return je.createElement(em, { ...e, layoutGroup: r, switchLayoutGroup: $e(ja), isPresent: t, safeToRemove: n });
}
const nm = {
  borderRadius: {
    ...nn,
    applyTo: [
      "borderTopLeftRadius",
      "borderTopRightRadius",
      "borderBottomLeftRadius",
      "borderBottomRightRadius"
    ]
  },
  borderTopLeftRadius: nn,
  borderTopRightRadius: nn,
  borderBottomLeftRadius: nn,
  borderBottomRightRadius: nn,
  boxShadow: Qp
}, rm = {
  measureLayout: tm
};
function im(e, t, n = {}) {
  const r = Ze(e) ? e : Yt(e);
  return r.start(uo("", r, t, n)), {
    stop: () => r.stop(),
    isAnimating: () => r.isAnimating()
  };
}
const Hc = ["TopLeft", "TopRight", "BottomLeft", "BottomRight"], om = Hc.length, Ls = (e) => typeof e == "string" ? parseFloat(e) : e, Ds = (e) => typeof e == "number" || Z.test(e);
function sm(e, t, n, r, i, s) {
  i ? (e.opacity = Me(
    0,
    // TODO Reinstate this if only child
    n.opacity !== void 0 ? n.opacity : 1,
    am(r)
  ), e.opacityExit = Me(t.opacity !== void 0 ? t.opacity : 1, 0, cm(r))) : s && (e.opacity = Me(t.opacity !== void 0 ? t.opacity : 1, n.opacity !== void 0 ? n.opacity : 1, r));
  for (let o = 0; o < om; o++) {
    const a = `border${Hc[o]}Radius`;
    let c = Vs(t, a), l = Vs(n, a);
    if (c === void 0 && l === void 0)
      continue;
    c || (c = 0), l || (l = 0), c === 0 || l === 0 || Ds(c) === Ds(l) ? (e[a] = Math.max(Me(Ls(c), Ls(l), r), 0), (ct.test(l) || ct.test(c)) && (e[a] += "%")) : e[a] = l;
  }
  (t.rotate || n.rotate) && (e.rotate = Me(t.rotate || 0, n.rotate || 0, r));
}
function Vs(e, t) {
  return e[t] !== void 0 ? e[t] : e.borderRadius;
}
const am = Wc(0, 0.5, co), cm = Wc(0.5, 0.95, ao);
function Wc(e, t, n) {
  return (r) => r < e ? 0 : r > t ? 1 : n(Xn(e, t, r));
}
function Ns(e, t) {
  e.min = t.min, e.max = t.max;
}
function rt(e, t) {
  Ns(e.x, t.x), Ns(e.y, t.y);
}
function Bs(e, t, n, r, i) {
  return e -= t, e = Jn(e, 1 / n, r), i !== void 0 && (e = Jn(e, 1 / i, r)), e;
}
function lm(e, t = 0, n = 1, r = 0.5, i, s = e, o = e) {
  if (ct.test(t) && (t = parseFloat(t), t = Me(o.min, o.max, t / 100) - o.min), typeof t != "number")
    return;
  let a = Me(s.min, s.max, r);
  e === s && (a -= t), e.min = Bs(e.min, t, n, a, i), e.max = Bs(e.max, t, n, a, i);
}
function js(e, t, [n, r, i], s, o) {
  lm(e, t[n], t[r], t[i], t.scale, s, o);
}
const um = ["x", "scaleX", "originX"], fm = ["y", "scaleY", "originY"];
function $s(e, t, n, r) {
  js(e.x, t, um, n == null ? void 0 : n.x, r == null ? void 0 : r.x), js(e.y, t, fm, n == null ? void 0 : n.y, r == null ? void 0 : r.y);
}
function Fs(e) {
  return e.translate === 0 && e.scale === 1;
}
function qc(e) {
  return Fs(e.x) && Fs(e.y);
}
function zc(e, t) {
  return e.x.min === t.x.min && e.x.max === t.x.max && e.y.min === t.y.min && e.y.max === t.y.max;
}
function Us(e) {
  return Je(e.x) / Je(e.y);
}
class dm {
  constructor() {
    this.members = [];
  }
  add(t) {
    Xi(this.members, t), t.scheduleRender();
  }
  remove(t) {
    if (Zi(this.members, t), t === this.prevLead && (this.prevLead = void 0), t === this.lead) {
      const n = this.members[this.members.length - 1];
      n && this.promote(n);
    }
  }
  relegate(t) {
    const n = this.members.findIndex((i) => t === i);
    if (n === 0)
      return !1;
    let r;
    for (let i = n; i >= 0; i--) {
      const s = this.members[i];
      if (s.isPresent !== !1) {
        r = s;
        break;
      }
    }
    return r ? (this.promote(r), !0) : !1;
  }
  promote(t, n) {
    var r;
    const i = this.lead;
    if (t !== i && (this.prevLead = i, this.lead = t, t.show(), i)) {
      i.instance && i.scheduleRender(), t.scheduleRender(), t.resumeFrom = i, n && (t.resumeFrom.preserveOpacity = !0), i.snapshot && (t.snapshot = i.snapshot, t.snapshot.latestValues = i.animationValues || i.latestValues), !((r = t.root) === null || r === void 0) && r.isUpdating && (t.isLayoutDirty = !0);
      const { crossfade: s } = t.options;
      s === !1 && i.hide();
    }
  }
  exitAnimationComplete() {
    this.members.forEach((t) => {
      var n, r, i, s, o;
      (r = (n = t.options).onExitComplete) === null || r === void 0 || r.call(n), (o = (i = t.resumingFrom) === null || i === void 0 ? void 0 : (s = i.options).onExitComplete) === null || o === void 0 || o.call(s);
    });
  }
  scheduleRender() {
    this.members.forEach((t) => {
      t.instance && t.scheduleRender(!1);
    });
  }
  /**
   * Clear any leads that have been removed this render to prevent them from being
   * used in future animations and to prevent memory leaks
   */
  removeLeadSnapshot() {
    this.lead && this.lead.snapshot && (this.lead.snapshot = void 0);
  }
}
function Hs(e, t, n) {
  let r = "";
  const i = e.x.translate / t.x, s = e.y.translate / t.y;
  if ((i || s) && (r = `translate3d(${i}px, ${s}px, 0) `), (t.x !== 1 || t.y !== 1) && (r += `scale(${1 / t.x}, ${1 / t.y}) `), n) {
    const { rotate: c, rotateX: l, rotateY: u } = n;
    c && (r += `rotate(${c}deg) `), l && (r += `rotateX(${l}deg) `), u && (r += `rotateY(${u}deg) `);
  }
  const o = e.x.scale * t.x, a = e.y.scale * t.y;
  return (o !== 1 || a !== 1) && (r += `scale(${o}, ${a})`), r || "none";
}
const hm = (e, t) => e.depth - t.depth;
class pm {
  constructor() {
    this.children = [], this.isDirty = !1;
  }
  add(t) {
    Xi(this.children, t), this.isDirty = !0;
  }
  remove(t) {
    Zi(this.children, t), this.isDirty = !0;
  }
  forEach(t) {
    this.isDirty && this.children.sort(hm), this.isDirty = !1, this.children.forEach(t);
  }
}
const Ws = ["", "X", "Y", "Z"], qs = 1e3;
let mm = 0;
function Kc({ attachResizeListener: e, defaultParent: t, measureScroll: n, checkIsScrollRoot: r, resetTransform: i }) {
  return class {
    constructor(o, a = {}, c = t == null ? void 0 : t()) {
      this.id = mm++, this.animationId = 0, this.children = /* @__PURE__ */ new Set(), this.options = {}, this.isTreeAnimating = !1, this.isAnimationBlocked = !1, this.isLayoutDirty = !1, this.isTransformDirty = !1, this.isProjectionDirty = !1, this.updateManuallyBlocked = !1, this.updateBlockedByResize = !1, this.isUpdating = !1, this.isSVG = !1, this.needsReset = !1, this.shouldResetTransform = !1, this.treeScale = { x: 1, y: 1 }, this.eventHandlers = /* @__PURE__ */ new Map(), this.potentialNodes = /* @__PURE__ */ new Map(), this.checkUpdateFailed = () => {
        this.isUpdating && (this.isUpdating = !1, this.clearAllSnapshots());
      }, this.updateProjection = () => {
        this.nodes.forEach(vm), this.nodes.forEach(bm), this.nodes.forEach(Am);
      }, this.hasProjected = !1, this.isVisible = !0, this.animationProgress = 0, this.sharedNodes = /* @__PURE__ */ new Map(), this.elementId = o, this.latestValues = a, this.root = c ? c.root || c : this, this.path = c ? [...c.path, c] : [], this.parent = c, this.depth = c ? c.depth + 1 : 0, o && this.root.registerPotentialNode(o, this);
      for (let l = 0; l < this.path.length; l++)
        this.path[l].shouldResetTransform = !0;
      this.root === this && (this.nodes = new pm());
    }
    addEventListener(o, a) {
      return this.eventHandlers.has(o) || this.eventHandlers.set(o, new Ji()), this.eventHandlers.get(o).add(a);
    }
    notifyListeners(o, ...a) {
      const c = this.eventHandlers.get(o);
      c == null || c.notify(...a);
    }
    hasListeners(o) {
      return this.eventHandlers.has(o);
    }
    registerPotentialNode(o, a) {
      this.potentialNodes.set(o, a);
    }
    /**
     * Lifecycles
     */
    mount(o, a = !1) {
      var c;
      if (this.instance)
        return;
      this.isSVG = o instanceof SVGElement && o.tagName !== "svg", this.instance = o;
      const { layoutId: l, layout: u, visualElement: d } = this.options;
      if (d && !d.current && d.mount(o), this.root.nodes.add(this), (c = this.parent) === null || c === void 0 || c.children.add(this), this.elementId && this.root.potentialNodes.delete(this.elementId), a && (u || l) && (this.isLayoutDirty = !0), e) {
        let h;
        const m = () => this.root.updateBlockedByResize = !1;
        e(o, () => {
          this.root.updateBlockedByResize = !0, h && h(), h = _c(m, 250), an.hasAnimatedSinceResize && (an.hasAnimatedSinceResize = !1, this.nodes.forEach(Ks));
        });
      }
      l && this.root.registerSharedNode(l, this), this.options.animate !== !1 && d && (l || u) && this.addEventListener("didUpdate", ({ delta: h, hasLayoutChanged: m, hasRelativeTargetChanged: v, layout: w }) => {
        var I, E, P, M, L;
        if (this.isTreeAnimationBlocked()) {
          this.target = void 0, this.relativeTarget = void 0;
          return;
        }
        const T = (E = (I = this.options.transition) !== null && I !== void 0 ? I : d.getDefaultTransition()) !== null && E !== void 0 ? E : Cm, { onLayoutAnimationStart: _, onLayoutAnimationComplete: V } = d.getProps(), F = !this.targetLayout || !zc(this.targetLayout, w) || v, W = !m && v;
        if (this.options.layoutRoot || !((P = this.resumeFrom) === null || P === void 0) && P.instance || W || m && (F || !this.currentAnimation)) {
          this.resumeFrom && (this.resumingFrom = this.resumeFrom, this.resumingFrom.resumingFrom = void 0), this.setAnimationOrigin(h, W);
          const N = {
            ...Oc(T, "layout"),
            onPlay: _,
            onComplete: V
          };
          (d.shouldReduceMotion || this.options.layoutRoot) && (N.delay = 0, N.type = !1), this.startAnimation(N);
        } else
          !m && this.animationProgress === 0 && Ks(this), this.isLead() && ((L = (M = this.options).onExitComplete) === null || L === void 0 || L.call(M));
        this.targetLayout = w;
      });
    }
    unmount() {
      var o, a;
      this.options.layoutId && this.willUpdate(), this.root.nodes.remove(this), (o = this.getStack()) === null || o === void 0 || o.remove(this), (a = this.parent) === null || a === void 0 || a.children.delete(this), this.instance = void 0, wt.preRender(this.updateProjection);
    }
    // only on the root
    blockUpdate() {
      this.updateManuallyBlocked = !0;
    }
    unblockUpdate() {
      this.updateManuallyBlocked = !1;
    }
    isUpdateBlocked() {
      return this.updateManuallyBlocked || this.updateBlockedByResize;
    }
    isTreeAnimationBlocked() {
      var o;
      return this.isAnimationBlocked || ((o = this.parent) === null || o === void 0 ? void 0 : o.isTreeAnimationBlocked()) || !1;
    }
    // Note: currently only running on root node
    startUpdate() {
      var o;
      this.isUpdateBlocked() || (this.isUpdating = !0, (o = this.nodes) === null || o === void 0 || o.forEach(Em), this.animationId++);
    }
    getTransformTemplate() {
      var o;
      return (o = this.options.visualElement) === null || o === void 0 ? void 0 : o.getProps().transformTemplate;
    }
    willUpdate(o = !0) {
      var a, c, l;
      if (this.root.isUpdateBlocked()) {
        (c = (a = this.options).onExitComplete) === null || c === void 0 || c.call(a);
        return;
      }
      if (!this.root.isUpdating && this.root.startUpdate(), this.isLayoutDirty)
        return;
      this.isLayoutDirty = !0;
      for (let h = 0; h < this.path.length; h++) {
        const m = this.path[h];
        m.shouldResetTransform = !0, m.updateScroll("snapshot"), m.options.layoutRoot && m.willUpdate(!1);
      }
      const { layoutId: u, layout: d } = this.options;
      u === void 0 && !d || (this.prevTransformTemplateValue = (l = this.getTransformTemplate()) === null || l === void 0 ? void 0 : l(this.latestValues, ""), this.updateSnapshot(), o && this.notifyListeners("willUpdate"));
    }
    // Note: Currently only running on root node
    didUpdate() {
      if (this.isUpdateBlocked()) {
        this.unblockUpdate(), this.clearAllSnapshots(), this.nodes.forEach(zs);
        return;
      }
      this.isUpdating && (this.isUpdating = !1, this.potentialNodes.size && (this.potentialNodes.forEach(_m), this.potentialNodes.clear()), this.nodes.forEach(Tm), this.nodes.forEach(gm), this.nodes.forEach(ym), this.clearAllSnapshots(), Pr.update(), Pr.preRender(), Pr.render());
    }
    clearAllSnapshots() {
      this.nodes.forEach(wm), this.sharedNodes.forEach(Sm);
    }
    scheduleUpdateProjection() {
      qe.preRender(this.updateProjection, !1, !0);
    }
    scheduleCheckAfterUnmount() {
      qe.postRender(() => {
        this.isLayoutDirty ? this.root.didUpdate() : this.root.checkUpdateFailed();
      });
    }
    /**
     * Update measurements
     */
    updateSnapshot() {
      this.snapshot || !this.instance || (this.snapshot = this.measure());
    }
    updateLayout() {
      var o;
      if (!this.instance || (this.updateScroll(), !(this.options.alwaysMeasureLayout && this.isLead()) && !this.isLayoutDirty))
        return;
      if (this.resumeFrom && !this.resumeFrom.instance)
        for (let c = 0; c < this.path.length; c++)
          this.path[c].updateScroll();
      const a = this.layout;
      this.layout = this.measure(!1), this.layoutCorrected = Ne(), this.isLayoutDirty = !1, this.projectionDelta = void 0, this.notifyListeners("measure", this.layout.layoutBox), (o = this.options.visualElement) === null || o === void 0 || o.notify("LayoutMeasure", this.layout.layoutBox, a == null ? void 0 : a.layoutBox);
    }
    updateScroll(o = "measure") {
      let a = !!(this.options.layoutScroll && this.instance);
      this.scroll && this.scroll.animationId === this.root.animationId && this.scroll.phase === o && (a = !1), a && (this.scroll = {
        animationId: this.root.animationId,
        phase: o,
        isRoot: r(this.instance),
        offset: n(this.instance)
      });
    }
    resetTransform() {
      var o;
      if (!i)
        return;
      const a = this.isLayoutDirty || this.shouldResetTransform, c = this.projectionDelta && !qc(this.projectionDelta), l = (o = this.getTransformTemplate()) === null || o === void 0 ? void 0 : o(this.latestValues, ""), u = l !== this.prevTransformTemplateValue;
      a && (c || Ct(this.latestValues) || u) && (i(this.instance, l), this.shouldResetTransform = !1, this.scheduleRender());
    }
    measure(o = !0) {
      const a = this.measurePageBox();
      let c = this.removeElementScroll(a);
      return o && (c = this.removeTransform(c)), Om(c), {
        animationId: this.root.animationId,
        measuredBox: a,
        layoutBox: c,
        latestValues: {},
        source: this.id
      };
    }
    measurePageBox() {
      const { visualElement: o } = this.options;
      if (!o)
        return Ne();
      const a = o.measureViewportBox(), { scroll: c } = this.root;
      return c && (gt(a.x, c.offset.x), gt(a.y, c.offset.y)), a;
    }
    removeElementScroll(o) {
      const a = Ne();
      rt(a, o);
      for (let c = 0; c < this.path.length; c++) {
        const l = this.path[c], { scroll: u, options: d } = l;
        if (l !== this.root && u && d.layoutScroll) {
          if (u.isRoot) {
            rt(a, o);
            const { scroll: h } = this.root;
            h && (gt(a.x, -h.offset.x), gt(a.y, -h.offset.y));
          }
          gt(a.x, u.offset.x), gt(a.y, u.offset.y);
        }
      }
      return a;
    }
    applyTransform(o, a = !1) {
      const c = Ne();
      rt(c, o);
      for (let l = 0; l < this.path.length; l++) {
        const u = this.path[l];
        !a && u.options.layoutScroll && u.scroll && u !== u.root && Ht(c, {
          x: -u.scroll.offset.x,
          y: -u.scroll.offset.y
        }), Ct(u.latestValues) && Ht(c, u.latestValues);
      }
      return Ct(this.latestValues) && Ht(c, this.latestValues), c;
    }
    removeTransform(o) {
      var a;
      const c = Ne();
      rt(c, o);
      for (let l = 0; l < this.path.length; l++) {
        const u = this.path[l];
        if (!u.instance || !Ct(u.latestValues))
          continue;
        ci(u.latestValues) && u.updateSnapshot();
        const d = Ne(), h = u.measurePageBox();
        rt(d, h), $s(c, u.latestValues, (a = u.snapshot) === null || a === void 0 ? void 0 : a.layoutBox, d);
      }
      return Ct(this.latestValues) && $s(c, this.latestValues), c;
    }
    /**
     *
     */
    setTargetDelta(o) {
      this.targetDelta = o, this.isProjectionDirty = !0, this.root.scheduleUpdateProjection();
    }
    setOptions(o) {
      this.options = {
        ...this.options,
        ...o,
        crossfade: o.crossfade !== void 0 ? o.crossfade : !0
      };
    }
    clearMeasurements() {
      this.scroll = void 0, this.layout = void 0, this.snapshot = void 0, this.prevTransformTemplateValue = void 0, this.targetDelta = void 0, this.target = void 0, this.isLayoutDirty = !1;
    }
    /**
     * Frame calculations
     */
    resolveTargetDelta() {
      var o;
      const a = this.getLead();
      if (this.isProjectionDirty || (this.isProjectionDirty = a.isProjectionDirty), this.isTransformDirty || (this.isTransformDirty = a.isTransformDirty), !this.isProjectionDirty && !this.attemptToResolveRelativeTarget)
        return;
      const { layout: c, layoutId: l } = this.options;
      if (!(!this.layout || !(c || l))) {
        if (!this.targetDelta && !this.relativeTarget) {
          const u = this.getClosestProjectingParent();
          u && u.layout ? (this.relativeParent = u, this.relativeTarget = Ne(), this.relativeTargetOrigin = Ne(), fn(this.relativeTargetOrigin, this.layout.layoutBox, u.layout.layoutBox), rt(this.relativeTarget, this.relativeTargetOrigin)) : this.relativeParent = this.relativeTarget = void 0;
        }
        if (!(!this.relativeTarget && !this.targetDelta) && (this.target || (this.target = Ne(), this.targetWithTransforms = Ne()), this.relativeTarget && this.relativeTargetOrigin && (!((o = this.relativeParent) === null || o === void 0) && o.target) ? hp(this.target, this.relativeTarget, this.relativeParent.target) : this.targetDelta ? (this.resumingFrom ? this.target = this.applyTransform(this.layout.layoutBox) : rt(this.target, this.layout.layoutBox), Dc(this.target, this.targetDelta)) : rt(this.target, this.layout.layoutBox), this.attemptToResolveRelativeTarget)) {
          this.attemptToResolveRelativeTarget = !1;
          const u = this.getClosestProjectingParent();
          u && !!u.resumingFrom == !!this.resumingFrom && !u.options.layoutScroll && u.target ? (this.relativeParent = u, this.relativeTarget = Ne(), this.relativeTargetOrigin = Ne(), fn(this.relativeTargetOrigin, this.target, u.target), rt(this.relativeTarget, this.relativeTargetOrigin)) : this.relativeParent = this.relativeTarget = void 0;
        }
      }
    }
    getClosestProjectingParent() {
      if (!(!this.parent || ci(this.parent.latestValues) || Lc(this.parent.latestValues)))
        return (this.parent.relativeTarget || this.parent.targetDelta || this.parent.options.layoutRoot) && this.parent.layout ? this.parent : this.parent.getClosestProjectingParent();
    }
    calcProjection() {
      var o;
      const { isProjectionDirty: a, isTransformDirty: c } = this;
      this.isProjectionDirty = this.isTransformDirty = !1;
      const l = this.getLead(), u = !!this.resumingFrom || this !== l;
      let d = !0;
      if (a && (d = !1), u && c && (d = !1), d)
        return;
      const { layout: h, layoutId: m } = this.options;
      if (this.isTreeAnimating = !!(!((o = this.parent) === null || o === void 0) && o.isTreeAnimating || this.currentAnimation || this.pendingAnimation), this.isTreeAnimating || (this.targetDelta = this.relativeTarget = void 0), !this.layout || !(h || m))
        return;
      rt(this.layoutCorrected, this.layout.layoutBox), Ap(this.layoutCorrected, this.treeScale, this.path, u);
      const { target: v } = l;
      if (!v)
        return;
      this.projectionDelta || (this.projectionDelta = dn(), this.projectionDeltaWithTransform = dn());
      const w = this.treeScale.x, I = this.treeScale.y, E = this.projectionTransform;
      un(this.projectionDelta, this.layoutCorrected, v, this.latestValues), this.projectionTransform = Hs(this.projectionDelta, this.treeScale), (this.projectionTransform !== E || this.treeScale.x !== w || this.treeScale.y !== I) && (this.hasProjected = !0, this.scheduleRender(), this.notifyListeners("projectionUpdate", v));
    }
    hide() {
      this.isVisible = !1;
    }
    show() {
      this.isVisible = !0;
    }
    scheduleRender(o = !0) {
      var a, c, l;
      (c = (a = this.options).scheduleRender) === null || c === void 0 || c.call(a), o && ((l = this.getStack()) === null || l === void 0 || l.scheduleRender()), this.resumingFrom && !this.resumingFrom.instance && (this.resumingFrom = void 0);
    }
    setAnimationOrigin(o, a = !1) {
      var c, l;
      const u = this.snapshot, d = (u == null ? void 0 : u.latestValues) || {}, h = { ...this.latestValues }, m = dn();
      (!this.relativeParent || !this.relativeParent.options.layoutRoot) && (this.relativeTarget = this.relativeTargetOrigin = void 0), this.attemptToResolveRelativeTarget = !a;
      const v = Ne(), w = (u == null ? void 0 : u.source) !== ((c = this.layout) === null || c === void 0 ? void 0 : c.source), I = (((l = this.getStack()) === null || l === void 0 ? void 0 : l.members.length) || 0) <= 1, E = !!(w && !I && this.options.crossfade === !0 && !this.path.some(Pm));
      this.animationProgress = 0, this.mixTargetDelta = (P) => {
        var M;
        const L = P / 1e3;
        Ys(m.x, o.x, L), Ys(m.y, o.y, L), this.setTargetDelta(m), this.relativeTarget && this.relativeTargetOrigin && this.layout && (!((M = this.relativeParent) === null || M === void 0) && M.layout) && (fn(v, this.layout.layoutBox, this.relativeParent.layout.layoutBox), xm(this.relativeTarget, this.relativeTargetOrigin, v, L)), w && (this.animationValues = h, sm(h, d, this.latestValues, L, E, I)), this.root.scheduleUpdateProjection(), this.scheduleRender(), this.animationProgress = L;
      }, this.mixTargetDelta(this.options.layoutRoot ? 1e3 : 0);
    }
    startAnimation(o) {
      var a, c;
      this.notifyListeners("animationStart"), (a = this.currentAnimation) === null || a === void 0 || a.stop(), this.resumingFrom && ((c = this.resumingFrom.currentAnimation) === null || c === void 0 || c.stop()), this.pendingAnimation && (wt.update(this.pendingAnimation), this.pendingAnimation = void 0), this.pendingAnimation = qe.update(() => {
        an.hasAnimatedSinceResize = !0, this.currentAnimation = im(0, qs, {
          ...o,
          onUpdate: (l) => {
            var u;
            this.mixTargetDelta(l), (u = o.onUpdate) === null || u === void 0 || u.call(o, l);
          },
          onComplete: () => {
            var l;
            (l = o.onComplete) === null || l === void 0 || l.call(o), this.completeAnimation();
          }
        }), this.resumingFrom && (this.resumingFrom.currentAnimation = this.currentAnimation), this.pendingAnimation = void 0;
      });
    }
    completeAnimation() {
      var o;
      this.resumingFrom && (this.resumingFrom.currentAnimation = void 0, this.resumingFrom.preserveOpacity = void 0), (o = this.getStack()) === null || o === void 0 || o.exitAnimationComplete(), this.resumingFrom = this.currentAnimation = this.animationValues = void 0, this.notifyListeners("animationComplete");
    }
    finishAnimation() {
      var o;
      this.currentAnimation && ((o = this.mixTargetDelta) === null || o === void 0 || o.call(this, qs), this.currentAnimation.stop()), this.completeAnimation();
    }
    applyTransformsToTarget() {
      const o = this.getLead();
      let { targetWithTransforms: a, target: c, layout: l, latestValues: u } = o;
      if (!(!a || !c || !l)) {
        if (this !== o && this.layout && l && Yc(this.options.animationType, this.layout.layoutBox, l.layoutBox)) {
          c = this.target || Ne();
          const d = Je(this.layout.layoutBox.x);
          c.x.min = o.target.x.min, c.x.max = c.x.min + d;
          const h = Je(this.layout.layoutBox.y);
          c.y.min = o.target.y.min, c.y.max = c.y.min + h;
        }
        rt(a, c), Ht(a, u), un(this.projectionDeltaWithTransform, this.layoutCorrected, a, u);
      }
    }
    registerSharedNode(o, a) {
      var c, l, u;
      this.sharedNodes.has(o) || this.sharedNodes.set(o, new dm()), this.sharedNodes.get(o).add(a), a.promote({
        transition: (c = a.options.initialPromotionConfig) === null || c === void 0 ? void 0 : c.transition,
        preserveFollowOpacity: (u = (l = a.options.initialPromotionConfig) === null || l === void 0 ? void 0 : l.shouldPreserveFollowOpacity) === null || u === void 0 ? void 0 : u.call(l, a)
      });
    }
    isLead() {
      const o = this.getStack();
      return o ? o.lead === this : !0;
    }
    getLead() {
      var o;
      const { layoutId: a } = this.options;
      return a ? ((o = this.getStack()) === null || o === void 0 ? void 0 : o.lead) || this : this;
    }
    getPrevLead() {
      var o;
      const { layoutId: a } = this.options;
      return a ? (o = this.getStack()) === null || o === void 0 ? void 0 : o.prevLead : void 0;
    }
    getStack() {
      const { layoutId: o } = this.options;
      if (o)
        return this.root.sharedNodes.get(o);
    }
    promote({ needsReset: o, transition: a, preserveFollowOpacity: c } = {}) {
      const l = this.getStack();
      l && l.promote(this, c), o && (this.projectionDelta = void 0, this.needsReset = !0), a && this.setOptions({ transition: a });
    }
    relegate() {
      const o = this.getStack();
      return o ? o.relegate(this) : !1;
    }
    resetRotation() {
      const { visualElement: o } = this.options;
      if (!o)
        return;
      let a = !1;
      const { latestValues: c } = o;
      if ((c.rotate || c.rotateX || c.rotateY || c.rotateZ) && (a = !0), !a)
        return;
      const l = {};
      for (let u = 0; u < Ws.length; u++) {
        const d = "rotate" + Ws[u];
        c[d] && (l[d] = c[d], o.setStaticValue(d, 0));
      }
      o == null || o.render();
      for (const u in l)
        o.setStaticValue(u, l[u]);
      o.scheduleRender();
    }
    getProjectionStyles(o = {}) {
      var a, c;
      const l = {};
      if (!this.instance || this.isSVG)
        return l;
      if (this.isVisible)
        l.visibility = "";
      else
        return { visibility: "hidden" };
      const u = this.getTransformTemplate();
      if (this.needsReset)
        return this.needsReset = !1, l.opacity = "", l.pointerEvents = Nn(o.pointerEvents) || "", l.transform = u ? u(this.latestValues, "") : "none", l;
      const d = this.getLead();
      if (!this.projectionDelta || !this.layout || !d.target) {
        const w = {};
        return this.options.layoutId && (w.opacity = this.latestValues.opacity !== void 0 ? this.latestValues.opacity : 1, w.pointerEvents = Nn(o.pointerEvents) || ""), this.hasProjected && !Ct(this.latestValues) && (w.transform = u ? u({}, "") : "none", this.hasProjected = !1), w;
      }
      const h = d.animationValues || d.latestValues;
      this.applyTransformsToTarget(), l.transform = Hs(this.projectionDeltaWithTransform, this.treeScale, h), u && (l.transform = u(h, l.transform));
      const { x: m, y: v } = this.projectionDelta;
      l.transformOrigin = `${m.origin * 100}% ${v.origin * 100}% 0`, d.animationValues ? l.opacity = d === this ? (c = (a = h.opacity) !== null && a !== void 0 ? a : this.latestValues.opacity) !== null && c !== void 0 ? c : 1 : this.preserveOpacity ? this.latestValues.opacity : h.opacityExit : l.opacity = d === this ? h.opacity !== void 0 ? h.opacity : "" : h.opacityExit !== void 0 ? h.opacityExit : 0;
      for (const w in Hn) {
        if (h[w] === void 0)
          continue;
        const { correct: I, applyTo: E } = Hn[w], P = l.transform === "none" ? h[w] : I(h[w], d);
        if (E) {
          const M = E.length;
          for (let L = 0; L < M; L++)
            l[E[L]] = P;
        } else
          l[w] = P;
      }
      return this.options.layoutId && (l.pointerEvents = d === this ? Nn(o.pointerEvents) || "" : "none"), l;
    }
    clearSnapshot() {
      this.resumeFrom = this.snapshot = void 0;
    }
    // Only run on root
    resetTree() {
      this.root.nodes.forEach((o) => {
        var a;
        return (a = o.currentAnimation) === null || a === void 0 ? void 0 : a.stop();
      }), this.root.nodes.forEach(zs), this.root.sharedNodes.clear();
    }
  };
}
function gm(e) {
  e.updateLayout();
}
function ym(e) {
  var t, n, r;
  const i = ((t = e.resumeFrom) === null || t === void 0 ? void 0 : t.snapshot) || e.snapshot;
  if (e.isLead() && e.layout && i && e.hasListeners("didUpdate")) {
    const { layoutBox: s, measuredBox: o } = e.layout, { animationType: a } = e.options, c = i.source !== e.layout.source;
    a === "size" ? st((m) => {
      const v = c ? i.measuredBox[m] : i.layoutBox[m], w = Je(v);
      v.min = s[m].min, v.max = v.min + w;
    }) : Yc(a, i.layoutBox, s) && st((m) => {
      const v = c ? i.measuredBox[m] : i.layoutBox[m], w = Je(s[m]);
      v.max = v.min + w;
    });
    const l = dn();
    un(l, s, i.layoutBox);
    const u = dn();
    c ? un(u, e.applyTransform(o, !0), i.measuredBox) : un(u, s, i.layoutBox);
    const d = !qc(l);
    let h = !1;
    if (!e.resumeFrom) {
      const m = e.getClosestProjectingParent();
      if (m && !m.resumeFrom) {
        const { snapshot: v, layout: w } = m;
        if (v && w) {
          const I = Ne();
          fn(I, i.layoutBox, v.layoutBox);
          const E = Ne();
          fn(E, s, w.layoutBox), zc(I, E) || (h = !0), m.options.layoutRoot && (e.relativeTarget = E, e.relativeTargetOrigin = I, e.relativeParent = m);
        }
      }
    }
    e.notifyListeners("didUpdate", {
      layout: s,
      snapshot: i,
      delta: u,
      layoutDelta: l,
      hasLayoutChanged: d,
      hasRelativeTargetChanged: h
    });
  } else
    e.isLead() && ((r = (n = e.options).onExitComplete) === null || r === void 0 || r.call(n));
  e.options.transition = void 0;
}
function vm(e) {
  e.isProjectionDirty || (e.isProjectionDirty = !!(e.parent && e.parent.isProjectionDirty)), e.isTransformDirty || (e.isTransformDirty = !!(e.parent && e.parent.isTransformDirty));
}
function wm(e) {
  e.clearSnapshot();
}
function zs(e) {
  e.clearMeasurements();
}
function Tm(e) {
  const { visualElement: t } = e.options;
  t != null && t.getProps().onBeforeLayoutMeasure && t.notify("BeforeLayoutMeasure"), e.resetTransform();
}
function Ks(e) {
  e.finishAnimation(), e.targetDelta = e.relativeTarget = e.target = void 0;
}
function bm(e) {
  e.resolveTargetDelta();
}
function Am(e) {
  e.calcProjection();
}
function Em(e) {
  e.resetRotation();
}
function Sm(e) {
  e.removeLeadSnapshot();
}
function Ys(e, t, n) {
  e.translate = Me(t.translate, 0, n), e.scale = Me(t.scale, 1, n), e.origin = t.origin, e.originPoint = t.originPoint;
}
function Gs(e, t, n, r) {
  e.min = Me(t.min, n.min, r), e.max = Me(t.max, n.max, r);
}
function xm(e, t, n, r) {
  Gs(e.x, t.x, n.x, r), Gs(e.y, t.y, n.y, r);
}
function Pm(e) {
  return e.animationValues && e.animationValues.opacityExit !== void 0;
}
const Cm = {
  duration: 0.45,
  ease: [0.4, 0, 0.1, 1]
};
function _m(e, t) {
  let n = e.root;
  for (let s = e.path.length - 1; s >= 0; s--)
    if (e.path[s].instance) {
      n = e.path[s];
      break;
    }
  const i = (n && n !== e.root ? n.instance : document).querySelector(`[data-projection-id="${t}"]`);
  i && e.mount(i, !0);
}
function Xs(e) {
  e.min = Math.round(e.min), e.max = Math.round(e.max);
}
function Om(e) {
  Xs(e.x), Xs(e.y);
}
function Yc(e, t, n) {
  return e === "position" || e === "preserve-aspect" && !si(Us(t), Us(n), 0.2);
}
const Rm = Kc({
  attachResizeListener: (e, t) => ur(e, "resize", t),
  measureScroll: () => ({
    x: document.documentElement.scrollLeft || document.body.scrollLeft,
    y: document.documentElement.scrollTop || document.body.scrollTop
  }),
  checkIsScrollRoot: () => !0
}), Vr = {
  current: void 0
}, km = Kc({
  measureScroll: (e) => ({
    x: e.scrollLeft,
    y: e.scrollTop
  }),
  defaultParent: () => {
    if (!Vr.current) {
      const e = new Rm(0, {});
      e.mount(window), e.setOptions({ layoutScroll: !0 }), Vr.current = e;
    }
    return Vr.current;
  },
  resetTransform: (e, t) => {
    e.style.transform = t !== void 0 ? t : "none";
  },
  checkIsScrollRoot: (e) => window.getComputedStyle(e).position === "fixed"
}), Mm = {
  ...lp,
  ...Rd,
  ...kp,
  ...rm
}, Gc = /* @__PURE__ */ Hf((e, t) => yd(e, t, Mm, Jp, km));
function Xc() {
  const e = nt(!1);
  return Un(() => (e.current = !0, () => {
    e.current = !1;
  }), []), e;
}
function Im() {
  const e = Xc(), [t, n] = He(0), r = Rt(() => {
    e.current && n(t + 1);
  }, [t]);
  return [Rt(() => qe.postRender(r), [r]), t];
}
class Lm extends ve.Component {
  getSnapshotBeforeUpdate(t) {
    const n = this.props.childRef.current;
    if (n && t.isPresent && !this.props.isPresent) {
      const r = this.props.sizeRef.current;
      r.height = n.offsetHeight || 0, r.width = n.offsetWidth || 0, r.top = n.offsetTop, r.left = n.offsetLeft;
    }
    return null;
  }
  /**
   * Required with getSnapshotBeforeUpdate to stop React complaining.
   */
  componentDidUpdate() {
  }
  render() {
    return this.props.children;
  }
}
function Dm({ children: e, isPresent: t }) {
  const n = wi(), r = nt(null), i = nt({
    width: 0,
    height: 0,
    top: 0,
    left: 0
  });
  return Tl(() => {
    const { width: s, height: o, top: a, left: c } = i.current;
    if (t || !r.current || !s || !o)
      return;
    r.current.dataset.motionPopId = n;
    const l = document.createElement("style");
    return document.head.appendChild(l), l.sheet && l.sheet.insertRule(`
          [data-motion-pop-id="${n}"] {
            position: absolute !important;
            width: ${s}px !important;
            height: ${o}px !important;
            top: ${a}px !important;
            left: ${c}px !important;
          }
        `), () => {
      document.head.removeChild(l);
    };
  }, [t]), ve.createElement(Lm, { isPresent: t, childRef: r, sizeRef: i }, ve.cloneElement(e, { ref: r }));
}
const Nr = ({ children: e, initial: t, isPresent: n, onExitComplete: r, custom: i, presenceAffectsLayout: s, mode: o }) => {
  const a = lr(Vm), c = wi(), l = ze(
    () => ({
      id: c,
      initial: t,
      isPresent: n,
      custom: i,
      onExitComplete: (u) => {
        a.set(u, !0);
        for (const d of a.values())
          if (!d)
            return;
        r && r();
      },
      register: (u) => (a.set(u, !1), () => a.delete(u))
    }),
    /**
     * If the presence of a child affects the layout of the components around it,
     * we want to make a new context value to ensure they get re-rendered
     * so they can detect that layout change.
     */
    s ? void 0 : [n]
  );
  return ze(() => {
    a.forEach((u, d) => a.set(d, !1));
  }, [n]), ve.useEffect(() => {
    !n && !a.size && r && r();
  }, [n]), o === "popLayout" && (e = ve.createElement(Dm, { isPresent: n }, e)), ve.createElement(An.Provider, { value: l }, e);
};
function Vm() {
  return /* @__PURE__ */ new Map();
}
const Bt = (e) => e.key || "";
function Nm(e, t) {
  e.forEach((n) => {
    const r = Bt(n);
    t.set(r, n);
  });
}
function Bm(e) {
  const t = [];
  return Al.forEach(e, (n) => {
    El(n) && t.push(n);
  }), t;
}
const jm = ({ children: e, custom: t, initial: n = !0, onExitComplete: r, exitBeforeEnter: i, presenceAffectsLayout: s = !0, mode: o = "sync" }) => {
  i && (o = "wait", process.env.NODE_ENV !== "production" && dr(!1, "Replace exitBeforeEnter with mode='wait'"));
  let [a] = Im();
  const c = $e(ji).forceRender;
  c && (a = c);
  const l = Xc(), u = Bm(e);
  let d = u;
  const h = /* @__PURE__ */ new Set(), m = nt(d), v = nt(/* @__PURE__ */ new Map()).current, w = nt(!0);
  if (Un(() => {
    w.current = !1, Nm(u, v), m.current = d;
  }), Gi(() => {
    w.current = !0, v.clear(), h.clear();
  }), w.current)
    return ve.createElement(ve.Fragment, null, d.map((M) => ve.createElement(Nr, { key: Bt(M), isPresent: !0, initial: n ? void 0 : !1, presenceAffectsLayout: s, mode: o }, M)));
  d = [...d];
  const I = m.current.map(Bt), E = u.map(Bt), P = I.length;
  for (let M = 0; M < P; M++) {
    const L = I[M];
    E.indexOf(L) === -1 && h.add(L);
  }
  return o === "wait" && h.size && (d = []), h.forEach((M) => {
    if (E.indexOf(M) !== -1)
      return;
    const L = v.get(M);
    if (!L)
      return;
    const T = I.indexOf(M), _ = () => {
      v.delete(M), h.delete(M);
      const V = m.current.findIndex((F) => F.key === M);
      if (m.current.splice(V, 1), !h.size) {
        if (m.current = u, l.current === !1)
          return;
        a(), r && r();
      }
    };
    d.splice(T, 0, ve.createElement(Nr, { key: Bt(L), isPresent: !1, onExitComplete: _, custom: t, presenceAffectsLayout: s, mode: o }, L));
  }), d = d.map((M) => {
    const L = M.key;
    return h.has(L) ? M : ve.createElement(Nr, { key: Bt(M), isPresent: !0, presenceAffectsLayout: s, mode: o }, M);
  }), process.env.NODE_ENV !== "production" && o === "wait" && d.length > 1 && console.warn(`You're attempting to animate multiple children within AnimatePresence, but its mode is set to "wait". This will lead to odd visual behaviour.`), ve.createElement(ve.Fragment, null, h.size ? d : d.map((M) => bl(M)));
};
function ho({
  open: e,
  onClose: t,
  children: n,
  className: r,
  variants: i,
  noWatermark: s = !1,
  noVariableContentSize: o = !1
}) {
  const a = Of(), [c, l] = He(0), u = Rt((d) => {
    if (!d)
      return;
    new ResizeObserver(() => {
      !d || d.clientHeight <= 0 || l(d.clientHeight);
    }).observe(d);
  }, []);
  return /* @__PURE__ */ ye(jm, {
    children: [e && /* @__PURE__ */ K(Um, {
      variants: $m,
      initial: "hidden",
      animate: "shown",
      exit: "hidden",
      transition: {
        ease: "easeInOut",
        duration: 0.23
      },
      onClick: t,
      children: !s && /* @__PURE__ */ ye(Ym, {
        children: ["Arweave Wallet Kit v", _f]
      })
    }, "bg"), e && /* @__PURE__ */ K(Km, {
      className: r,
      variants: i || Hm(a),
      initial: "hidden",
      animate: "shown",
      exit: "hidden",
      style: {
        height: o ? void 0 : c
      },
      children: /* @__PURE__ */ K("div", {
        ref: u,
        children: n
      })
    }, "modal")]
  });
}
const $m = {
  shown: {
    opacity: 1
  },
  hidden: {
    opacity: 0
  }
}, Fm = () => Gc.div, Um = /* @__PURE__ */ ce(Fm())({
  name: "BackgroundLayer",
  class: "bbvkbel",
  propsAsIs: !0
}), Hm = (e = !1) => ({
  shown: {
    opacity: 1,
    translateX: "-50%",
    translateY: e ? "0" : "-50%",
    transition: {
      type: "spring",
      duration: 0.4,
      delayChildren: 0.2,
      staggerChildren: 0.05
    }
  },
  hidden: {
    opacity: 0.4,
    translateX: "-50%",
    translateY: "200%",
    transition: {
      type: "spring",
      duration: 0.4
    }
  }
}), Wm = () => Gc.div, qm = () => (e) => e.theme.background, zm = () => (e) => ({
  default: 30,
  minimal: 12,
  none: 0
})[e.theme.themeConfig.radius] + "px", Km = Be(/* @__PURE__ */ ce(Wm())({
  name: "Wrapper",
  class: "w1767o4q",
  propsAsIs: !0,
  vars: {
    "w1767o4q-0": [qm()],
    "w1767o4q-1": [zm()]
  }
})), Ym = /* @__PURE__ */ ce("p")({
  name: "KitName",
  class: "kzdiz37",
  propsAsIs: !1
});
function po(e = !1) {
  const [t, n] = He(e);
  return {
    setOpen: n,
    open: t,
    bindings: {
      open: t,
      onClose: () => n(!1)
    }
  };
}
function Gm() {
  const e = po(), {
    state: t,
    dispatch: n
  } = We(), [r, i] = He();
  Te(() => {
    (async () => {
      const c = await Pl(t == null ? void 0 : t.config.strategies, (t == null ? void 0 : t.config.permissions) || [], !!(t != null && t.config.ensurePermissions));
      c && c.resumeSession ? (i(c), e.setOpen(!0)) : n({
        type: "UPDATE_STRATEGY",
        payload: !!c && c.id || !1
      });
    })();
  }, []);
  function s() {
    localStorage.removeItem(wn), n({
      type: "DISCONNECT"
    });
  }
  async function o() {
    let c = !1;
    if (r != null && r.resumeSession) {
      c = r;
      try {
        await r.resumeSession();
      } catch {
        c = !1;
      }
    }
    i(void 0), e.setOpen(!1), n({
      type: "UPDATE_STRATEGY",
      payload: !!c && c.id || !1
    }), c || s();
  }
  function a() {
    i(void 0), e.setOpen(!1), s();
  }
  return /* @__PURE__ */ K(Qm, {
    variants: Xm,
    ...e.bindings,
    onClose: a,
    noWatermark: !0,
    noVariableContentSize: !0,
    children: /* @__PURE__ */ ye(eg, {
      children: [/* @__PURE__ */ ye(ng, {
        children: ["Would you like to restore your ", (r == null ? void 0 : r.name) + " " || "", "session?"]
      }), /* @__PURE__ */ ye(rg, {
        children: [/* @__PURE__ */ K(vt, {
          onClick: o,
          children: "Restore"
        }), /* @__PURE__ */ K(ag, {
          onClick: a,
          children: "Cancel"
        })]
      })]
    })
  });
}
const Xm = {
  shown: {
    opacity: 1,
    translateY: "-1.5rem",
    transition: {
      type: "spring",
      duration: 0.4,
      delayChildren: 0.2,
      staggerChildren: 0.025
    }
  },
  hidden: {
    opacity: 0.4,
    translateY: "200%",
    transition: {
      type: "spring",
      duration: 0.4
    }
  }
}, Zm = () => ho, Jm = () => (e) => ({
  default: 15,
  minimal: 8,
  none: 0
})[e.theme.themeConfig.radius] + "px", Qm = Be(/* @__PURE__ */ ce(Zm())({
  name: "BottomModal",
  class: "b7jc8fb",
  propsAsIs: !0,
  vars: {
    "b7jc8fb-0": [Jm()]
  }
})), eg = /* @__PURE__ */ ce("div")({
  name: "Content",
  class: "cypmncv",
  propsAsIs: !1
}), tg = () => (e) => e.theme.primaryText, ng = Be(/* @__PURE__ */ ce("p")({
  name: "Text",
  class: "t14qolsb",
  propsAsIs: !1,
  vars: {
    "t14qolsb-0": [tg()]
  }
})), rg = /* @__PURE__ */ ce("div")({
  name: "Buttons",
  class: "b1jq17m8",
  propsAsIs: !1
}), ig = () => vt, og = () => (e) => e.theme.primaryText, sg = () => (e) => e.theme.theme, ag = Be(/* @__PURE__ */ ce(ig())({
  name: "CloseButton",
  class: "c4cavtk",
  propsAsIs: !0,
  vars: {
    "c4cavtk-0": [og()],
    "c4cavtk-1": [sg()]
  }
}));
var cg = function() {
  const t = Array.prototype.slice.call(arguments).filter(Boolean), n = {}, r = [];
  t.forEach((s) => {
    (s ? s.split(" ") : []).forEach((a) => {
      if (a.startsWith("atm_")) {
        const [, c] = a.split("_");
        n[c] = a;
      } else
        r.push(a);
    });
  });
  const i = [];
  for (const s in n)
    Object.prototype.hasOwnProperty.call(n, s) && i.push(n[s]);
  return i.push(...r), i.join(" ");
}, gr = cg;
const yr = ({ children: e, className: t, small: n, ...r }) => /* @__PURE__ */ K(
  "p",
  {
    className: gr(So.paragraph, n && So.small, t),
    ...r,
    children: e
  }
), mo = ({ children: e, className: t, small: n, themed: r, ...i }) => /* @__PURE__ */ K(
  "h1",
  {
    className: gr(Vn.title, n && Vn.small, r && Vn.themed, t),
    ...i,
    children: e
  }
), lg = ({ children: e, className: t, ...n }) => /* @__PURE__ */ K(
  "div",
  {
    className: gr(Vn.withParagraph, t),
    ...n,
    children: e
  }
);
function ug({
  logo: e,
  name: t,
  description: n,
  onClick: r,
  theme: i
}) {
  return /* @__PURE__ */ ye(fg, {
    children: [/* @__PURE__ */ ye(dg, {
      children: [/* @__PURE__ */ K(Jc, {
        colorTheme: i,
        clickable: !0,
        onClick: r,
        children: /* @__PURE__ */ K(Zc, {
          src: e,
          draggable: !1
        })
      }), /* @__PURE__ */ ye(yg, {
        children: [/* @__PURE__ */ K(mo, {
          small: !0,
          children: t
        }), /* @__PURE__ */ K(yr, {
          small: !0,
          children: n
        })]
      })]
    }), /* @__PURE__ */ K(vt, {
      onClick: r,
      children: "Go"
    })]
  });
}
const fg = /* @__PURE__ */ ce("div")({
  name: "Wrapper",
  class: "wzg6vks",
  propsAsIs: !1
}), dg = /* @__PURE__ */ ce("div")({
  name: "AppInfo",
  class: "a1vzc1qt",
  propsAsIs: !1
}), Zc = /* @__PURE__ */ ce("img")({
  name: "Logo",
  class: "l1rbotc6",
  propsAsIs: !1
}), hg = () => (e) => ({
  default: 15,
  minimal: 6,
  none: 0
})[e.theme.themeConfig.radius] + "px", pg = () => (e) => e.colorTheme || e.theme.primaryText, mg = () => (e) => e.clickable ? "pointer" : "default", gg = () => (e) => e.clickable ? ".95" : "1", Jc = Be(/* @__PURE__ */ ce("div")({
  name: "AppIcon",
  class: "acuhj7u",
  propsAsIs: !1,
  vars: {
    "acuhj7u-0": [hg()],
    "acuhj7u-1": [pg()],
    "acuhj7u-2": [mg()],
    "acuhj7u-3": [gg()]
  }
})), yg = /* @__PURE__ */ ce("div")({
  name: "AppNameAndDescription",
  class: "a143ijem",
  propsAsIs: !1
});
function vg({
  children: e
}) {
  return /* @__PURE__ */ K(Tg, {
    children: e
  });
}
const wg = () => (e) => e.theme.light, Tg = Be(/* @__PURE__ */ ce("div")({
  name: "Wrapper",
  class: "wv1c1ab",
  propsAsIs: !1,
  vars: {
    "wv1c1ab-0": [wg()]
  }
})), bg = ({ className: e, ...t }) => /* @__PURE__ */ ye(
  "svg",
  {
    className: gr(xl.loading, e),
    viewBox: "0 0 48 48",
    xmlns: "http://www.w3.org/2000/svg",
    ...t,
    children: [
      /* @__PURE__ */ K(
        "circle",
        {
          cx: "24",
          cy: "24",
          fill: "none",
          r: "20",
          strokeDasharray: "80",
          strokeLinecap: "round",
          stroke: "currentColor",
          strokeWidth: "4"
        }
      ),
      /* @__PURE__ */ K(
        "circle",
        {
          cx: "24",
          cy: "24",
          fill: "none",
          opacity: "0.3",
          r: "20",
          strokeLinecap: "round",
          stroke: "currentColor",
          strokeWidth: "4"
        }
      )
    ]
  }
);
function Qc({
  children: e,
  onClose: t
}) {
  return /* @__PURE__ */ ye(Ag, {
    children: [e, /* @__PURE__ */ K(xg, {
      onClick: t,
      children: /* @__PURE__ */ K(Il, {})
    })]
  });
}
const Ag = /* @__PURE__ */ ce("div")({
  name: "HeadWrapper",
  class: "h1mmuqym",
  propsAsIs: !1
}), Eg = () => (e) => e.theme.light, Sg = () => (e) => e.theme.secondaryText, xg = Be(/* @__PURE__ */ ce("div")({
  name: "CloseButton",
  class: "c86k5gq",
  propsAsIs: !1,
  vars: {
    "c86k5gq-0": [Eg()],
    "c86k5gq-1": [Sg()]
  }
}));
function Pg() {
  const e = po(), {
    state: t,
    dispatch: n
  } = We();
  Te(() => {
    e.setOpen((t == null ? void 0 : t.activeModal) === "connect");
  }, [t == null ? void 0 : t.activeModal]), Te(() => {
    e.open || (s(void 0), n({
      type: "CLOSE_MODAL"
    }));
  }, [e.open]);
  const {
    connected: r
  } = _i();
  Te(() => {
    !r || (t == null ? void 0 : t.activeModal) !== "connect" || n({
      type: "CLOSE_MODAL"
    });
  }, [r, t]);
  const [i, s] = He(), o = ze(() => i ? jt(i, t.config.strategies) : void 0, [i, t]), [a, c] = He(!1), [l, u] = He(!1), [d, h] = He(!1), [m, v] = He(!1);
  async function w(_) {
    const F = t.config.strategies.find((N) => N.id === _);
    if (!F)
      return;
    u(!0), s(_);
    let W = !1;
    try {
      W = await F.isAvailable();
    } catch {
      W = !1;
    }
    h(W), u(!1), W && await I(F);
  }
  async function I(_) {
    v(!1), c(!0);
    try {
      await _.connect(t.config.permissions, t.config.appInfo, t.config.gatewayConfig), postMessage({
        type: "connect_result",
        res: !0
      }), n({
        type: "CLOSE_MODAL"
      }), qr(_.id), n({
        type: "UPDATE_STRATEGY",
        payload: _.id
      });
    } catch {
      M(), v(!0), n({
        type: "UPDATE_STRATEGY",
        payload: !1
      });
    }
    c(!1);
  }
  function E() {
    postMessage({
      type: "connect_result",
      res: !1
    }), n({
      type: "CLOSE_MODAL"
    });
  }
  const P = Ni();
  function M() {
    try {
      document.querySelectorAll(".arconnect_connect_overlay_extension_temporary").forEach((_) => _.remove());
    } catch {
    }
  }
  const [L, T] = He(!1);
  return Te(() => {
    (async () => {
      const _ = navigator.brave && await navigator.brave.isBrave();
      T(_);
    })();
  }, []), /* @__PURE__ */ ye(ho, {
    ...e.bindings,
    onClose: E,
    children: [/* @__PURE__ */ K(Qc, {
      onClose: E,
      children: /* @__PURE__ */ ye(Dn, {
        themed: !!i,
        onClick: () => {
          i && s(void 0);
        },
        children: [i && /* @__PURE__ */ K(Fg, {}), o ? o.name : "Connect wallet"]
      })
    }), !i && /* @__PURE__ */ ye(Og, {
      children: [t.config.strategies.sort((_, V) => _.name.localeCompare(V.name)).map((_, V) => /* @__PURE__ */ K(ug, {
        name: _.name,
        description: _.description,
        logo: `${P}/${_.logo}`,
        theme: _.theme,
        onClick: () => w(_.id)
      }, V)), t.config.strategies.length < 1 && /* @__PURE__ */ ye(kg, {
        children: ["No strategies added yet. You can add one like this:", /* @__PURE__ */ K(Wg, {
          children: "npm i @arweave-wallet-kit/arconnect-strategy"
        })]
      })]
    }) || /* @__PURE__ */ K(Mg, {
      children: /* @__PURE__ */ ye(Ig, {
        children: [/* @__PURE__ */ K(Jc, {
          colorTheme: o == null ? void 0 : o.theme,
          children: /* @__PURE__ */ K(Zc, {
            src: `${P}/${o == null ? void 0 : o.logo}`,
            draggable: !1
          })
        }), d && /* @__PURE__ */ ye(hn, {
          children: [/* @__PURE__ */ ye(Dn, {
            small: !0,
            children: ["Connecting to ", (o == null ? void 0 : o.name) || "", "..."]
          }), /* @__PURE__ */ K(Br, {
            children: "Confirm connection request in the wallet popup window"
          }), (o == null ? void 0 : o.id) === "othent" && L && /* @__PURE__ */ ye(Vg, {
            children: ["You might need to ", /* @__PURE__ */ K("b", {
              children: "disable Brave shields"
            }), " for this to work properly."]
          }), m && o && /* @__PURE__ */ K(vt, {
            onClick: () => I(o),
            children: "Retry"
          })]
        }) || !l && /* @__PURE__ */ ye(hn, {
          children: [/* @__PURE__ */ ye(Dn, {
            small: !0,
            children: [(o == null ? void 0 : o.name) || "", " is not available."]
          }), /* @__PURE__ */ K(Br, {
            children: "If you don't have it yet, you can try to download it"
          }), (o == null ? void 0 : o.url) && /* @__PURE__ */ K(vt, {
            onClick: () => window.open(o.url),
            children: "Download"
          })]
        }), (a || l) && /* @__PURE__ */ K(jg, {})]
      })
    }), /* @__PURE__ */ ye(vg, {
      children: [/* @__PURE__ */ ye(lg, {
        children: [/* @__PURE__ */ K(Dn, {
          small: !0,
          children: "Don't have a wallet?"
        }), /* @__PURE__ */ K(Br, {
          small: !0,
          children: "Click to learn more about the permaweb & wallets."
        })]
      }), /* @__PURE__ */ K(vt, {
        onClick: () => window.open("https://arwiki.wiki/#/en/wallets"),
        children: "Get"
      })]
    })]
  });
}
const Cg = () => mo, Dn = /* @__PURE__ */ ce(Cg())({
  name: "StyledTitle",
  class: "s1osnke6",
  propsAsIs: !0
}), _g = () => yr, Br = /* @__PURE__ */ ce(_g())({
  name: "StyledParagraph",
  class: "s15u83h7",
  propsAsIs: !0
}), Og = /* @__PURE__ */ ce("div")({
  name: "Apps",
  class: "a5r445t",
  propsAsIs: !1
}), Rg = () => (e) => e.theme.secondaryText, kg = Be(/* @__PURE__ */ ce("p")({
  name: "NoStrategies",
  class: "nukrfi8",
  propsAsIs: !1,
  vars: {
    "nukrfi8-0": [Rg()]
  }
})), Mg = /* @__PURE__ */ ce("div")({
  name: "Connecting",
  class: "c13sms3",
  propsAsIs: !1
}), Ig = /* @__PURE__ */ ce("div")({
  name: "WalletData",
  class: "w1r2gdr0",
  propsAsIs: !1
}), Lg = () => yr, Dg = () => (e) => ({
  default: 14,
  minimal: 8,
  none: 0
})[e.theme.themeConfig.radius] + "px", Vg = Be(/* @__PURE__ */ ce(Lg())({
  name: "BraveParagraph",
  class: "b1aod1tx",
  propsAsIs: !0,
  vars: {
    "b1aod1tx-0": [Dg()]
  }
})), Ng = () => bg, Bg = () => (e) => e.theme.primaryText, jg = Be(/* @__PURE__ */ ce(Ng())({
  name: "ConnectLoading",
  class: "c11dth47",
  propsAsIs: !0,
  vars: {
    "c11dth47-0": [Bg()]
  }
})), $g = () => Ml, Fg = /* @__PURE__ */ ce($g())({
  name: "BackButton",
  class: "bcs69tl",
  propsAsIs: !0
}), Ug = () => (e) => e.theme.light, Hg = () => (e) => e.theme.secondaryText, Wg = Be(/* @__PURE__ */ ce("div")({
  name: "AddStrategyCode",
  class: "ar7vqm6",
  propsAsIs: !1,
  vars: {
    "ar7vqm6-0": [Ug()],
    "ar7vqm6-1": [Hg()]
  }
}));
function qg() {
  const e = po(), {
    state: t,
    dispatch: n
  } = We();
  Te(() => {
    e.setOpen((t == null ? void 0 : t.activeModal) === "profile");
  }, [t == null ? void 0 : t.activeModal]), Te(() => {
    e.open || n({
      type: "CLOSE_MODAL"
    });
  }, [e.open, n]);
  function r() {
    n({
      type: "CLOSE_MODAL"
    });
  }
  const i = La(), s = Va(), o = Ni(), {
    disconnect: a
  } = _i(), c = lt();
  return /* @__PURE__ */ ye(ho, {
    ...e.bindings,
    onClose: r,
    children: [/* @__PURE__ */ K(Qc, {
      onClose: r,
      children: /* @__PURE__ */ K(Zs, {
        children: "Profile"
      })
    }), /* @__PURE__ */ ye(Xg, {
      children: [/* @__PURE__ */ ye(ey, {
        profilePicture: s == null ? void 0 : s.avatar,
        children: [!(s != null && s.avatar) && /* @__PURE__ */ K(oy, {}), /* @__PURE__ */ K(ry, {
          strategyTheme: c == null ? void 0 : c.theme,
          children: /* @__PURE__ */ K("img", {
            src: c != null && c.logo ? `${o}/${c.logo}` : "",
            alt: (c == null ? void 0 : c.name) || "active strategy logo",
            draggable: !1
          })
        })]
      }), /* @__PURE__ */ ye(Zs, {
        children: [(s == null ? void 0 : s.currentLabel) || da((t == null ? void 0 : t.activeAddress) || "", 8), /* @__PURE__ */ K(Ll, {
          onClick: () => navigator.clipboard.writeText(t.activeAddress || "")
        })]
      }), /* @__PURE__ */ ye(Yg, {
        children: [i.toLocaleString(void 0, {
          maximumFractionDigits: 4
        }), " AR"]
      }), /* @__PURE__ */ ye(vt, {
        onClick: a,
        children: [/* @__PURE__ */ K(Dl, {}), "Disconnect"]
      })]
    })]
  });
}
const zg = () => mo, Zs = /* @__PURE__ */ ce(zg())({
  name: "StyledTitle",
  class: "s1hjgol5",
  propsAsIs: !0
}), Kg = () => yr, Yg = /* @__PURE__ */ ce(Kg())({
  name: "StyledParagraph",
  class: "subls4f",
  propsAsIs: !0
}), Gg = () => (e) => ({
  default: 18,
  minimal: 10,
  none: 0
})[e.theme.themeConfig.radius] + "px", Xg = Be(/* @__PURE__ */ ce("div")({
  name: "ProfileData",
  class: "plzinag",
  propsAsIs: !1,
  vars: {
    "plzinag-0": [Gg()]
  }
})), Zg = () => (e) => ({
  default: "100%",
  minimal: "8px",
  none: "none"
})[e.theme.themeConfig.radius], Jg = () => (e) => e.theme.theme, Qg = () => (e) => e.profilePicture ? `background-image: url(${e.profilePicture});` : "", ey = Be(/* @__PURE__ */ ce("div")({
  name: "ProfilePicture",
  class: "p1qewrlg",
  propsAsIs: !1,
  vars: {
    "p1qewrlg-0": [Zg()],
    "p1qewrlg-1": [Jg()],
    "p1qewrlg-2": [Qg()]
  }
})), ty = () => (e) => e.strategyTheme || e.theme.theme, ny = () => (e) => e.theme.background, ry = Be(/* @__PURE__ */ ce("div")({
  name: "ActiveStrategy",
  class: "a11vudt2",
  propsAsIs: !1,
  vars: {
    "a11vudt2-0": [ty()],
    "a11vudt2-1": [ny()]
  }
})), iy = () => ha, oy = /* @__PURE__ */ ce(iy())({
  name: "ProfileIcon",
  class: "p1jk1ov7",
  propsAsIs: !0
});
function sy(e = Ti, t) {
  switch (t.type) {
    case "OPEN_MODAL":
      return {
        ...e,
        activeModal: t.payload
      };
    case "CLOSE_MODAL":
      return {
        ...e,
        activeModal: !1
      };
    case "DISCONNECT":
      return {
        ...e,
        activeStrategy: !1,
        activeAddress: void 0,
        givenPermissions: []
      };
    case "UPDATE_STRATEGY":
      return {
        ...e,
        activeStrategy: t.payload
      };
    case "UPDATE_CONFIG":
      return {
        ...e,
        config: t.payload
      };
    case "UPDATE_ADDRESS":
      return {
        ...e,
        activeAddress: t.payload
      };
    case "UPDATE_PERMISSIONS":
      return {
        ...e,
        givenPermissions: t.payload
      };
  }
  return e;
}
var hi = { exports: {} };
/*
object-assign
(c) Sindre Sorhus
@license MIT
*/
var Js = Object.getOwnPropertySymbols, ay = Object.prototype.hasOwnProperty, cy = Object.prototype.propertyIsEnumerable;
function ly(e) {
  if (e == null)
    throw new TypeError("Object.assign cannot be called with null or undefined");
  return Object(e);
}
function uy() {
  try {
    if (!Object.assign)
      return !1;
    var e = new String("abc");
    if (e[5] = "de", Object.getOwnPropertyNames(e)[0] === "5")
      return !1;
    for (var t = {}, n = 0; n < 10; n++)
      t["_" + String.fromCharCode(n)] = n;
    var r = Object.getOwnPropertyNames(t).map(function(s) {
      return t[s];
    });
    if (r.join("") !== "0123456789")
      return !1;
    var i = {};
    return "abcdefghijklmnopqrst".split("").forEach(function(s) {
      i[s] = s;
    }), Object.keys(Object.assign({}, i)).join("") === "abcdefghijklmnopqrst";
  } catch {
    return !1;
  }
}
var el = uy() ? Object.assign : function(e, t) {
  for (var n, r = ly(e), i, s = 1; s < arguments.length; s++) {
    n = Object(arguments[s]);
    for (var o in n)
      ay.call(n, o) && (r[o] = n[o]);
    if (Js) {
      i = Js(n);
      for (var a = 0; a < i.length; a++)
        cy.call(n, i[a]) && (r[i[a]] = n[i[a]]);
    }
  }
  return r;
};
const fy = /* @__PURE__ */ Tn(el);
var jr, Qs;
function go() {
  if (Qs)
    return jr;
  Qs = 1;
  var e = "SECRET_DO_NOT_PASS_THIS_OR_YOU_WILL_BE_FIRED";
  return jr = e, jr;
}
var $r, ea;
function tl() {
  return ea || (ea = 1, $r = Function.call.bind(Object.prototype.hasOwnProperty)), $r;
}
var Fr, ta;
function dy() {
  if (ta)
    return Fr;
  ta = 1;
  var e = function() {
  };
  if (process.env.NODE_ENV !== "production") {
    var t = go(), n = {}, r = tl();
    e = function(s) {
      var o = "Warning: " + s;
      typeof console < "u" && console.error(o);
      try {
        throw new Error(o);
      } catch {
      }
    };
  }
  function i(s, o, a, c, l) {
    if (process.env.NODE_ENV !== "production") {
      for (var u in s)
        if (r(s, u)) {
          var d;
          try {
            if (typeof s[u] != "function") {
              var h = Error(
                (c || "React class") + ": " + a + " type `" + u + "` is invalid; it must be a function, usually from the `prop-types` package, but received `" + typeof s[u] + "`.This often happens because of typos such as `PropTypes.function` instead of `PropTypes.func`."
              );
              throw h.name = "Invariant Violation", h;
            }
            d = s[u](o, u, c, a, null, t);
          } catch (v) {
            d = v;
          }
          if (d && !(d instanceof Error) && e(
            (c || "React class") + ": type specification of " + a + " `" + u + "` is invalid; the type checker function must return `null` or an `Error` but returned a " + typeof d + ". You may have forgotten to pass an argument to the type checker creator (arrayOf, instanceOf, objectOf, oneOf, oneOfType, and shape all require an argument)."
          ), d instanceof Error && !(d.message in n)) {
            n[d.message] = !0;
            var m = l ? l() : "";
            e(
              "Failed " + a + " type: " + d.message + (m ?? "")
            );
          }
        }
    }
  }
  return i.resetWarningCache = function() {
    process.env.NODE_ENV !== "production" && (n = {});
  }, Fr = i, Fr;
}
var Ur, na;
function hy() {
  if (na)
    return Ur;
  na = 1;
  var e = Ei(), t = el, n = go(), r = tl(), i = dy(), s = function() {
  };
  process.env.NODE_ENV !== "production" && (s = function(a) {
    var c = "Warning: " + a;
    typeof console < "u" && console.error(c);
    try {
      throw new Error(c);
    } catch {
    }
  });
  function o() {
    return null;
  }
  return Ur = function(a, c) {
    var l = typeof Symbol == "function" && Symbol.iterator, u = "@@iterator";
    function d(j) {
      var H = j && (l && j[l] || j[u]);
      if (typeof H == "function")
        return H;
    }
    var h = "<<anonymous>>", m = {
      array: E("array"),
      bigint: E("bigint"),
      bool: E("boolean"),
      func: E("function"),
      number: E("number"),
      object: E("object"),
      string: E("string"),
      symbol: E("symbol"),
      any: P(),
      arrayOf: M,
      element: L(),
      elementType: T(),
      instanceOf: _,
      node: N(),
      objectOf: F,
      oneOf: V,
      oneOfType: W,
      shape: ne,
      exact: J
    };
    function v(j, H) {
      return j === H ? j !== 0 || 1 / j === 1 / H : j !== j && H !== H;
    }
    function w(j, H) {
      this.message = j, this.data = H && typeof H == "object" ? H : {}, this.stack = "";
    }
    w.prototype = Error.prototype;
    function I(j) {
      if (process.env.NODE_ENV !== "production")
        var H = {}, ee = 0;
      function oe(fe, re, ie, X, se, f, g) {
        if (X = X || h, f = f || ie, g !== n) {
          if (c) {
            var p = new Error(
              "Calling PropTypes validators directly is not supported by the `prop-types` package. Use `PropTypes.checkPropTypes()` to call them. Read more at http://fb.me/use-check-prop-types"
            );
            throw p.name = "Invariant Violation", p;
          } else if (process.env.NODE_ENV !== "production" && typeof console < "u") {
            var C = X + ":" + ie;
            !H[C] && // Avoid spamming the console because they are often not actionable except for lib authors
            ee < 3 && (s(
              "You are manually calling a React.PropTypes validation function for the `" + f + "` prop on `" + X + "`. This is deprecated and will throw in the standalone `prop-types` package. You may be seeing this warning due to a third-party PropTypes library. See https://fb.me/react-warning-dont-call-proptypes for details."
            ), H[C] = !0, ee++);
          }
        }
        return re[ie] == null ? fe ? re[ie] === null ? new w("The " + se + " `" + f + "` is marked as required " + ("in `" + X + "`, but its value is `null`.")) : new w("The " + se + " `" + f + "` is marked as required in " + ("`" + X + "`, but its value is `undefined`.")) : null : j(re, ie, X, se, f);
      }
      var D = oe.bind(null, !1);
      return D.isRequired = oe.bind(null, !0), D;
    }
    function E(j) {
      function H(ee, oe, D, fe, re, ie) {
        var X = ee[oe], se = ge(X);
        if (se !== j) {
          var f = de(X);
          return new w(
            "Invalid " + fe + " `" + re + "` of type " + ("`" + f + "` supplied to `" + D + "`, expected ") + ("`" + j + "`."),
            { expectedType: j }
          );
        }
        return null;
      }
      return I(H);
    }
    function P() {
      return I(o);
    }
    function M(j) {
      function H(ee, oe, D, fe, re) {
        if (typeof j != "function")
          return new w("Property `" + re + "` of component `" + D + "` has invalid PropType notation inside arrayOf.");
        var ie = ee[oe];
        if (!Array.isArray(ie)) {
          var X = ge(ie);
          return new w("Invalid " + fe + " `" + re + "` of type " + ("`" + X + "` supplied to `" + D + "`, expected an array."));
        }
        for (var se = 0; se < ie.length; se++) {
          var f = j(ie, se, D, fe, re + "[" + se + "]", n);
          if (f instanceof Error)
            return f;
        }
        return null;
      }
      return I(H);
    }
    function L() {
      function j(H, ee, oe, D, fe) {
        var re = H[ee];
        if (!a(re)) {
          var ie = ge(re);
          return new w("Invalid " + D + " `" + fe + "` of type " + ("`" + ie + "` supplied to `" + oe + "`, expected a single ReactElement."));
        }
        return null;
      }
      return I(j);
    }
    function T() {
      function j(H, ee, oe, D, fe) {
        var re = H[ee];
        if (!e.isValidElementType(re)) {
          var ie = ge(re);
          return new w("Invalid " + D + " `" + fe + "` of type " + ("`" + ie + "` supplied to `" + oe + "`, expected a single ReactElement type."));
        }
        return null;
      }
      return I(j);
    }
    function _(j) {
      function H(ee, oe, D, fe, re) {
        if (!(ee[oe] instanceof j)) {
          var ie = j.name || h, X = Fe(ee[oe]);
          return new w("Invalid " + fe + " `" + re + "` of type " + ("`" + X + "` supplied to `" + D + "`, expected ") + ("instance of `" + ie + "`."));
        }
        return null;
      }
      return I(H);
    }
    function V(j) {
      if (!Array.isArray(j))
        return process.env.NODE_ENV !== "production" && (arguments.length > 1 ? s(
          "Invalid arguments supplied to oneOf, expected an array, got " + arguments.length + " arguments. A common mistake is to write oneOf(x, y, z) instead of oneOf([x, y, z])."
        ) : s("Invalid argument supplied to oneOf, expected an array.")), o;
      function H(ee, oe, D, fe, re) {
        for (var ie = ee[oe], X = 0; X < j.length; X++)
          if (v(ie, j[X]))
            return null;
        var se = JSON.stringify(j, function(g, p) {
          var C = de(p);
          return C === "symbol" ? String(p) : p;
        });
        return new w("Invalid " + fe + " `" + re + "` of value `" + String(ie) + "` " + ("supplied to `" + D + "`, expected one of " + se + "."));
      }
      return I(H);
    }
    function F(j) {
      function H(ee, oe, D, fe, re) {
        if (typeof j != "function")
          return new w("Property `" + re + "` of component `" + D + "` has invalid PropType notation inside objectOf.");
        var ie = ee[oe], X = ge(ie);
        if (X !== "object")
          return new w("Invalid " + fe + " `" + re + "` of type " + ("`" + X + "` supplied to `" + D + "`, expected an object."));
        for (var se in ie)
          if (r(ie, se)) {
            var f = j(ie, se, D, fe, re + "." + se, n);
            if (f instanceof Error)
              return f;
          }
        return null;
      }
      return I(H);
    }
    function W(j) {
      if (!Array.isArray(j))
        return process.env.NODE_ENV !== "production" && s("Invalid argument supplied to oneOfType, expected an instance of array."), o;
      for (var H = 0; H < j.length; H++) {
        var ee = j[H];
        if (typeof ee != "function")
          return s(
            "Invalid argument supplied to oneOfType. Expected an array of check functions, but received " + Le(ee) + " at index " + H + "."
          ), o;
      }
      function oe(D, fe, re, ie, X) {
        for (var se = [], f = 0; f < j.length; f++) {
          var g = j[f], p = g(D, fe, re, ie, X, n);
          if (p == null)
            return null;
          p.data && r(p.data, "expectedType") && se.push(p.data.expectedType);
        }
        var C = se.length > 0 ? ", expected one of type [" + se.join(", ") + "]" : "";
        return new w("Invalid " + ie + " `" + X + "` supplied to " + ("`" + re + "`" + C + "."));
      }
      return I(oe);
    }
    function N() {
      function j(H, ee, oe, D, fe) {
        return ue(H[ee]) ? null : new w("Invalid " + D + " `" + fe + "` supplied to " + ("`" + oe + "`, expected a ReactNode."));
      }
      return I(j);
    }
    function G(j, H, ee, oe, D) {
      return new w(
        (j || "React class") + ": " + H + " type `" + ee + "." + oe + "` is invalid; it must be a function, usually from the `prop-types` package, but received `" + D + "`."
      );
    }
    function ne(j) {
      function H(ee, oe, D, fe, re) {
        var ie = ee[oe], X = ge(ie);
        if (X !== "object")
          return new w("Invalid " + fe + " `" + re + "` of type `" + X + "` " + ("supplied to `" + D + "`, expected `object`."));
        for (var se in j) {
          var f = j[se];
          if (typeof f != "function")
            return G(D, fe, re, se, de(f));
          var g = f(ie, se, D, fe, re + "." + se, n);
          if (g)
            return g;
        }
        return null;
      }
      return I(H);
    }
    function J(j) {
      function H(ee, oe, D, fe, re) {
        var ie = ee[oe], X = ge(ie);
        if (X !== "object")
          return new w("Invalid " + fe + " `" + re + "` of type `" + X + "` " + ("supplied to `" + D + "`, expected `object`."));
        var se = t({}, ee[oe], j);
        for (var f in se) {
          var g = j[f];
          if (r(j, f) && typeof g != "function")
            return G(D, fe, re, f, de(g));
          if (!g)
            return new w(
              "Invalid " + fe + " `" + re + "` key `" + f + "` supplied to `" + D + "`.\nBad object: " + JSON.stringify(ee[oe], null, "  ") + `
Valid keys: ` + JSON.stringify(Object.keys(j), null, "  ")
            );
          var p = g(ie, f, D, fe, re + "." + f, n);
          if (p)
            return p;
        }
        return null;
      }
      return I(H);
    }
    function ue(j) {
      switch (typeof j) {
        case "number":
        case "string":
        case "undefined":
          return !0;
        case "boolean":
          return !j;
        case "object":
          if (Array.isArray(j))
            return j.every(ue);
          if (j === null || a(j))
            return !0;
          var H = d(j);
          if (H) {
            var ee = H.call(j), oe;
            if (H !== j.entries) {
              for (; !(oe = ee.next()).done; )
                if (!ue(oe.value))
                  return !1;
            } else
              for (; !(oe = ee.next()).done; ) {
                var D = oe.value;
                if (D && !ue(D[1]))
                  return !1;
              }
          } else
            return !1;
          return !0;
        default:
          return !1;
      }
    }
    function Q(j, H) {
      return j === "symbol" ? !0 : H ? H["@@toStringTag"] === "Symbol" || typeof Symbol == "function" && H instanceof Symbol : !1;
    }
    function ge(j) {
      var H = typeof j;
      return Array.isArray(j) ? "array" : j instanceof RegExp ? "object" : Q(H, j) ? "symbol" : H;
    }
    function de(j) {
      if (typeof j > "u" || j === null)
        return "" + j;
      var H = ge(j);
      if (H === "object") {
        if (j instanceof Date)
          return "date";
        if (j instanceof RegExp)
          return "regexp";
      }
      return H;
    }
    function Le(j) {
      var H = de(j);
      switch (H) {
        case "array":
        case "object":
          return "an " + H;
        case "boolean":
        case "date":
        case "regexp":
          return "a " + H;
        default:
          return H;
      }
    }
    function Fe(j) {
      return !j.constructor || !j.constructor.name ? h : j.constructor.name;
    }
    return m.checkPropTypes = i, m.resetWarningCache = i.resetWarningCache, m.PropTypes = m, m;
  }, Ur;
}
var Hr, ra;
function py() {
  if (ra)
    return Hr;
  ra = 1;
  var e = go();
  function t() {
  }
  function n() {
  }
  return n.resetWarningCache = t, Hr = function() {
    function r(o, a, c, l, u, d) {
      if (d !== e) {
        var h = new Error(
          "Calling PropTypes validators directly is not supported by the `prop-types` package. Use PropTypes.checkPropTypes() to call them. Read more at http://fb.me/use-check-prop-types"
        );
        throw h.name = "Invariant Violation", h;
      }
    }
    r.isRequired = r;
    function i() {
      return r;
    }
    var s = {
      array: r,
      bigint: r,
      bool: r,
      func: r,
      number: r,
      object: r,
      string: r,
      symbol: r,
      any: r,
      arrayOf: i,
      element: r,
      elementType: r,
      instanceOf: i,
      node: r,
      objectOf: i,
      oneOf: i,
      oneOfType: i,
      shape: i,
      exact: i,
      checkPropTypes: n,
      resetWarningCache: t
    };
    return s.PropTypes = s, s;
  }, Hr;
}
if (process.env.NODE_ENV !== "production") {
  var my = Ei(), gy = !0;
  hi.exports = hy()(my.isElement, gy);
} else
  hi.exports = py()();
var yy = hi.exports;
const Oe = /* @__PURE__ */ Tn(yy);
function vy(e) {
  return e && typeof e == "object" && "default" in e ? e.default : e;
}
var nl = je, wy = vy(nl);
function ia(e, t, n) {
  return t in e ? Object.defineProperty(e, t, {
    value: n,
    enumerable: !0,
    configurable: !0,
    writable: !0
  }) : e[t] = n, e;
}
function Ty(e, t) {
  e.prototype = Object.create(t.prototype), e.prototype.constructor = e, e.__proto__ = t;
}
var by = !!(typeof window < "u" && window.document && window.document.createElement);
function Ay(e, t, n) {
  if (typeof e != "function")
    throw new Error("Expected reducePropsToState to be a function.");
  if (typeof t != "function")
    throw new Error("Expected handleStateChangeOnClient to be a function.");
  if (typeof n < "u" && typeof n != "function")
    throw new Error("Expected mapStateOnServer to either be undefined or a function.");
  function r(i) {
    return i.displayName || i.name || "Component";
  }
  return function(s) {
    if (typeof s != "function")
      throw new Error("Expected WrappedComponent to be a React component.");
    var o = [], a;
    function c() {
      a = e(o.map(function(u) {
        return u.props;
      })), l.canUseDOM ? t(a) : n && (a = n(a));
    }
    var l = /* @__PURE__ */ function(u) {
      Ty(d, u);
      function d() {
        return u.apply(this, arguments) || this;
      }
      d.peek = function() {
        return a;
      }, d.rewind = function() {
        if (d.canUseDOM)
          throw new Error("You may only call rewind() on the server. Call peek() to read the current state.");
        var v = a;
        return a = void 0, o = [], v;
      };
      var h = d.prototype;
      return h.UNSAFE_componentWillMount = function() {
        o.push(this), c();
      }, h.componentDidUpdate = function() {
        c();
      }, h.componentWillUnmount = function() {
        var v = o.indexOf(this);
        o.splice(v, 1), c();
      }, h.render = function() {
        return wy.createElement(s, this.props);
      }, d;
    }(nl.PureComponent);
    return ia(l, "displayName", "SideEffect(" + r(s) + ")"), ia(l, "canUseDOM", by), l;
  };
}
var Ey = Ay;
const Sy = /* @__PURE__ */ Tn(Ey);
var xy = typeof Element < "u", Py = typeof Map == "function", Cy = typeof Set == "function", _y = typeof ArrayBuffer == "function" && !!ArrayBuffer.isView;
function jn(e, t) {
  if (e === t)
    return !0;
  if (e && t && typeof e == "object" && typeof t == "object") {
    if (e.constructor !== t.constructor)
      return !1;
    var n, r, i;
    if (Array.isArray(e)) {
      if (n = e.length, n != t.length)
        return !1;
      for (r = n; r-- !== 0; )
        if (!jn(e[r], t[r]))
          return !1;
      return !0;
    }
    var s;
    if (Py && e instanceof Map && t instanceof Map) {
      if (e.size !== t.size)
        return !1;
      for (s = e.entries(); !(r = s.next()).done; )
        if (!t.has(r.value[0]))
          return !1;
      for (s = e.entries(); !(r = s.next()).done; )
        if (!jn(r.value[1], t.get(r.value[0])))
          return !1;
      return !0;
    }
    if (Cy && e instanceof Set && t instanceof Set) {
      if (e.size !== t.size)
        return !1;
      for (s = e.entries(); !(r = s.next()).done; )
        if (!t.has(r.value[0]))
          return !1;
      return !0;
    }
    if (_y && ArrayBuffer.isView(e) && ArrayBuffer.isView(t)) {
      if (n = e.length, n != t.length)
        return !1;
      for (r = n; r-- !== 0; )
        if (e[r] !== t[r])
          return !1;
      return !0;
    }
    if (e.constructor === RegExp)
      return e.source === t.source && e.flags === t.flags;
    if (e.valueOf !== Object.prototype.valueOf && typeof e.valueOf == "function" && typeof t.valueOf == "function")
      return e.valueOf() === t.valueOf();
    if (e.toString !== Object.prototype.toString && typeof e.toString == "function" && typeof t.toString == "function")
      return e.toString() === t.toString();
    if (i = Object.keys(e), n = i.length, n !== Object.keys(t).length)
      return !1;
    for (r = n; r-- !== 0; )
      if (!Object.prototype.hasOwnProperty.call(t, i[r]))
        return !1;
    if (xy && e instanceof Element)
      return !1;
    for (r = n; r-- !== 0; )
      if (!((i[r] === "_owner" || i[r] === "__v" || i[r] === "__o") && e.$$typeof) && !jn(e[i[r]], t[i[r]]))
        return !1;
    return !0;
  }
  return e !== e && t !== t;
}
var Oy = function(t, n) {
  try {
    return jn(t, n);
  } catch (r) {
    if ((r.message || "").match(/stack|recursion/i))
      return console.warn("react-fast-compare cannot handle circular refs"), !1;
    throw r;
  }
};
const Ry = /* @__PURE__ */ Tn(Oy);
var Ot = {
  BODY: "bodyAttributes",
  HTML: "htmlAttributes",
  TITLE: "titleAttributes"
}, ae = {
  BASE: "base",
  BODY: "body",
  HEAD: "head",
  HTML: "html",
  LINK: "link",
  META: "meta",
  NOSCRIPT: "noscript",
  SCRIPT: "script",
  STYLE: "style",
  TITLE: "title"
}, oa = Object.keys(ae).map(function(e) {
  return ae[e];
}), Re = {
  CHARSET: "charset",
  CSS_TEXT: "cssText",
  HREF: "href",
  HTTPEQUIV: "http-equiv",
  INNER_HTML: "innerHTML",
  ITEM_PROP: "itemprop",
  NAME: "name",
  PROPERTY: "property",
  REL: "rel",
  SRC: "src",
  TARGET: "target"
}, Qn = {
  accesskey: "accessKey",
  charset: "charSet",
  class: "className",
  contenteditable: "contentEditable",
  contextmenu: "contextMenu",
  "http-equiv": "httpEquiv",
  itemprop: "itemProp",
  tabindex: "tabIndex"
}, vn = {
  DEFAULT_TITLE: "defaultTitle",
  DEFER: "defer",
  ENCODE_SPECIAL_CHARACTERS: "encodeSpecialCharacters",
  ON_CHANGE_CLIENT_STATE: "onChangeClientState",
  TITLE_TEMPLATE: "titleTemplate"
}, ky = Object.keys(Qn).reduce(function(e, t) {
  return e[Qn[t]] = t, e;
}, {}), My = [ae.NOSCRIPT, ae.SCRIPT, ae.STYLE], it = "data-react-helmet", Iy = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? function(e) {
  return typeof e;
} : function(e) {
  return e && typeof Symbol == "function" && e.constructor === Symbol && e !== Symbol.prototype ? "symbol" : typeof e;
}, Ly = function(e, t) {
  if (!(e instanceof t))
    throw new TypeError("Cannot call a class as a function");
}, Dy = function() {
  function e(t, n) {
    for (var r = 0; r < n.length; r++) {
      var i = n[r];
      i.enumerable = i.enumerable || !1, i.configurable = !0, "value" in i && (i.writable = !0), Object.defineProperty(t, i.key, i);
    }
  }
  return function(t, n, r) {
    return n && e(t.prototype, n), r && e(t, r), t;
  };
}(), Xe = Object.assign || function(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t];
    for (var r in n)
      Object.prototype.hasOwnProperty.call(n, r) && (e[r] = n[r]);
  }
  return e;
}, Vy = function(e, t) {
  if (typeof t != "function" && t !== null)
    throw new TypeError("Super expression must either be null or a function, not " + typeof t);
  e.prototype = Object.create(t && t.prototype, {
    constructor: {
      value: e,
      enumerable: !1,
      writable: !0,
      configurable: !0
    }
  }), t && (Object.setPrototypeOf ? Object.setPrototypeOf(e, t) : e.__proto__ = t);
}, sa = function(e, t) {
  var n = {};
  for (var r in e)
    t.indexOf(r) >= 0 || Object.prototype.hasOwnProperty.call(e, r) && (n[r] = e[r]);
  return n;
}, Ny = function(e, t) {
  if (!e)
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  return t && (typeof t == "object" || typeof t == "function") ? t : e;
}, pi = function(t) {
  var n = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : !0;
  return n === !1 ? String(t) : String(t).replace(/&/g, "&amp;").replace(/</g, "&lt;").replace(/>/g, "&gt;").replace(/"/g, "&quot;").replace(/'/g, "&#x27;");
}, By = function(t) {
  var n = zt(t, ae.TITLE), r = zt(t, vn.TITLE_TEMPLATE);
  if (r && n)
    return r.replace(/%s/g, function() {
      return Array.isArray(n) ? n.join("") : n;
    });
  var i = zt(t, vn.DEFAULT_TITLE);
  return n || i || void 0;
}, jy = function(t) {
  return zt(t, vn.ON_CHANGE_CLIENT_STATE) || function() {
  };
}, Wr = function(t, n) {
  return n.filter(function(r) {
    return typeof r[t] < "u";
  }).map(function(r) {
    return r[t];
  }).reduce(function(r, i) {
    return Xe({}, r, i);
  }, {});
}, $y = function(t, n) {
  return n.filter(function(r) {
    return typeof r[ae.BASE] < "u";
  }).map(function(r) {
    return r[ae.BASE];
  }).reverse().reduce(function(r, i) {
    if (!r.length)
      for (var s = Object.keys(i), o = 0; o < s.length; o++) {
        var a = s[o], c = a.toLowerCase();
        if (t.indexOf(c) !== -1 && i[c])
          return r.concat(i);
      }
    return r;
  }, []);
}, rn = function(t, n, r) {
  var i = {};
  return r.filter(function(s) {
    return Array.isArray(s[t]) ? !0 : (typeof s[t] < "u" && gi("Helmet: " + t + ' should be of type "Array". Instead found type "' + Iy(s[t]) + '"'), !1);
  }).map(function(s) {
    return s[t];
  }).reverse().reduce(function(s, o) {
    var a = {};
    o.filter(function(h) {
      for (var m = void 0, v = Object.keys(h), w = 0; w < v.length; w++) {
        var I = v[w], E = I.toLowerCase();
        n.indexOf(E) !== -1 && !(m === Re.REL && h[m].toLowerCase() === "canonical") && !(E === Re.REL && h[E].toLowerCase() === "stylesheet") && (m = E), n.indexOf(I) !== -1 && (I === Re.INNER_HTML || I === Re.CSS_TEXT || I === Re.ITEM_PROP) && (m = I);
      }
      if (!m || !h[m])
        return !1;
      var P = h[m].toLowerCase();
      return i[m] || (i[m] = {}), a[m] || (a[m] = {}), i[m][P] ? !1 : (a[m][P] = !0, !0);
    }).reverse().forEach(function(h) {
      return s.push(h);
    });
    for (var c = Object.keys(a), l = 0; l < c.length; l++) {
      var u = c[l], d = fy({}, i[u], a[u]);
      i[u] = d;
    }
    return s;
  }, []).reverse();
}, zt = function(t, n) {
  for (var r = t.length - 1; r >= 0; r--) {
    var i = t[r];
    if (i.hasOwnProperty(n))
      return i[n];
  }
  return null;
}, Fy = function(t) {
  return {
    baseTag: $y([Re.HREF, Re.TARGET], t),
    bodyAttributes: Wr(Ot.BODY, t),
    defer: zt(t, vn.DEFER),
    encode: zt(t, vn.ENCODE_SPECIAL_CHARACTERS),
    htmlAttributes: Wr(Ot.HTML, t),
    linkTags: rn(ae.LINK, [Re.REL, Re.HREF], t),
    metaTags: rn(ae.META, [Re.NAME, Re.CHARSET, Re.HTTPEQUIV, Re.PROPERTY, Re.ITEM_PROP], t),
    noscriptTags: rn(ae.NOSCRIPT, [Re.INNER_HTML], t),
    onChangeClientState: jy(t),
    scriptTags: rn(ae.SCRIPT, [Re.SRC, Re.INNER_HTML], t),
    styleTags: rn(ae.STYLE, [Re.CSS_TEXT], t),
    title: By(t),
    titleAttributes: Wr(Ot.TITLE, t)
  };
}, mi = function() {
  var e = Date.now();
  return function(t) {
    var n = Date.now();
    n - e > 16 ? (e = n, t(n)) : setTimeout(function() {
      mi(t);
    }, 0);
  };
}(), aa = function(t) {
  return clearTimeout(t);
}, Uy = typeof window < "u" ? window.requestAnimationFrame && window.requestAnimationFrame.bind(window) || window.webkitRequestAnimationFrame || window.mozRequestAnimationFrame || mi : global.requestAnimationFrame || mi, Hy = typeof window < "u" ? window.cancelAnimationFrame || window.webkitCancelAnimationFrame || window.mozCancelAnimationFrame || aa : global.cancelAnimationFrame || aa, gi = function(t) {
  return console && typeof console.warn == "function" && console.warn(t);
}, on = null, Wy = function(t) {
  on && Hy(on), t.defer ? on = Uy(function() {
    ca(t, function() {
      on = null;
    });
  }) : (ca(t), on = null);
}, ca = function(t, n) {
  var r = t.baseTag, i = t.bodyAttributes, s = t.htmlAttributes, o = t.linkTags, a = t.metaTags, c = t.noscriptTags, l = t.onChangeClientState, u = t.scriptTags, d = t.styleTags, h = t.title, m = t.titleAttributes;
  yi(ae.BODY, i), yi(ae.HTML, s), qy(h, m);
  var v = {
    baseTag: Nt(ae.BASE, r),
    linkTags: Nt(ae.LINK, o),
    metaTags: Nt(ae.META, a),
    noscriptTags: Nt(ae.NOSCRIPT, c),
    scriptTags: Nt(ae.SCRIPT, u),
    styleTags: Nt(ae.STYLE, d)
  }, w = {}, I = {};
  Object.keys(v).forEach(function(E) {
    var P = v[E], M = P.newTags, L = P.oldTags;
    M.length && (w[E] = M), L.length && (I[E] = v[E].oldTags);
  }), n && n(), l(t, w, I);
}, rl = function(t) {
  return Array.isArray(t) ? t.join("") : t;
}, qy = function(t, n) {
  typeof t < "u" && document.title !== t && (document.title = rl(t)), yi(ae.TITLE, n);
}, yi = function(t, n) {
  var r = document.getElementsByTagName(t)[0];
  if (r) {
    for (var i = r.getAttribute(it), s = i ? i.split(",") : [], o = [].concat(s), a = Object.keys(n), c = 0; c < a.length; c++) {
      var l = a[c], u = n[l] || "";
      r.getAttribute(l) !== u && r.setAttribute(l, u), s.indexOf(l) === -1 && s.push(l);
      var d = o.indexOf(l);
      d !== -1 && o.splice(d, 1);
    }
    for (var h = o.length - 1; h >= 0; h--)
      r.removeAttribute(o[h]);
    s.length === o.length ? r.removeAttribute(it) : r.getAttribute(it) !== a.join(",") && r.setAttribute(it, a.join(","));
  }
}, Nt = function(t, n) {
  var r = document.head || document.querySelector(ae.HEAD), i = r.querySelectorAll(t + "[" + it + "]"), s = Array.prototype.slice.call(i), o = [], a = void 0;
  return n && n.length && n.forEach(function(c) {
    var l = document.createElement(t);
    for (var u in c)
      if (c.hasOwnProperty(u))
        if (u === Re.INNER_HTML)
          l.innerHTML = c.innerHTML;
        else if (u === Re.CSS_TEXT)
          l.styleSheet ? l.styleSheet.cssText = c.cssText : l.appendChild(document.createTextNode(c.cssText));
        else {
          var d = typeof c[u] > "u" ? "" : c[u];
          l.setAttribute(u, d);
        }
    l.setAttribute(it, "true"), s.some(function(h, m) {
      return a = m, l.isEqualNode(h);
    }) ? s.splice(a, 1) : o.push(l);
  }), s.forEach(function(c) {
    return c.parentNode.removeChild(c);
  }), o.forEach(function(c) {
    return r.appendChild(c);
  }), {
    oldTags: s,
    newTags: o
  };
}, il = function(t) {
  return Object.keys(t).reduce(function(n, r) {
    var i = typeof t[r] < "u" ? r + '="' + t[r] + '"' : "" + r;
    return n ? n + " " + i : i;
  }, "");
}, zy = function(t, n, r, i) {
  var s = il(r), o = rl(n);
  return s ? "<" + t + " " + it + '="true" ' + s + ">" + pi(o, i) + "</" + t + ">" : "<" + t + " " + it + '="true">' + pi(o, i) + "</" + t + ">";
}, Ky = function(t, n, r) {
  return n.reduce(function(i, s) {
    var o = Object.keys(s).filter(function(l) {
      return !(l === Re.INNER_HTML || l === Re.CSS_TEXT);
    }).reduce(function(l, u) {
      var d = typeof s[u] > "u" ? u : u + '="' + pi(s[u], r) + '"';
      return l ? l + " " + d : d;
    }, ""), a = s.innerHTML || s.cssText || "", c = My.indexOf(t) === -1;
    return i + "<" + t + " " + it + '="true" ' + o + (c ? "/>" : ">" + a + "</" + t + ">");
  }, "");
}, ol = function(t) {
  var n = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
  return Object.keys(t).reduce(function(r, i) {
    return r[Qn[i] || i] = t[i], r;
  }, n);
}, Yy = function(t) {
  var n = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
  return Object.keys(t).reduce(function(r, i) {
    return r[ky[i] || i] = t[i], r;
  }, n);
}, Gy = function(t, n, r) {
  var i, s = (i = {
    key: n
  }, i[it] = !0, i), o = ol(r, s);
  return [je.createElement(ae.TITLE, o, n)];
}, Xy = function(t, n) {
  return n.map(function(r, i) {
    var s, o = (s = {
      key: i
    }, s[it] = !0, s);
    return Object.keys(r).forEach(function(a) {
      var c = Qn[a] || a;
      if (c === Re.INNER_HTML || c === Re.CSS_TEXT) {
        var l = r.innerHTML || r.cssText;
        o.dangerouslySetInnerHTML = { __html: l };
      } else
        o[c] = r[a];
    }), je.createElement(t, o);
  });
}, dt = function(t, n, r) {
  switch (t) {
    case ae.TITLE:
      return {
        toComponent: function() {
          return Gy(t, n.title, n.titleAttributes);
        },
        toString: function() {
          return zy(t, n.title, n.titleAttributes, r);
        }
      };
    case Ot.BODY:
    case Ot.HTML:
      return {
        toComponent: function() {
          return ol(n);
        },
        toString: function() {
          return il(n);
        }
      };
    default:
      return {
        toComponent: function() {
          return Xy(t, n);
        },
        toString: function() {
          return Ky(t, n, r);
        }
      };
  }
}, sl = function(t) {
  var n = t.baseTag, r = t.bodyAttributes, i = t.encode, s = t.htmlAttributes, o = t.linkTags, a = t.metaTags, c = t.noscriptTags, l = t.scriptTags, u = t.styleTags, d = t.title, h = d === void 0 ? "" : d, m = t.titleAttributes;
  return {
    base: dt(ae.BASE, n, i),
    bodyAttributes: dt(Ot.BODY, r, i),
    htmlAttributes: dt(Ot.HTML, s, i),
    link: dt(ae.LINK, o, i),
    meta: dt(ae.META, a, i),
    noscript: dt(ae.NOSCRIPT, c, i),
    script: dt(ae.SCRIPT, l, i),
    style: dt(ae.STYLE, u, i),
    title: dt(ae.TITLE, { title: h, titleAttributes: m }, i)
  };
}, Zy = function(t) {
  var n, r;
  return r = n = function(i) {
    Vy(s, i);
    function s() {
      return Ly(this, s), Ny(this, i.apply(this, arguments));
    }
    return s.prototype.shouldComponentUpdate = function(a) {
      return !Ry(this.props, a);
    }, s.prototype.mapNestedChildrenToProps = function(a, c) {
      if (!c)
        return null;
      switch (a.type) {
        case ae.SCRIPT:
        case ae.NOSCRIPT:
          return {
            innerHTML: c
          };
        case ae.STYLE:
          return {
            cssText: c
          };
      }
      throw new Error("<" + a.type + " /> elements are self-closing and can not contain children. Refer to our API for more information.");
    }, s.prototype.flattenArrayTypeChildren = function(a) {
      var c, l = a.child, u = a.arrayTypeChildren, d = a.newChildProps, h = a.nestedChildren;
      return Xe({}, u, (c = {}, c[l.type] = [].concat(u[l.type] || [], [Xe({}, d, this.mapNestedChildrenToProps(l, h))]), c));
    }, s.prototype.mapObjectTypeChildren = function(a) {
      var c, l, u = a.child, d = a.newProps, h = a.newChildProps, m = a.nestedChildren;
      switch (u.type) {
        case ae.TITLE:
          return Xe({}, d, (c = {}, c[u.type] = m, c.titleAttributes = Xe({}, h), c));
        case ae.BODY:
          return Xe({}, d, {
            bodyAttributes: Xe({}, h)
          });
        case ae.HTML:
          return Xe({}, d, {
            htmlAttributes: Xe({}, h)
          });
      }
      return Xe({}, d, (l = {}, l[u.type] = Xe({}, h), l));
    }, s.prototype.mapArrayTypeChildrenToProps = function(a, c) {
      var l = Xe({}, c);
      return Object.keys(a).forEach(function(u) {
        var d;
        l = Xe({}, l, (d = {}, d[u] = a[u], d));
      }), l;
    }, s.prototype.warnOnInvalidChildren = function(a, c) {
      if (process.env.NODE_ENV !== "production") {
        if (!oa.some(function(l) {
          return a.type === l;
        }))
          return typeof a.type == "function" ? gi("You may be attempting to nest <Helmet> components within each other, which is not allowed. Refer to our API for more information.") : gi("Only elements types " + oa.join(", ") + " are allowed. Helmet does not support rendering <" + a.type + "> elements. Refer to our API for more information.");
        if (c && typeof c != "string" && (!Array.isArray(c) || c.some(function(l) {
          return typeof l != "string";
        })))
          throw new Error("Helmet expects a string as a child of <" + a.type + ">. Did you forget to wrap your children in braces? ( <" + a.type + ">{``}</" + a.type + "> ) Refer to our API for more information.");
      }
      return !0;
    }, s.prototype.mapChildrenToProps = function(a, c) {
      var l = this, u = {};
      return je.Children.forEach(a, function(d) {
        if (!(!d || !d.props)) {
          var h = d.props, m = h.children, v = sa(h, ["children"]), w = Yy(v);
          switch (l.warnOnInvalidChildren(d, m), d.type) {
            case ae.LINK:
            case ae.META:
            case ae.NOSCRIPT:
            case ae.SCRIPT:
            case ae.STYLE:
              u = l.flattenArrayTypeChildren({
                child: d,
                arrayTypeChildren: u,
                newChildProps: w,
                nestedChildren: m
              });
              break;
            default:
              c = l.mapObjectTypeChildren({
                child: d,
                newProps: c,
                newChildProps: w,
                nestedChildren: m
              });
              break;
          }
        }
      }), c = this.mapArrayTypeChildrenToProps(u, c), c;
    }, s.prototype.render = function() {
      var a = this.props, c = a.children, l = sa(a, ["children"]), u = Xe({}, l);
      return c && (u = this.mapChildrenToProps(c, u)), je.createElement(t, u);
    }, Dy(s, null, [{
      key: "canUseDOM",
      // Component.peek comes from react-side-effect:
      // For testing, you may use a static peek() method available on the returned component.
      // It lets you get the current state without resetting the mounted instance stack.
      // Dont use it for anything other than testing.
      /**
       * @param {Object} base: {"target": "_blank", "href": "http://mysite.com/"}
       * @param {Object} bodyAttributes: {"className": "root"}
       * @param {String} defaultTitle: "Default Title"
       * @param {Boolean} defer: true
       * @param {Boolean} encodeSpecialCharacters: true
       * @param {Object} htmlAttributes: {"lang": "en", "amp": undefined}
       * @param {Array} link: [{"rel": "canonical", "href": "http://mysite.com/example"}]
       * @param {Array} meta: [{"name": "description", "content": "Test description"}]
       * @param {Array} noscript: [{"innerHTML": "<img src='http://mysite.com/js/test.js'"}]
       * @param {Function} onChangeClientState: "(newState) => console.log(newState)"
       * @param {Array} script: [{"type": "text/javascript", "src": "http://mysite.com/js/test.js"}]
       * @param {Array} style: [{"type": "text/css", "cssText": "div { display: block; color: blue; }"}]
       * @param {String} title: "Title"
       * @param {Object} titleAttributes: {"itemprop": "name"}
       * @param {String} titleTemplate: "MySite.com - %s"
       */
      set: function(a) {
        t.canUseDOM = a;
      }
    }]), s;
  }(je.Component), n.propTypes = {
    base: Oe.object,
    bodyAttributes: Oe.object,
    children: Oe.oneOfType([Oe.arrayOf(Oe.node), Oe.node]),
    defaultTitle: Oe.string,
    defer: Oe.bool,
    encodeSpecialCharacters: Oe.bool,
    htmlAttributes: Oe.object,
    link: Oe.arrayOf(Oe.object),
    meta: Oe.arrayOf(Oe.object),
    noscript: Oe.arrayOf(Oe.object),
    onChangeClientState: Oe.func,
    script: Oe.arrayOf(Oe.object),
    style: Oe.arrayOf(Oe.object),
    title: Oe.string,
    titleAttributes: Oe.object,
    titleTemplate: Oe.string
  }, n.defaultProps = {
    defer: !0,
    encodeSpecialCharacters: !0
  }, n.peek = t.peek, n.rewind = function() {
    var i = t.rewind();
    return i || (i = sl({
      baseTag: [],
      bodyAttributes: {},
      encodeSpecialCharacters: !0,
      htmlAttributes: {},
      linkTags: [],
      metaTags: [],
      noscriptTags: [],
      scriptTags: [],
      styleTags: [],
      title: "",
      titleAttributes: {}
    })), i;
  }, r;
}, Jy = function() {
  return null;
}, Qy = Sy(Fy, Wy, sl)(Jy), vi = Zy(Qy);
vi.renderStatic = vi.rewind;
function hv({
  children: e,
  theme: t = Kr,
  config: n = Cf
}) {
  const [r, i] = Sl(sy, {
    ...Ti,
    config: n
  });
  Te(() => {
    i({
      type: "UPDATE_CONFIG",
      payload: n
    });
  }, [n]);
  const s = ze(
    () => ({
      ...Kr,
      ...t
    }),
    [t]
  );
  return /* @__PURE__ */ K(fa.Provider, { value: { state: r, dispatch: i }, children: /* @__PURE__ */ K(
    pu,
    {
      theme: {
        ...s.displayTheme === "light" ? wa : hu,
        displayTheme: s.displayTheme || "light",
        theme: du(s.accent),
        themeConfig: s
      },
      children: /* @__PURE__ */ ye(ev, { children: [
        /* @__PURE__ */ ye(vi, { children: [
          /* @__PURE__ */ K("link", { rel: "preconnect", href: "https://fonts.googleapis.com" }),
          /* @__PURE__ */ K(
            "link",
            {
              rel: "preconnect",
              href: "https://fonts.gstatic.com",
              crossOrigin: ""
            }
          ),
          /* @__PURE__ */ K(
            "link",
            {
              href: "https://fonts.googleapis.com/css2?family=Manrope:wght@400;500;600;700;800&display=swap",
              rel: "stylesheet"
            }
          )
        ] }),
        e,
        /* @__PURE__ */ K(Pg, {}),
        /* @__PURE__ */ K(qg, {}),
        /* @__PURE__ */ K(Gm, {})
      ] })
    }
  ) });
}
const ev = ({ children: e }) => (gu(), Cl(), /* @__PURE__ */ K(hn, { children: e }));
export {
  hv as ArweaveWalletKit,
  fv as ConnectButton,
  er as useActiveAddress,
  _l as useAddresses,
  av as useApi,
  _i as useConnection,
  mu as usePermissions,
  wu as useProfileModal,
  cv as usePublicKey,
  sv as useStrategy,
  lv as useWalletNames
};
